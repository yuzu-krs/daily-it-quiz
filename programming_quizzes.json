[
  {
    "id": 641,
    "question": "Javaの「JVM（Java Virtual Machine）」の役割として正しいものはどれか？",
    "options": [
      "A. Javaソースコードをネイティブコードに直接コンパイルする",
      "B. バイトコードを解釈しプラットフォーム非依存で実行する機構",
      "C. Javaのソースコードを自動的にデバッグする開発支援ツール",
      "D. Javaのパッケージ管理とライブラリ配布を行うツール機構"
    ],
    "correct": 1,
    "explanation": "JVMはJavaバイトコードを各OS向けに解釈・実行する仮想マシンで、Write Once, Run Anywhereを実現します。"
  },
  {
    "id": 642,
    "question": "Pythonのリスト内包表記として正しい構文はどれか？",
    "options": [
      "A. [for x in range(10): x*2]",
      "B. [x*2 for x in range(10)]",
      "C. [x*2: for x in range(10)]",
      "D. {x*2 for x in range(10)}"
    ],
    "correct": 1,
    "explanation": "Pythonのリスト内包表記は[式 for 変数 in イテラブル]の形式です。Dの{}はセット内包表記になります。"
  },
  {
    "id": 643,
    "question": "JavaScriptの「===」演算子の動作として正しいものはどれか？",
    "options": [
      "A. 値のみを比較し型変換を行って一致を判定する演算子",
      "B. 値と型の両方を比較し型変換を行わずに判定する演算子",
      "C. オブジェクトの参照先の値を再帰的に比較する演算子",
      "D. 値の大小関係を比較して真偽値を返す比較演算子のこと"
    ],
    "correct": 1,
    "explanation": "===（厳密等価演算子）は型変換を行わず、値と型の両方が一致する場合にtrueを返します。==は型変換を行います。"
  },
  {
    "id": 644,
    "question": "TypeScriptの「interface」と「type」の違いとして正しいものはどれか？",
    "options": [
      "A. interfaceは宣言マージが可能だがtypeはできない違い",
      "B. typeはオブジェクト型のみ定義できるがinterfaceは万能",
      "C. interfaceはプリミティブ型のエイリアスが定義可能な違い",
      "D. typeとinterfaceは完全に同じ機能で名前だけが異なる"
    ],
    "correct": 0,
    "explanation": "interfaceは同名の宣言が自動マージされますが、typeは再宣言できません。typeはユニオン型やプリミティブの別名定義が可能です。"
  },
  {
    "id": 645,
    "question": "C言語の「ポインタ」の説明として正しいものはどれか？",
    "options": [
      "A. 変数の値そのものをコピーして保持する特殊な変数のこと",
      "B. メモリ上のアドレスを格納する変数のことを指す概念のこと",
      "C. 動的にサイズが変わる配列を実現する仕組みのことを指す",
      "D. 関数の戻り値を一時的にキャッシュする仕組みのことを指す"
    ],
    "correct": 1,
    "explanation": "ポインタはメモリのアドレスを格納する変数です。間接参照（デリファレンス）でそのアドレスの値にアクセスできます。"
  },
  {
    "id": 646,
    "question": "C++の「RAII」パターンの説明として正しいものはどれか？",
    "options": [
      "A. 例外処理を使わずにエラーをハンドリングする設計手法",
      "B. リソース取得と初期化を結びつけ解放を自動化する手法",
      "C. ランタイム型情報を使って動的にキャストする手法のこと",
      "D. コンパイル時にテンプレートを展開して最適化する手法"
    ],
    "correct": 1,
    "explanation": "RAII（Resource Acquisition Is Initialization）はコンストラクタでリソースを取得し、デストラクタで自動解放する手法です。"
  },
  {
    "id": 647,
    "question": "Go言語の「ゴルーチン（goroutine）」の特徴はどれか？",
    "options": [
      "A. OSスレッドと1対1で対応する重量な並行処理の単位のこと",
      "B. 軽量なスレッドでGoランタイムが多重化して管理する単位",
      "C. プロセスをフォークして並列処理を実現する仕組みのこと",
      "D. コルーチンと同一でシングルスレッドで協調動作する仕組み"
    ],
    "correct": 1,
    "explanation": "ゴルーチンはGoランタイムが管理する軽量スレッドで、少数のOSスレッド上に多数のゴルーチンを多重化して実行します。"
  },
  {
    "id": 648,
    "question": "Rustの「所有権（ownership）」システムの目的はどれか？",
    "options": [
      "A. ガベージコレクションを使ってメモリを自動管理する目的",
      "B. コンパイル時にメモリ安全性を保証しGCなしで管理する",
      "C. 参照カウントでメモリリークを防止する目的で使用する機構",
      "D. 仮想メモリを使ってメモリ使用量を最適化する目的の仕組み"
    ],
    "correct": 1,
    "explanation": "Rustの所有権システムはコンパイル時にメモリの解放タイミングを決定し、GCなしでメモリ安全性を保証します。"
  },
  {
    "id": 649,
    "question": "「静的型付け言語」の特徴として正しいものはどれか？",
    "options": [
      "A. 実行時に変数の型が決定されタイプエラーが実行時に発生",
      "B. コンパイル時に型チェックが行われ型エラーが事前に検出",
      "C. 変数に型の宣言が不要で型推論も行われない言語のこと",
      "D. 同じ変数に異なる型の値を自由に代入できる言語のこと"
    ],
    "correct": 1,
    "explanation": "静的型付け言語はコンパイル時に型チェックが行われ、型の不整合が実行前に検出されます。Java、C、TypeScript等が該当します。"
  },
  {
    "id": 650,
    "question": "「コンパイラ」と「インタプリタ」の違いとして正しいものはどれか？",
    "options": [
      "A. コンパイラは実行時に逐次変換しインタプリタは一括変換",
      "B. コンパイラは事前に一括変換しインタプリタは逐次解釈実行",
      "C. コンパイラはスクリプト言語用でインタプリタはシステム言語用",
      "D. コンパイラもインタプリタも同じ動作で名称が異なるだけのもの"
    ],
    "correct": 1,
    "explanation": "コンパイラはソースコード全体を事前に機械語に変換します。インタプリタは実行時にソースコードを一行ずつ解釈・実行します。"
  },
  {
    "id": 651,
    "question": "「OOP（オブジェクト指向プログラミング）」の三大要素はどれか？",
    "options": [
      "A. 変数、関数、モジュールの三つが三大要素として定義",
      "B. カプセル化、継承、ポリモーフィズムが三大要素として定義",
      "C. 抽象化、再帰、並行性の三つが三大要素として定義される",
      "D. クラス、メソッド、プロパティの三つが三大要素として定義"
    ],
    "correct": 1,
    "explanation": "OOPの三大要素はカプセル化（データ隠蔽）、継承（機能の再利用）、ポリモーフィズム（多態性）です。"
  },
  {
    "id": 652,
    "question": "デザインパターンの「Singleton」の目的として正しいものはどれか？",
    "options": [
      "A. オブジェクトの生成と利用を分離して柔軟性を高める目的",
      "B. クラスのインスタンスが1つだけ存在することを保証する目的",
      "C. オブジェクトの状態変化を他のオブジェクトに通知する目的",
      "D. 複雑なオブジェクトの構築過程を段階的に行うための目的"
    ],
    "correct": 1,
    "explanation": "Singletonパターンはクラスのインスタンスがシステム内に1つだけ存在することを保証し、グローバルなアクセスポイントを提供します。"
  },
  {
    "id": 653,
    "question": "JavaScriptの非同期処理で「Promise」の3つの状態はどれか？",
    "options": [
      "A. start, running, stopped の3状態で構成される",
      "B. pending, fulfilled, rejected の3状態で構成される",
      "C. open, closed, error の3状態で構成されるものである",
      "D. init, success, failure の3状態で構成されるものである"
    ],
    "correct": 1,
    "explanation": "Promiseはpending（保留中）、fulfilled（成功）、rejected（失敗）の3状態を持ちます。一度決定すると状態は変わりません。"
  },
  {
    "id": 654,
    "question": "Pythonの「デコレータ」の説明として正しいものはどれか？",
    "options": [
      "A. クラスの継承関係を定義するための構文のことを指す仕組み",
      "B. 関数やクラスの機能を修飾・拡張するラッパーの仕組み",
      "C. 例外処理のハンドラを定義するための構文のことを指す機構",
      "D. モジュールのインポート順序を制御するための仕組みのこと"
    ],
    "correct": 1,
    "explanation": "デコレータは@記法で関数やクラスを修飾し、元の機能を変更せずに追加機能を付与するラッパー関数です。"
  },
  {
    "id": 655,
    "question": "C言語でメモリリークが発生する原因として正しいものはどれか？",
    "options": [
      "A. スタック上の変数が関数終了後に解放されない場合に発生",
      "B. malloc等で確保したメモリをfreeせず参照を失った場合",
      "C. 変数のスコープが広すぎる場合に自動的に発生する問題",
      "D. ポインタが正しい型にキャストされていない場合に発生する"
    ],
    "correct": 1,
    "explanation": "malloc/calloc等で動的に確保したメモリをfreeせずにポインタを失うと、そのメモリは回収不能になりメモリリークが発生します。"
  },
  {
    "id": 656,
    "question": "デザインパターンの「Observer」の説明として正しいものはどれか？",
    "options": [
      "A. オブジェクト生成をサブクラスに委譲するパターンのこと",
      "B. 状態の変化を依存オブジェクトに自動通知するパターン",
      "C. 複雑なサブシステムへの統一インターフェースを提供する",
      "D. 処理の骨格を定義し詳細をサブクラスで実装するパターン"
    ],
    "correct": 1,
    "explanation": "Observerパターンはサブジェクトの状態変化をオブザーバーに自動通知する1対多の依存関係を実現するパターンです。"
  },
  {
    "id": 657,
    "question": "Go言語にないOOP機能として正しいものはどれか？",
    "options": [
      "A. インターフェースによるポリモーフィズムはない機能",
      "B. クラスの継承（extends）がない設計になっている言語",
      "C. 構造体にメソッドを定義する機能がない設計の言語",
      "D. 構造体の埋め込みによるコンポジションがない設計"
    ],
    "correct": 1,
    "explanation": "Goにはクラスや継承（extends）がありません。代わりに構造体の埋め込み（composition）とインターフェースを使います。"
  },
  {
    "id": 658,
    "question": "Rustの「借用（borrowing）」のルールとして正しいものはどれか？",
    "options": [
      "A. 一度に複数の可変参照を持つことが可能であるルールのこと",
      "B. 可変参照が存在する間は不変参照を持てないルールが適用",
      "C. 不変参照中でも可変参照を同時に持てるルールが適用される",
      "D. 借用は参照カウントで管理され実行時にチェックされるもの"
    ],
    "correct": 1,
    "explanation": "Rustでは任意の時点で「複数の不変参照」か「1つの可変参照」のどちらかしか存在できません。これによりデータ競合を防ぎます。"
  },
  {
    "id": 659,
    "question": "JavaScriptの「クロージャ」の説明として正しいものはどれか？",
    "options": [
      "A. try-catch文で例外を捕捉する仕組みのことを指す概念処理",
      "B. 外側の関数のスコープの変数を参照し続ける内側の関数",
      "C. オブジェクトのプロパティに直接アクセスする仕組みのこと",
      "D. for文やwhile文のループを途中で終了させる仕組みのこと"
    ],
    "correct": 1,
    "explanation": "クロージャは関数が定義されたスコープの変数を「覚えている」内部関数です。外部関数が終了しても変数にアクセスできます。"
  },
  {
    "id": 660,
    "question": "「ジェネリクス（Generics）」の目的として正しいものはどれか？",
    "options": [
      "A. 実行時に動的に型を変更して柔軟な処理を実現する目的",
      "B. 型をパラメータ化し型安全かつ再利用可能なコードを書く",
      "C. 変数に型を付けずに自由な値を代入可能にする目的のもの",
      "D. コンパイル時に型情報をすべて削除する最適化の目的うため"
    ],
    "correct": 1,
    "explanation": "ジェネリクスは型をパラメータとして受け取ることで、型安全性を維持しつつ汎用的・再利用可能なコードを記述できます。"
  },
  {
    "id": 661,
    "question": "Pythonの「GIL（Global Interpreter Lock）」の影響はどれか？",
    "options": [
      "A. マルチプロセスの並列実行が制限される影響が出るもの",
      "B. マルチスレッドでもCPUバウンド処理は並列実行されない",
      "C. 非同期処理（async/await）の使用が制限される影響出る",
      "D. I/O処理がシングルスレッドでしか実行できない影響のもの"
    ],
    "correct": 1,
    "explanation": "GILによりCPythonではマルチスレッドでもCPUバウンドな処理は一度に1スレッドしか実行できません。I/OやマルチプロセスはGILの影響を受けません。"
  },
  {
    "id": 662,
    "question": "デザインパターンの「Factory Method」の目的はどれか？",
    "options": [
      "A. クラスのインスタンスを1つに制限するための目的で使用する",
      "B. オブジェクト生成をサブクラスに委譲し拡張性を高める目的",
      "C. オブジェクトの構造を再帰的に構成するための目的で使用する",
      "D. 異なるインターフェースを持つクラスを統合する目的で使用"
    ],
    "correct": 1,
    "explanation": "Factory Methodパターンはオブジェクト生成のインターフェースを定義し、具体的な生成処理をサブクラスに委譲して拡張性を確保します。"
  },
  {
    "id": 663,
    "question": "TypeScriptの「enum」の説明として正しいものはどれか？",
    "options": [
      "A. 動的に値を追加できる可変長の配列型のことを指す型定義",
      "B. 名前付き定数の集合を定義する列挙型の仕組みのことを指す",
      "C. 型のユニオンを自動的に生成する機能のことを指す型定義",
      "D. ジェネリック型の制約を定義する仕組みのことを指す型定義"
    ],
    "correct": 1,
    "explanation": "enumは名前付き定数の集合を定義する列挙型です。数値enum（デフォルト）と文字列enumがあります。"
  },
  {
    "id": 664,
    "question": "Javaの「ガベージコレクション」の動作として正しいものはどれか？",
    "options": [
      "A. プログラマが明示的にdelete演算子で呼び出す必要がある",
      "B. 参照されなくなったオブジェクトのメモリをJVMが自動回収",
      "C. プログラムの終了時にのみ一括でメモリが解放される仕組み",
      "D. コンパイル時に不要なメモリ領域を検出して最適化する処理"
    ],
    "correct": 1,
    "explanation": "JavaのGCはJVMが実行時に参照されなくなったオブジェクトを自動検出し、そのメモリ領域を解放します。"
  },
  {
    "id": 665,
    "question": "「アロー関数」を持たない言語として正しいものはどれか？",
    "options": [
      "A. JavaScript（ES6以降の仕様として提供されている）",
      "B. Java（Java 8以降のラムダ式として提供されている言語）",
      "C. C言語（関数ポインタのみで無名関数は持たない言語）",
      "D. TypeScript（JavaScriptの上位互換として提供されている）"
    ],
    "correct": 2,
    "explanation": "C言語にはアロー関数やラムダ式はありません。関数ポインタで関数を値として扱えますが、無名関数の構文はありません。"
  },
  {
    "id": 666,
    "question": "Pythonの「with文」の目的として正しいものはどれか？",
    "options": [
      "A. 条件分岐を簡潔に記述するための構文のことを指す仕組み",
      "B. リソースの確保と解放を自動的に管理するコンテキスト管理",
      "C. ループ処理を簡潔に記述するための構文のことを指す仕組み",
      "D. 例外を無視して処理を継続するための構文のことを指す仕組"
    ],
    "correct": 1,
    "explanation": "with文はコンテキストマネージャを使い、ブロック終了時にリソース（ファイル、接続等）を自動的に解放します。"
  },
  {
    "id": 667,
    "question": "GoのエラーハンドリングでJavaのtry-catchに相当する仕組みはどれか？",
    "options": [
      "A. try-except文を使って例外を捕捉する仕組みが存在する",
      "B. 関数の戻り値としてerror型を返し呼び出し側で確認する",
      "C. throw-catch文で例外を投げて捕捉する仕組みが存在",
      "D. begin-rescue文で例外処理を行う仕組みが存在するもの"
    ],
    "correct": 1,
    "explanation": "Goには例外機構がなく、関数の戻り値としてerror型を返し、呼び出し側でif err != nilで確認するのが慣例です。"
  },
  {
    "id": 668,
    "question": "デザインパターンの「Strategy」の説明として正しいものはどれか？",
    "options": [
      "A. オブジェクトの内部状態に応じて振る舞いを変えるパターン",
      "B. アルゴリズム群を個別に定義し実行時に切り替え可能にする",
      "C. 処理を連鎖的に次のハンドラに委譲するパターンのこと指す",
      "D. オブジェクトの構造を走査して処理を適用するパターン指す"
    ],
    "correct": 1,
    "explanation": "Strategyパターンはアルゴリズム（戦略）をクラスとして分離し、実行時にアルゴリズムを切り替え可能にするパターンです。"
  },
  {
    "id": 669,
    "question": "Javaの「Stream API」の特徴として正しいものはどれか？",
    "options": [
      "A. ファイルの入出力ストリームを管理するAPIのことを指す",
      "B. コレクションに対する関数型操作をパイプラインで記述する",
      "C. ネットワークソケットのデータストリームを処理するもの",
      "D. マルチスレッドの制御フローを管理するAPIのことを指す機能"
    ],
    "correct": 1,
    "explanation": "Stream APIはコレクションに対してfilter, map, reduce等の関数型操作をパイプラインで宣言的に記述できるJava 8の機能です。"
  },
  {
    "id": 670,
    "question": "「ダックタイピング」の説明として正しいものはどれか？",
    "options": [
      "A. 明示的な型宣言に基づいてオブジェクトの型を判定する方式",
      "B. オブジェクトの振る舞い（メソッド）で型の適合性を判断する",
      "C. 継承関係に基づいてオブジェクトの型の互換性を判定する方式",
      "D. インターフェースの明示的な実装宣言で型を判定する方式手法"
    ],
    "correct": 1,
    "explanation": "ダックタイピングは「アヒルのように歩き鳴くならアヒルだ」の考えで、型ではなくメソッドの有無で互換性を判断します。Python等で使われます。"
  }
]
