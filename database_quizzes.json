[
  {
    "id": 611,
    "question": "SQLの「INNER JOIN」の動作として正しいものはどれか？",
    "options": [
      "A. 左テーブルの全行と右テーブルの一致行を結合する",
      "B. 両テーブルの結合条件に一致する行のみを返す結合",
      "C. 右テーブルの全行と左テーブルの一致行を結合する",
      "D. 両テーブルの全行のデカルト積を返す結合方式のこと"
    ],
    "correct": 1,
    "explanation": "INNER JOINは両方のテーブルで結合条件に一致する行のみを返します。LEFT JOINは左テーブルの全行を含みます。"
  },
  {
    "id": 612,
    "question": "SQLの「LEFT JOIN」で右テーブルに一致がない場合の結果はどれか？",
    "options": [
      "A. その行は結果から除外されて表示されない状態になる",
      "B. 右テーブルの列がNULLで埋められて結果に含まれる",
      "C. エラーが発生してクエリの実行が中断される結果になる",
      "D. 右テーブルの列がデフォルト値で埋められて結果に含まれ"
    ],
    "correct": 1,
    "explanation": "LEFT JOINでは左テーブルの全行が保持され、右テーブルに一致がない場合は右テーブルの列がNULLになります。"
  },
  {
    "id": 613,
    "question": "データベースの「インデックス」の主な効果として正しいものはどれか？",
    "options": [
      "A. データの物理的な格納順序を変更して最適化する効果",
      "B. 検索クエリの実行速度を向上させるがINSERTは遅くなる",
      "C. データの整合性制約を自動的に適用する仕組みのこと",
      "D. データの暗号化を行いセキュリティを向上させる効果"
    ],
    "correct": 1,
    "explanation": "インデックスはB-tree等の構造でSELECTの検索を高速化しますが、INSERT/UPDATE/DELETE時にインデックスの更新コストが発生します。"
  },
  {
    "id": 614,
    "question": "トランザクションのACID特性の「I（Isolation）」の意味はどれか？",
    "options": [
      "A. トランザクションが完了したら変更が永続化されること",
      "B. 同時実行中のトランザクションが互いに影響しないこと",
      "C. トランザクション内の操作がすべて成功か全て失敗すること",
      "D. データベースの整合性制約が常に維持されることを指す"
    ],
    "correct": 1,
    "explanation": "Isolation（分離性）は同時に実行されるトランザクションが互いに干渉しないことを保証する特性です。"
  },
  {
    "id": 615,
    "question": "データベースの「第3正規形」の条件として正しいものはどれか？",
    "options": [
      "A. 繰り返しグループが排除されている状態のことを指す",
      "B. 第2正規形を満たし推移的関数従属が排除された状態",
      "C. 主キーの一部への部分関数従属が排除された状態のこと",
      "D. すべての属性がアトミック（原子的）な値である状態"
    ],
    "correct": 1,
    "explanation": "第3正規形は第2正規形を満たし、非キー属性間の推移的関数従属が排除された状態です。A→B→Cのような依存を除去します。"
  },
  {
    "id": 616,
    "question": "NoSQLデータベースの分類として正しくないものはどれか？",
    "options": [
      "A. キーバリュー型（Redis、DynamoDB等が該当する）",
      "B. リレーショナル型（PostgreSQL、MySQL等が該当する）",
      "C. ドキュメント型（MongoDB、CouchDB等が該当する）",
      "D. グラフ型（Neo4j、Amazon Neptune等が該当する）"
    ],
    "correct": 1,
    "explanation": "リレーショナル型はRDBMSでありNoSQLではありません。NoSQLにはKVS、ドキュメント、カラムファミリ、グラフ型があります。"
  },
  {
    "id": 617,
    "question": "Redisの主な特徴として正しい説明はどれか？",
    "options": [
      "A. ディスクベースのリレーショナルデータベースである",
      "B. インメモリのキーバリューストアで高速アクセスが特徴",
      "C. ドキュメント指向のデータベースでJSON保存が特徴的",
      "D. カラムファミリ型で大量の書き込みに最適化されている"
    ],
    "correct": 1,
    "explanation": "Redisはインメモリで動作するキーバリューストアで、文字列・リスト・ハッシュ等の多彩なデータ型をサポートし高速です。"
  },
  {
    "id": 618,
    "question": "MongoDBのデータ格納形式として正しいものはどれか？",
    "options": [
      "A. テーブルと行で構成されるリレーショナル形式を使用",
      "B. BSON（Binary JSON）形式のドキュメントとして格納する",
      "C. キーと値のペアのみで構成されるシンプルな形式を使用",
      "D. ノードとエッジで構成されるグラフ形式で格納する方法"
    ],
    "correct": 1,
    "explanation": "MongoDBはBSON（Binary JSON）形式でドキュメントを格納するドキュメント型NoSQLデータベースです。スキーマレスで柔軟です。"
  },
  {
    "id": 619,
    "question": "データベースの「レプリケーション」の主な目的はどれか？",
    "options": [
      "A. データを複数テーブルに分割して検索を高速化する目的",
      "B. データを複数ノードに複製して可用性と読取性能を向上",
      "C. データの不要部分を削除してストレージを最適化する目的",
      "D. データのスキーマを自動的に変更して最適化する目的処理"
    ],
    "correct": 1,
    "explanation": "レプリケーションはデータベースのデータを別のノードに複製し、障害時の可用性確保と読み取りの負荷分散を実現します。"
  },
  {
    "id": 620,
    "question": "データベースの「シャーディング」の説明として正しいものはどれか？",
    "options": [
      "A. データの完全なコピーを複数ノードに配置する手法のこと",
      "B. データを水平分割して複数ノードに分散配置する手法のこと",
      "C. データの古い部分をアーカイブストレージに移動する手法",
      "D. データのインデックスを複数ノードに分散させる手法のこと"
    ],
    "correct": 1,
    "explanation": "シャーディングはデータを水平に分割（シャードキーに基づく）して複数ノードに分散配置し、書き込みと読み取りの両方をスケールさせます。"
  },
  {
    "id": 621,
    "question": "SQLの「GROUP BY」句の説明として正しいものはどれか？",
    "options": [
      "A. 結果セットを指定した列の値でソートして出力する句",
      "B. 指定した列の値でグループ化し集約関数を適用する句",
      "C. 結果セットから重複行を除去して出力するための句のこと",
      "D. 結合条件を指定してテーブルを結合するための句のこと"
    ],
    "correct": 1,
    "explanation": "GROUP BYは指定した列の値が同じ行をグループ化し、COUNT、SUM、AVG等の集約関数を各グループに適用します。"
  },
  {
    "id": 622,
    "question": "SQLの「HAVING」句の用途として正しいものはどれか？",
    "options": [
      "A. WHERE句と同じで行レベルの条件フィルタリングに使う",
      "B. GROUP BYでグループ化した結果に対して条件を付ける句",
      "C. JOINの結合条件を指定するために使用される句のことである",
      "D. サブクエリの結果に対して条件を付けるために使う句のこと"
    ],
    "correct": 1,
    "explanation": "HAVING句はGROUP BYでグループ化された結果に対して集約関数の条件を指定します。WHEREはグループ化前の行に適用されます。"
  },
  {
    "id": 623,
    "question": "「デッドロック」の説明として正しいものはどれか？",
    "options": [
      "A. トランザクションがタイムアウトで自動的に中断される状態",
      "B. 複数トランザクションが互いのロック解放を待ち永遠に停止",
      "C. データベースのディスク容量がゼロになり書込み不能な状態",
      "D. インデックスが破損してクエリが正常に実行できない状態"
    ],
    "correct": 1,
    "explanation": "デッドロックは2つ以上のトランザクションが互いにロックの解放を待ち合い、どちらも進行できなくなる状態です。"
  },
  {
    "id": 624,
    "question": "SQLの「サブクエリ」の説明として正しいものはどれか？",
    "options": [
      "A. 複数のSELECT結果を結合するUNION操作のことを指す",
      "B. SQL文の中に入れ子で含まれる別のSELECT文のことを指す",
      "C. トランザクション内で実行される個々のSQL文のことを指す",
      "D. ストアドプロシージャ内で呼び出される関数のことを指す"
    ],
    "correct": 1,
    "explanation": "サブクエリはSELECT、WHERE、FROM句の中にネスト（入れ子）されたSELECT文で、外部クエリの条件として使用されます。"
  },
  {
    "id": 625,
    "question": "データベースの「ビュー（VIEW）」の説明として正しいものはどれか？",
    "options": [
      "A. データを物理的に格納する実テーブルの別名のことを指す",
      "B. SELECT文の結果を仮想テーブルとして定義したものである",
      "C. インデックスの一種で検索速度を改善するための仕組み",
      "D. データの一時的なバックアップを保存する領域のことを指す"
    ],
    "correct": 1,
    "explanation": "ビューはSELECT文を保存した仮想テーブルで、データを物理的に持ちません。複雑なクエリの簡略化やアクセス制御に使われます。"
  },
  {
    "id": 626,
    "question": "CAP定理の3つの特性として正しい組み合わせはどれか？",
    "options": [
      "A. Consistency, Availability, Performance",
      "B. Consistency, Availability, Partition tolerance",
      "C. Concurrency, Availability, Partition tolerance",
      "D. Consistency, Atomicity, Partition tolerance"
    ],
    "correct": 1,
    "explanation": "CAP定理は一貫性（Consistency）、可用性（Availability）、分断耐性（Partition tolerance）の3つで、分散システムは同時に2つまでしか保証できません。"
  },
  {
    "id": 627,
    "question": "SQLの「EXPLAIN」コマンドの用途として正しいものはどれか？",
    "options": [
      "A. テーブルのスキーマ定義を詳細に表示するコマンド操作",
      "B. クエリの実行計画を表示しパフォーマンス分析に使用する",
      "C. テーブルのデータを読みやすい形式で出力するコマンド",
      "D. データベースのバックアップを作成するコマンド操作のこと"
    ],
    "correct": 1,
    "explanation": "EXPLAINはクエリの実行計画（インデックスの使用有無、スキャン方式等）を表示し、パフォーマンスチューニングに使います。"
  },
  {
    "id": 628,
    "question": "「N+1問題」の説明として正しいものはどれか？",
    "options": [
      "A. N個のテーブルを結合する際にN+1回のJOINが必要になる",
      "B. 1回の一覧取得後に各行ごとに追加クエリが発行される問題",
      "C. N個のインデックスに対してN+1個のカラムが必要になる問題",
      "D. N個のトランザクションでN+1回のコミットが発生する問題"
    ],
    "correct": 1,
    "explanation": "N+1問題は一覧取得の1クエリ後にN件の関連データを各1クエリで取得し、合計N+1回のクエリが発行される非効率な問題です。"
  },
  {
    "id": 629,
    "question": "PostgreSQLの特徴として正しくないものはどれか？",
    "options": [
      "A. JSONB型をサポートしドキュメントデータも扱えること",
      "B. トランザクションのACID特性をサポートしている機能",
      "C. テーブルのパーティショニング機能を備えている特長",
      "D. スキーマレスでテーブル定義が不要なデータベースである"
    ],
    "correct": 3,
    "explanation": "PostgreSQLはスキーマ定義が必要なRDBMSです。JSONB型でドキュメントも扱えますが、テーブル定義（CREATE TABLE）は必要です。"
  },
  {
    "id": 630,
    "question": "SQLの「UNION」と「UNION ALL」の違いとして正しいものはどれか？",
    "options": [
      "A. UNIONはNULLを含みUNION ALLはNULLを除外する違い",
      "B. UNIONは重複を除去しUNION ALLは重複を含めて返す違い",
      "C. UNIONは2テーブルまでUNION ALLは制限なしという違い",
      "D. UNIONは自動ソートなしでUNION ALLは自動ソートする違い"
    ],
    "correct": 1,
    "explanation": "UNIONは結果から重複行を除去（DISTINCT）しますが、UNION ALLは重複を含めてすべての行を返します。UNION ALLの方が高速です。"
  },
  {
    "id": 631,
    "question": "データベースの「楽観的ロック」の仕組みとして正しいものはどれか？",
    "options": [
      "A. データ読み取り時に排他ロックを取得する方式のこと指す",
      "B. 更新時にバージョン番号を確認し競合を検出する方式のこと",
      "C. トランザクション全体でテーブルロックを保持する方式のこと",
      "D. 読み取りと書き込みを完全に分離するための方式のことを指"
    ],
    "correct": 1,
    "explanation": "楽観的ロックはデータにバージョン番号やタイムスタンプを持たせ、更新時に変更されていないか確認して競合を検出します。"
  },
  {
    "id": 632,
    "question": "Redisの「TTL（Time To Live）」の説明として正しいものはどれか？",
    "options": [
      "A. データの作成日時を記録するタイムスタンプ機能のこと",
      "B. キーの有効期限を設定し期限後に自動削除される仕組み",
      "C. ネットワークパケットの生存時間を制御する設定のこと指す",
      "D. データベース接続のタイムアウト時間を設定する仕組み機能"
    ],
    "correct": 1,
    "explanation": "RedisのTTLはキーに有効期限（秒/ミリ秒）を設定し、期限が来るとそのキーを自動的に削除する機能です。キャッシュに有用です。"
  },
  {
    "id": 633,
    "question": "SQLの「FOREIGN KEY」制約の目的として正しいものはどれか？",
    "options": [
      "A. 列の値が一意であることを保証するための制約のことを指す",
      "B. テーブル間の参照整合性を維持するための制約のことを指す",
      "C. 列の値がNULLでないことを保証するための制約のことを指す",
      "D. 列の値が指定した範囲内であることを保証するための制約"
    ],
    "correct": 1,
    "explanation": "FOREIGN KEY制約は子テーブルの値が親テーブルの主キー/ユニークキーに存在することを保証し、参照整合性を維持します。"
  },
  {
    "id": 634,
    "question": "「MVCC（Multi-Version Concurrency Control）」の特徴はどれか？",
    "options": [
      "A. 読み取りと書き込みが互いにブロックし合う制御方式のこと",
      "B. データの複数バージョンを保持し読取がロックを取らない方式",
      "C. テーブル全体をロックして排他制御する方式のことを指すもの",
      "D. トランザクション開始時にスナップショットを取らない方式"
    ],
    "correct": 1,
    "explanation": "MVCCはデータの複数バージョンを管理し、読み取りトランザクションがロックを取得せずに過去のスナップショットを参照できる方式です。"
  },
  {
    "id": 635,
    "question": "「コネクションプーリング」の目的として正しいものはどれか？",
    "options": [
      "A. データベースの暗号化接続を管理するための仕組みのこと",
      "B. DB接続を再利用して接続確立のオーバーヘッドを削減する",
      "C. 複数DBへの同時接続を負荷分散する仕組みのことを指す",
      "D. データベースのレプリケーション接続を管理する仕組み機能"
    ],
    "correct": 1,
    "explanation": "コネクションプーリングはDB接続をプールに保持し再利用することで、接続確立/切断のオーバーヘッドを削減します。"
  },
  {
    "id": 636,
    "question": "SQLの「トリガー」の説明として正しいものはどれか？",
    "options": [
      "A. 定期的なスケジュールで自動実行されるSQL処理のこと指す",
      "B. INSERT/UPDATE/DELETE時に自動的に実行される処理のこと",
      "C. クライアントからの接続時に自動実行される処理のこと指す",
      "D. データベースの起動時に自動的に実行される処理のことを指"
    ],
    "correct": 1,
    "explanation": "トリガーはテーブルに対するINSERT、UPDATE、DELETEの前後に自動的に実行される処理（プロシージャ）です。"
  },
  {
    "id": 637,
    "question": "Redisの「Pub/Sub」機能の説明として正しいものはどれか？",
    "options": [
      "A. キーバリュー型のデータを永続的に保存する機能のこと指す",
      "B. チャネルを介してメッセージをリアルタイム配信する機能",
      "C. データの有効期限を設定して自動削除する機能のことを指す",
      "D. データのソート済みセットを管理する機能のことを指すもの"
    ],
    "correct": 1,
    "explanation": "RedisのPub/SubはPublisher（発行者）がチャネルにメッセージを発行し、Subscriber（購読者）がリアルタイムで受信する機能です。"
  },
  {
    "id": 638,
    "question": "「ストアドプロシージャ」のメリットとして正しいものはどれか？",
    "options": [
      "A. クライアント側のコード量が増加してメンテが容易になる",
      "B. DB側で処理を実行しネットワーク往復を削減できるメリット",
      "C. どのDBMSでも同じ構文で利用できる互換性のメリットがある",
      "D. コンパイル不要でインタプリタ方式で高速に動作するメリット"
    ],
    "correct": 1,
    "explanation": "ストアドプロシージャはDB側で事前コンパイルされた処理を実行するため、ネットワーク往復の削減と実行速度の向上が期待できます。"
  },
  {
    "id": 639,
    "question": "データベースの「フルテーブルスキャン」が発生する原因はどれか？",
    "options": [
      "A. PRIMARY KEY制約が設定されている列で検索した場合",
      "B. 検索条件の列にインデックスが存在しない場合に発生する",
      "C. ユニークインデックスで一意の値を検索した場合に発生",
      "D. クラスタ化インデックスの列で範囲検索した場合に発生する"
    ],
    "correct": 1,
    "explanation": "検索条件の列にインデックスがないと、全行を順に走査するフルテーブルスキャンが発生します。データ量が多いと非常に遅くなります。"
  },
  {
    "id": 640,
    "question": "MongoDBの「コレクション」はRDBの何に相当するか？",
    "options": [
      "A. データベース（スキーマ）に相当するものとして対応する",
      "B. テーブルに相当するものとしてRDBの概念に対応する",
      "C. レコード（行）に相当するものとしてRDBの概念に対応",
      "D. カラム（列）に相当するものとしてRDBの概念に対応する"
    ],
    "correct": 1,
    "explanation": "MongoDBのコレクションはRDBのテーブルに相当します。ドキュメントはレコード（行）、フィールドはカラム（列）に対応します。"
  }
]
