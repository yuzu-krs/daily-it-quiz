[
  {
    "id": 731,
    "question": "SQLの「SELECT」文の役割は？",
    "options": [
      "A. データの削除",
      "B. テーブルからデータを取得する",
      "C. データの挿入",
      "D. テーブルの作成"
    ],
    "correct": 1,
    "explanation": "SELECTはテーブルからデータを検索・取得するSQL文で、最も基本的で頻繁に使用されるコマンドです。"
  },
  {
    "id": 732,
    "question": "SQLのWHERE句の役割は？",
    "options": [
      "A. データの並び替え",
      "B. 条件に一致するレコードのみをフィルタリング",
      "C. グループ化",
      "D. テーブル結合"
    ],
    "correct": 1,
    "explanation": "WHERE句はSELECT/UPDATE/DELETE文に条件を付加し、条件に合致するレコードのみを対象にします。"
  },
  {
    "id": 733,
    "question": "SQLのINSERT文の基本構文は？",
    "options": [
      "A. INSERT FROM table",
      "B. INSERT INTO table (columns) VALUES (values)",
      "C. INSERT table SET values",
      "D. INSERT VALUES INTO table"
    ],
    "correct": 1,
    "explanation": "INSERT INTO テーブル名 (列名) VALUES (値) でテーブルに新しいレコードを追加します。"
  },
  {
    "id": 734,
    "question": "SQLのUPDATE文でWHEREを省略するとどうなる？",
    "options": [
      "A. エラーになる",
      "B. テーブルの全レコードが更新される",
      "C. 先頭行のみ更新",
      "D. 何も起きない"
    ],
    "correct": 1,
    "explanation": "UPDATE文でWHEREを省略すると、テーブルの全行が更新対象になり、意図しないデータ変更が発生する危険があります。"
  },
  {
    "id": 735,
    "question": "SQLのDELETE文とTRUNCATE文の違いは？",
    "options": [
      "A. 同じ動作",
      "B. DELETEは行単位で削除しロールバック可能、TRUNCATEは全行を高速削除",
      "C. TRUNCATEは行単位で削除",
      "D. DELETEの方が高速"
    ],
    "correct": 1,
    "explanation": "DELETEはWHEREで条件指定可能でトランザクションログに記録。TRUNCATEはテーブル全データを高速削除しますがロールバックが制限されます。"
  },
  {
    "id": 736,
    "question": "PRIMARY KEY（主キー）の特徴は？",
    "options": [
      "A. NULLを許容する",
      "B. テーブル内で一意かつNULL不可で、レコードを一意に識別",
      "C. 重複を許容する",
      "D. 複数テーブルで共有"
    ],
    "correct": 1,
    "explanation": "主キーはテーブル内の各レコードを一意に識別する列で、一意性制約（UNIQUE）とNOT NULL制約の両方を持ちます。"
  },
  {
    "id": 737,
    "question": "FOREIGN KEY（外部キー）の役割は？",
    "options": [
      "A. 主キーと同じ",
      "B. 別テーブルの主キーを参照し、テーブル間の参照整合性を保証",
      "C. インデックスの作成",
      "D. データの暗号化"
    ],
    "correct": 1,
    "explanation": "外部キーは別テーブルの主キー（または一意キー）を参照し、親テーブルに存在しない値の挿入を防いで参照整合性を維持します。"
  },
  {
    "id": 738,
    "question": "INNER JOINの動作は？",
    "options": [
      "A. 左テーブルの全行を返す",
      "B. 両テーブルで条件に一致するレコードのみを返す",
      "C. 右テーブルの全行を返す",
      "D. 全レコードを返す"
    ],
    "correct": 1,
    "explanation": "INNER JOINは結合条件に一致する両テーブルのレコードのみを返します。一致しないレコードは結果に含まれません。"
  },
  {
    "id": 739,
    "question": "LEFT JOINの動作は？",
    "options": [
      "A. 右テーブルの全行を返す",
      "B. 左テーブルの全行と、一致する右テーブルの行を返す（不一致はNULL）",
      "C. 一致する行のみ返す",
      "D. 重複を除外"
    ],
    "correct": 1,
    "explanation": "LEFT JOINは左テーブルの全レコードを保持し、右テーブルで一致するレコードを結合。一致しない場合は右側がNULLになります。"
  },
  {
    "id": 740,
    "question": "RIGHT JOINの動作は？",
    "options": [
      "A. 左テーブルの全行を返す",
      "B. 右テーブルの全行と、一致する左テーブルの行を返す（不一致はNULL）",
      "C. 一致する行のみ返す",
      "D. CROSS JOIN"
    ],
    "correct": 1,
    "explanation": "RIGHT JOINは右テーブルの全レコードを保持し、左テーブルで一致するレコードを結合。一致しない場合は左側がNULLになります。"
  },
  {
    "id": 741,
    "question": "FULL OUTER JOINの動作は？",
    "options": [
      "A. INNER JOINと同じ",
      "B. 両テーブルの全レコードを返し、一致しない側はNULL",
      "C. LEFT JOINと同じ",
      "D. 一致する行のみ"
    ],
    "correct": 1,
    "explanation": "FULL OUTER JOINは両テーブルの全レコードを返し、一方に一致するレコードがない場合はNULLで埋めます。"
  },
  {
    "id": 742,
    "question": "CROSS JOINの動作は？",
    "options": [
      "A. 条件に一致する行のみ",
      "B. 両テーブルのすべての行の直積（全組み合わせ）を返す",
      "C. LEFT JOINと同じ",
      "D. 重複排除"
    ],
    "correct": 1,
    "explanation": "CROSS JOINはWHERE条件なしで使うと、両テーブルの全行のデカルト積（M×N行）を生成します。"
  },
  {
    "id": 743,
    "question": "SQLのGROUP BY句の用途は？",
    "options": [
      "A. データの並び替え",
      "B. 指定列の値でレコードをグループ化し集約関数と組み合わせる",
      "C. データのフィルタリング",
      "D. テーブル結合"
    ],
    "correct": 1,
    "explanation": "GROUP BYは指定列で同じ値を持つ行をグループ化し、COUNT、SUM、AVG等の集約関数で各グループの統計を算出します。"
  },
  {
    "id": 744,
    "question": "SQLのHAVING句とWHERE句の違いは？",
    "options": [
      "A. 同じ機能",
      "B. WHEREはグループ化前のフィルタ、HAVINGはグループ化後のフィルタ",
      "C. HAVINGはグループ化前",
      "D. WHEREはグループ化後"
    ],
    "correct": 1,
    "explanation": "WHEREは個々の行に対するフィルタ、HAVINGはGROUP BYでグループ化した後の集計結果に対するフィルタです。"
  },
  {
    "id": 745,
    "question": "SQLのサブクエリ（副問い合わせ）とは？",
    "options": [
      "A. テーブル結合",
      "B. SQL文の中に入れ子として埋め込まれた別のSELECT文",
      "C. ストアドプロシージャ",
      "D. ビューの定義"
    ],
    "correct": 1,
    "explanation": "サブクエリはSELECT/WHERE/FROM等の中に埋め込まれたSELECT文で、外側のクエリに値やテーブルを提供します。"
  },
  {
    "id": 746,
    "question": "SQLのUNIONとUNION ALLの違いは？",
    "options": [
      "A. 同じ動作",
      "B. UNIONは重複排除、UNION ALLは重複を含む全結果を返す",
      "C. UNION ALLが重複排除",
      "D. UNIONの方が高速"
    ],
    "correct": 1,
    "explanation": "UNIONは2つのSELECTの結果を結合して重複行を排除。UNION ALLは重複排除せず全行を返すため高速です。"
  },
  {
    "id": 747,
    "question": "データベースインデックスの主な目的は？",
    "options": [
      "A. データの暗号化",
      "B. データの検索・取得速度を向上させる",
      "C. データの圧縮",
      "D. データのバックアップ"
    ],
    "correct": 1,
    "explanation": "インデックスはテーブルの特定列にB-tree等のデータ構造を作成し、フルテーブルスキャンを回避して高速な検索を実現します。"
  },
  {
    "id": 748,
    "question": "B-treeインデックスの特徴は？",
    "options": [
      "A. ハッシュ計算のみ",
      "B. バランス木構造で範囲検索や等値検索に効率的",
      "C. 全文検索専用",
      "D. 空間インデックス"
    ],
    "correct": 1,
    "explanation": "B-treeはバランスの取れた木構造で、等値検索（=）、範囲検索（<, >, BETWEEN）、ソートに効率的です。多くのRDBMSのデフォルト。"
  },
  {
    "id": 749,
    "question": "複合インデックスの注意点は？",
    "options": [
      "A. 順序は関係ない",
      "B. 先頭列から順に有効で、中間列を飛ばすと後続列のインデックスが効かない",
      "C. 常に全列を使う",
      "D. 単一インデックスと同じ"
    ],
    "correct": 1,
    "explanation": "複合インデックス(A, B, C)はAのみ、A+B、A+B+Cの検索に有効ですが、BのみやCのみの検索ではインデックスが効きません（最左プレフィックスルール）。"
  },
  {
    "id": 750,
    "question": "インデックスのデメリットは？",
    "options": [
      "A. デメリットなし",
      "B. INSERT/UPDATE/DELETE時にインデックスも更新するためオーバーヘッドが増加",
      "C. SELECT性能が低下",
      "D. データが消える"
    ],
    "correct": 1,
    "explanation": "インデックスは検索を高速化しますが、データ変更時にインデックス構造も更新する必要があり、書き込み性能が低下しストレージも消費します。"
  },
  {
    "id": 751,
    "question": "EXPLAIN（実行計画）の用途は？",
    "options": [
      "A. データの挿入",
      "B. SQLクエリの実行計画を表示しパフォーマンス分析を行う",
      "C. テーブルの作成",
      "D. インデックスの削除"
    ],
    "correct": 1,
    "explanation": "EXPLAINはSQLが実際にどのようなインデックスやスキャン方法で実行されるかを表示し、パフォーマンスチューニングに必須です。"
  },
  {
    "id": 752,
    "question": "フルテーブルスキャンとは？",
    "options": [
      "A. インデックスを使用した検索",
      "B. テーブルの全行を順次読み取る最も遅い検索方法",
      "C. 並列検索",
      "D. キャッシュ検索"
    ],
    "correct": 1,
    "explanation": "フルテーブルスキャンはインデックスを使わずテーブルの全行を順番に読む方法で、大きなテーブルでは非常に遅くなります。"
  },
  {
    "id": 753,
    "question": "トランザクションの ACID特性の「A」は？",
    "options": [
      "A. Availability",
      "B. Atomicity（原子性）",
      "C. Authentication",
      "D. Authorization"
    ],
    "correct": 1,
    "explanation": "Atomicity（原子性）はトランザクションの全操作が完全に実行されるか、まったく実行されないかを保証する特性です。"
  },
  {
    "id": 754,
    "question": "ACID特性の「C」は？",
    "options": [
      "A. Concurrency",
      "B. Consistency（一貫性）",
      "C. Compression",
      "D. Caching"
    ],
    "correct": 1,
    "explanation": "Consistency（一貫性）はトランザクション前後でデータベースが整合性制約を満たす有効な状態を維持する特性です。"
  },
  {
    "id": 755,
    "question": "ACID特性の「I」は？",
    "options": [
      "A. Integrity",
      "B. Isolation（分離性）",
      "C. Implementation",
      "D. Integration"
    ],
    "correct": 1,
    "explanation": "Isolation（分離性）は複数のトランザクションが並行実行されても、互いに干渉しないように独立して実行される特性です。"
  },
  {
    "id": 756,
    "question": "ACID特性の「D」は？",
    "options": [
      "A. Distribution",
      "B. Durability（永続性）",
      "C. Deletion",
      "D. Debugging"
    ],
    "correct": 1,
    "explanation": "Durability（永続性）はコミットされたトランザクションの結果がシステム障害後も失われないことを保証する特性です。"
  },
  {
    "id": 757,
    "question": "トランザクション分離レベル「READ UNCOMMITTED」の特徴は？",
    "options": [
      "A. 最も安全",
      "B. コミットされていないデータも読める（ダーティリード発生）",
      "C. 繰り返し読取り保証",
      "D. ファントム防止"
    ],
    "correct": 1,
    "explanation": "READ UNCOMMITTEDは最低の分離レベルで、他のトランザクションの未コミットデータが読めるダーティリードが発生します。"
  },
  {
    "id": 758,
    "question": "トランザクション分離レベル「READ COMMITTED」の特徴は？",
    "options": [
      "A. ダーティリードが発生",
      "B. コミット済みデータのみ読取り可能（ノンリピータブルリードは発生しうる）",
      "C. ファントム防止",
      "D. 完全な分離"
    ],
    "correct": 1,
    "explanation": "READ COMMITTEDはコミット済みデータのみ読取りダーティリードを防ぎますが、同一トランザクション内で同じクエリが異なる結果を返す可能性があります。"
  },
  {
    "id": 759,
    "question": "トランザクション分離レベル「SERIALIZABLE」の特徴は？",
    "options": [
      "A. 最も低い分離レベル",
      "B. 最も高い分離レベルで、トランザクションを順次実行したかのように動作",
      "C. ダーティリード許可",
      "D. パフォーマンスが最も高い"
    ],
    "correct": 1,
    "explanation": "SERIALIZABLEは最高の分離レベルで全ての異常を防ぎますが、ロック競合が多くパフォーマンスが最も低下します。"
  },
  {
    "id": 760,
    "question": "デッドロックとは？",
    "options": [
      "A. 高速なトランザクション",
      "B. 2つ以上のトランザクションが互いにロックの解放を待ち、永久に進まない状態",
      "C. ロックの自動解放",
      "D. トランザクションの正常終了"
    ],
    "correct": 1,
    "explanation": "デッドロックは複数トランザクションが互いに相手のロック解放を待つ循環待ちの状態で、DBMSが検知して一方をロールバックします。"
  },
  {
    "id": 761,
    "question": "楽観的ロック（Optimistic Locking）の仕組みは？",
    "options": [
      "A. 読取り時にロック取得",
      "B. 更新時にバージョン番号等で競合を検出し、競合がなければ更新",
      "C. 常にテーブル全体をロック",
      "D. ロックを使わない"
    ],
    "correct": 1,
    "explanation": "楽観的ロックは読取り時にロックせず、更新時にバージョン番号やタイムスタンプで他者による変更を検出して競合を防ぎます。"
  },
  {
    "id": 762,
    "question": "悲観的ロック（Pessimistic Locking）の仕組みは？",
    "options": [
      "A. バージョン番号で管理",
      "B. データ読取り時にロックを取得し、他トランザクションのアクセスを防ぐ",
      "C. ロックなし",
      "D. 更新時のみ確認"
    ],
    "correct": 1,
    "explanation": "悲観的ロックは読取り時点でレコードにロックを取得し、トランザクション完了まで他者のアクセス（読取りまたは書込み）をブロックします。"
  },
  {
    "id": 763,
    "question": "正規化の目的は？",
    "options": [
      "A. データの暗号化",
      "B. データの冗長性を排除し更新異常を防ぐためにテーブルを分割",
      "C. パフォーマンスの向上",
      "D. データの圧縮"
    ],
    "correct": 1,
    "explanation": "正規化はテーブルを適切に分割してデータの重複を排除し、挿入・更新・削除時の異常（アノマリー）を防ぎます。"
  },
  {
    "id": 764,
    "question": "第1正規形（1NF）の条件は？",
    "options": [
      "A. 関数従属性の排除",
      "B. 全ての列の値が原子的（それ以上分割できない単一値）であること",
      "C. 推移的関数従属性の排除",
      "D. 結合従属性の排除"
    ],
    "correct": 1,
    "explanation": "1NFは各列に繰り返しグループやリストを持たず、全ての値がスカラー値（原子値）であることを要求します。"
  },
  {
    "id": 765,
    "question": "第2正規形（2NF）の条件は？",
    "options": [
      "A. 原子値のみ",
      "B. 1NFかつ、主キーの一部への部分関数従属を排除",
      "C. 推移的従属の排除",
      "D. 多値従属の排除"
    ],
    "correct": 1,
    "explanation": "2NFは1NFを満たした上で、複合主キーの一部にのみ従属する（部分関数従属する）非キー列を別テーブルに分離します。"
  },
  {
    "id": 766,
    "question": "第3正規形（3NF）の条件は？",
    "options": [
      "A. 部分関数従属の排除",
      "B. 2NFかつ、非キー列から別の非キー列への推移的関数従属を排除",
      "C. 1NFのみ",
      "D. 多値従属の排除"
    ],
    "correct": 1,
    "explanation": "3NFは2NFを満たした上で、非キー列が別の非キー列を経由して主キーに従属する（推移的関数従属）のを排除します。"
  },
  {
    "id": 767,
    "question": "非正規化（デノーマライゼーション）の目的は？",
    "options": [
      "A. データ整合性の向上",
      "B. JOINを減らして読取りパフォーマンスを向上させるためにテーブルを結合",
      "C. ストレージの節約",
      "D. セキュリティ向上"
    ],
    "correct": 1,
    "explanation": "非正規化は意図的にデータの冗長性を導入してJOINを減らし、読取り性能を向上させます。データ整合性管理の負担は増します。"
  },
  {
    "id": 768,
    "question": "ビュー（VIEW）とは？",
    "options": [
      "A. 物理テーブル",
      "B. SELECTクエリに名前を付けた仮想テーブル",
      "C. インデックスの種類",
      "D. ストアドプロシージャ"
    ],
    "correct": 1,
    "explanation": "ビューはSELECT文を保存した仮想テーブルで、データを物理的に持たず参照時にクエリが実行されます。アクセス制御や複雑なクエリの簡略化に使用。"
  },
  {
    "id": 769,
    "question": "マテリアライズドビューとは？",
    "options": [
      "A. 通常のビュー",
      "B. クエリ結果を物理的に保存し高速参照できるビュー",
      "C. 一時テーブル",
      "D. インデックス"
    ],
    "correct": 1,
    "explanation": "マテリアライズドビューはSELECTの結果を物理的にディスクに保存する実体化ビューで、定期的なリフレッシュが必要ですが高速です。"
  },
  {
    "id": 770,
    "question": "ストアドプロシージャとは？",
    "options": [
      "A. 外部プログラム",
      "B. データベースサーバー側に保存された再利用可能なSQL手続き",
      "C. クライアント側スクリプト",
      "D. インデックスの種類"
    ],
    "correct": 1,
    "explanation": "ストアドプロシージャはDB内に保存される名前付きのSQLプログラムで、繰り返し実行、パラメータ渡し、条件分岐等が可能です。"
  },
  {
    "id": 771,
    "question": "トリガー（Trigger）とは？",
    "options": [
      "A. インデックスの自動作成",
      "B. INSERT/UPDATE/DELETE等のイベントに対して自動実行されるDB手続き",
      "C. バックアップ機能",
      "D. 接続管理"
    ],
    "correct": 1,
    "explanation": "トリガーはテーブルへのINSERT/UPDATE/DELETEをきっかけに自動実行されるプログラムで、監査ログや整合性チェックに使用します。"
  },
  {
    "id": 772,
    "question": "NoSQLデータベースが従来のRDBと異なる主な特徴は？",
    "options": [
      "A. SQLが使える",
      "B. スキーマレスで水平スケーラビリティに優れ、非リレーショナル",
      "C. ACID完全準拠",
      "D. テーブル構造"
    ],
    "correct": 1,
    "explanation": "NoSQLは固定スキーマ不要、水平スケーリングに適し、キーバリュー/ドキュメント/カラム/グラフ等の多様なデータモデルを提供します。"
  },
  {
    "id": 773,
    "question": "NoSQLの「ドキュメント型」データベースの代表例は？",
    "options": ["A. Redis", "B. MongoDB", "C. Cassandra", "D. Neo4j"],
    "correct": 1,
    "explanation": "MongoDBはJSON/BSON形式のドキュメントを保存するNoSQLで、柔軟なスキーマと強力なクエリ機能を持ちます。"
  },
  {
    "id": 774,
    "question": "NoSQLの「キーバリュー型」データベースの代表例は？",
    "options": ["A. MongoDB", "B. Redis", "C. PostgreSQL", "D. Neo4j"],
    "correct": 1,
    "explanation": "Redisはインメモリのキーバリューストアで、極めて高速な読み書きが可能です。キャッシュ、セッション管理等に使用されます。"
  },
  {
    "id": 775,
    "question": "NoSQLの「カラム指向」データベースの代表例は？",
    "options": ["A. MongoDB", "B. Apache Cassandra", "C. Redis", "D. MySQL"],
    "correct": 1,
    "explanation": "Cassandraはカラムファミリー型の分散NoSQLで、大量のデータに対する高速書き込みと水平スケーリングに優れています。"
  },
  {
    "id": 776,
    "question": "NoSQLの「グラフ型」データベースの代表例は？",
    "options": ["A. Redis", "B. Neo4j", "C. MongoDB", "D. Cassandra"],
    "correct": 1,
    "explanation": "Neo4jはノードとエッジでデータ間の関係を表現するグラフDBで、SNSの友人関係や推薦システム等の関係性分析に適しています。"
  },
  {
    "id": 777,
    "question": "CAP定理とは？",
    "options": [
      "A. 暗号化の理論",
      "B. 分散システムは一貫性・可用性・分断耐性の3つのうち2つしか同時に保証できない",
      "C. ACIDの拡張",
      "D. SQLの最適化理論"
    ],
    "correct": 1,
    "explanation": "CAP定理はConsistency（一貫性）、Availability（可用性）、Partition tolerance（分断耐性）の3つを分散システムで同時に満たせないとする定理です。"
  },
  {
    "id": 778,
    "question": "BASE特性とは？",
    "options": [
      "A. ACIDと同じ",
      "B. Basically Available, Soft state, Eventually consistent の略で、NoSQLの設計原則",
      "C. バックアップ方式",
      "D. セキュリティモデル"
    ],
    "correct": 1,
    "explanation": "BASEはACIDの対極として、基本的に利用可能、状態は変化しうる、結果整合性を重視するNoSQL/分散システムの設計原則です。"
  },
  {
    "id": 779,
    "question": "結果整合性（Eventual Consistency）とは？",
    "options": [
      "A. 即座に整合性を保証",
      "B. 新しい更新がなければ、最終的に全レプリカが同じ値に収束する",
      "C. 整合性を保証しない",
      "D. トランザクション分離"
    ],
    "correct": 1,
    "explanation": "結果整合性は更新後すぐには全ノードで同じ値が読めないが、時間経過とともに全レプリカが最終的に一致することを保証します。"
  },
  {
    "id": 780,
    "question": "Redisをキャッシュとして使う主なメリットは？",
    "options": [
      "A. ディスクI/Oが多い",
      "B. インメモリ動作で読み書きがミリ秒以下、DB負荷を軽減",
      "C. テーブル結合が高速",
      "D. 正規化が容易"
    ],
    "correct": 1,
    "explanation": "Redisはデータをメモリ上に保持するため、ディスクベースのDBに比べて数十〜数百倍高速に応答し、頻繁なクエリの負荷を軽減します。"
  },
  {
    "id": 781,
    "question": "Redisのデータ型に含まれないものは？",
    "options": ["A. String", "B. TABLE", "C. List", "D. Hash"],
    "correct": 1,
    "explanation": "Redisの主なデータ型はString、List、Hash、Set、Sorted Set等です。リレーショナルDBのTABLE概念はありません。"
  },
  {
    "id": 782,
    "question": "Redisの永続化方式「RDB」と「AOF」の違いは？",
    "options": [
      "A. 同じ方式",
      "B. RDBは定期スナップショット、AOFは全書込み命令をログに記録",
      "C. AOFがスナップショット",
      "D. RDBがログ方式"
    ],
    "correct": 1,
    "explanation": "RDBは指定間隔でメモリのスナップショットを保存。AOFは全書込み操作をログファイルに追記し、よりデータ損失が少ない方式です。"
  },
  {
    "id": 783,
    "question": "MongoDBのドキュメントの形式は？",
    "options": ["A. XML", "B. BSON（Binary JSON）", "C. CSV", "D. YAML"],
    "correct": 1,
    "explanation": "MongoDBはBSON（Binary JSON）形式でドキュメントを保存します。JSONに似た構造ですが、バイナリで格納され追加のデータ型をサポートします。"
  },
  {
    "id": 784,
    "question": "MongoDBの「コレクション」はRDBの何に相当する？",
    "options": ["A. 列", "B. テーブル", "C. 行", "D. データベース"],
    "correct": 1,
    "explanation": "MongoDBのコレクションはRDBのテーブルに相当し、ドキュメント（レコード）の集まりです。スキーマ固定ではありません。"
  },
  {
    "id": 785,
    "question": "MongoDBのレプリカセットとは？",
    "options": [
      "A. シャーディング",
      "B. プライマリとセカンダリの自動フェイルオーバーを提供する複製構成",
      "C. インデックス",
      "D. 集約パイプライン"
    ],
    "correct": 1,
    "explanation": "レプリカセットは1つのプライマリと複数のセカンダリノードで構成され、データを自動複製しプライマリ障害時に自動フェイルオーバーします。"
  },
  {
    "id": 786,
    "question": "データベースのシャーディングとは？",
    "options": [
      "A. データの圧縮",
      "B. データを複数のサーバーに水平分割して分散保存",
      "C. データの暗号化",
      "D. バックアップ方式"
    ],
    "correct": 1,
    "explanation": "シャーディングはデータをシャードキーに基づいて複数のサーバー（シャード）に水平分割し、容量とスループットを水平スケールさせます。"
  },
  {
    "id": 787,
    "question": "レプリケーションとシャーディングの違いは？",
    "options": [
      "A. 同じ概念",
      "B. レプリケーションは同じデータを複製、シャーディングは異なるデータを分散",
      "C. シャーディングがデータ複製",
      "D. レプリケーションがデータ分割"
    ],
    "correct": 1,
    "explanation": "レプリケーションは可用性と読取り性能のためにデータを複数ノードにコピー。シャーディングは容量と書込み性能のためにデータを分割します。"
  },
  {
    "id": 788,
    "question": "MySQLのデフォルトストレージエンジンは？",
    "options": ["A. MyISAM", "B. InnoDB", "C. MEMORY", "D. CSV"],
    "correct": 1,
    "explanation": "InnoDBはMySQL 5.5以降のデフォルトストレージエンジンで、トランザクション、行レベルロック、外部キー、MVCC等をサポートします。"
  },
  {
    "id": 789,
    "question": "PostgreSQLのMVCC（Multi-Version Concurrency Control）とは？",
    "options": [
      "A. ロックベースの排他制御",
      "B. 各トランザクションにデータのスナップショットを提供し並行処理を効率化",
      "C. テーブルロック",
      "D. シングルスレッド実行"
    ],
    "correct": 1,
    "explanation": "MVCCは各トランザクションにデータの一時点のスナップショットを見せ、読取りが書込みをブロックしない高い並行性を実現します。"
  },
  {
    "id": 790,
    "question": "PostgreSQLの「JSONB」データ型の特徴は？",
    "options": [
      "A. テキストとして保存",
      "B. バイナリJSON形式で保存しインデックス作成と高速クエリが可能",
      "C. XML形式",
      "D. CSV形式"
    ],
    "correct": 1,
    "explanation": "JSONBはJSONをバイナリ形式で保存し、GINインデックスによる高速検索やキーによるクエリが可能。リレーショナルとNoSQLの中間的機能。"
  },
  {
    "id": 791,
    "question": "コネクションプーリングの目的は？",
    "options": [
      "A. セキュリティ向上",
      "B. DB接続を再利用してオーバーヘッドを削減しパフォーマンスを向上",
      "C. データの暗号化",
      "D. バックアップの効率化"
    ],
    "correct": 1,
    "explanation": "コネクションプーリングはDB接続を事前に作成してプールし再利用することで、接続確立のオーバーヘッドを削減します。"
  },
  {
    "id": 792,
    "question": "N+1問題とは？",
    "options": [
      "A. 正規化の問題",
      "B. 1回のクエリでリストを取得し、各要素に対してN回の追加クエリを発行する非効率なアクセスパターン",
      "C. インデックスの問題",
      "D. デッドロックの一種"
    ],
    "correct": 1,
    "explanation": "N+1問題は初回クエリで一覧取得後、各レコードの関連データを個別に取得するため大量のクエリが発生します。JOINやEager Loadingで解決。"
  },
  {
    "id": 793,
    "question": "ORMとは？",
    "options": [
      "A. データベースサーバー",
      "B. オブジェクトとリレーショナルDBのテーブルをマッピングするライブラリ",
      "C. SQLの方言",
      "D. バックアップツール"
    ],
    "correct": 1,
    "explanation": "ORM（Object-Relational Mapping）はプログラミング言語のオブジェクトとDBテーブルを自動マッピングし、SQLを書かずにDB操作可能にします。"
  },
  {
    "id": 794,
    "question": "SQLインジェクションを防ぐ基本的な対策は？",
    "options": [
      "A. 入力値をそのままSQLに連結",
      "B. プリペアドステートメント（パラメータ化クエリ）の使用",
      "C. 暗号化のみ",
      "D. ファイアウォールのみ"
    ],
    "correct": 1,
    "explanation": "プリペアドステートメントはSQL文とパラメータを分離してバインドするため、ユーザー入力がSQLの構造を変更できません。"
  },
  {
    "id": 795,
    "question": "データベースマイグレーションとは？",
    "options": [
      "A. データのバックアップ",
      "B. スキーマの変更をバージョン管理して段階的に適用する仕組み",
      "C. データの暗号化",
      "D. インデックスの再構築"
    ],
    "correct": 1,
    "explanation": "マイグレーションはスキーマ変更（テーブル追加、列変更等）をバージョン管理し、適用・ロールバックを管理します。Flyway、Alembic等が代表例。"
  },
  {
    "id": 796,
    "question": "WAL（Write-Ahead Logging）の仕組みは？",
    "options": [
      "A. データを直接ディスクに書込み",
      "B. データ変更前にまずログに書込み、その後データファイルを更新し耐障害性を確保",
      "C. ログを後で書込み",
      "D. メモリのみで動作"
    ],
    "correct": 1,
    "explanation": "WALはトランザクションの変更をデータファイルの前にログファイルへ書込むことで、障害時にログからデータを復旧できます。"
  },
  {
    "id": 797,
    "question": "データベースのVACUUM（PostgreSQL）の目的は？",
    "options": [
      "A. データの暗号化",
      "B. 不要になった古い行バージョンを回収しディスク領域を再利用",
      "C. バックアップ",
      "D. インデックス作成"
    ],
    "correct": 1,
    "explanation": "VACUUMはMVCCで生じた不要な古いタプル（行バージョン）を回収し、ディスク領域を再利用可能にする保守処理です。"
  },
  {
    "id": 798,
    "question": "データベースのパーティショニングとは？",
    "options": [
      "A. シャーディングと同じ",
      "B. 1つのテーブルを条件に基づいて複数の物理的なサブテーブルに分割",
      "C. インデックスの分割",
      "D. バックアップの分割"
    ],
    "correct": 1,
    "explanation": "パーティショニングは大テーブルを日付や範囲等の条件で分割し、クエリが必要なパーティションのみスキャンしてパフォーマンスを向上させます。"
  },
  {
    "id": 799,
    "question": "カバリングインデックスとは？",
    "options": [
      "A. 全テーブルのインデックス",
      "B. クエリに必要な全列を含み、テーブルアクセスなしで結果を返せるインデックス",
      "C. 主キーのインデックス",
      "D. 外部キーのインデックス"
    ],
    "correct": 1,
    "explanation": "カバリングインデックスはSELECTの列がすべてインデックスに含まれるため、テーブル本体へのアクセス(ルックアップ)が不要で高速です。"
  },
  {
    "id": 800,
    "question": "クラスタインデックスの特徴は？",
    "options": [
      "A. テーブルに複数作成可能",
      "B. テーブルの物理的なデータ順序をインデックスの順序に合わせる（1テーブルに1つ）",
      "C. 常に非クラスタ",
      "D. ビューのインデックス"
    ],
    "correct": 1,
    "explanation": "クラスタインデックスはテーブルのデータ自体をインデックスの順序で物理的に格納するため、1テーブルに1つのみ作成可能です。"
  },
  {
    "id": 801,
    "question": "DBの「スロークエリログ」の用途は？",
    "options": [
      "A. 正常クエリの記録",
      "B. 実行時間が閾値を超えたクエリを記録しパフォーマンスの問題を特定",
      "C. セキュリティログ",
      "D. バックアップログ"
    ],
    "correct": 1,
    "explanation": "スロークエリログは設定した時間（例：1秒）を超えるクエリを記録し、パフォーマンスチューニングの対象を特定するのに役立ちます。"
  },
  {
    "id": 802,
    "question": "SQLのウィンドウ関数（Window Function）の特徴は？",
    "options": [
      "A. GROUP BYと同じ",
      "B. 行をグループ化せずに集計やランク付けを行い、個々の行も保持",
      "C. テーブル作成",
      "D. データ挿入"
    ],
    "correct": 1,
    "explanation": "ウィンドウ関数はOVER句でウィンドウを定義し、ROW_NUMBER、RANK、SUM等をグループ化せずに行ごとに適用して結果セットの全行を保持します。"
  },
  {
    "id": 803,
    "question": "CTE（Common Table Expression / WITH句）の用途は？",
    "options": [
      "A. テーブルの作成",
      "B. 一時的な名前付き結果セットを定義しクエリの可読性を向上",
      "C. インデックスの作成",
      "D. ユーザーの管理"
    ],
    "correct": 1,
    "explanation": "CTEはWITH句で一時的な結果セットに名前を付け、メインクエリで参照します。再帰クエリにも使え、可読性が向上します。"
  },
  {
    "id": 804,
    "question": "データベースの「ホットバックアップ」とは？",
    "options": [
      "A. DBを停止してバックアップ",
      "B. DBが稼働中（オンライン）のままバックアップを取得",
      "C. 差分バックアップ",
      "D. 増分バックアップ"
    ],
    "correct": 1,
    "explanation": "ホットバックアップはサービスを停止せず稼働中にバックアップを取得する方式で、24/7運用のシステムで重要です。"
  },
  {
    "id": 805,
    "question": "ポイントインタイムリカバリ（PITR）とは？",
    "options": [
      "A. 最新状態への復旧のみ",
      "B. バックアップとトランザクションログを使い任意の時点の状態に復元",
      "C. テーブル単位の復旧",
      "D. インデックスの再構築"
    ],
    "correct": 1,
    "explanation": "PITRはフルバックアップとWAL/binlog等のトランザクションログを適用して、障害発生前の任意の時点の状態にデータベースを復元します。"
  },
  {
    "id": 806,
    "question": "Elasticsearchの主な用途は？",
    "options": [
      "A. リレーショナルDB",
      "B. 全文検索・ログ分析のための分散検索エンジン",
      "C. グラフDB",
      "D. メッセージキュー"
    ],
    "correct": 1,
    "explanation": "Elasticsearchは逆インデックスベースの分散検索エンジンで、全文検索、ログ分析（ELKスタック）、リアルタイム検索に使用されます。"
  },
  {
    "id": 807,
    "question": "ClickHouseの特徴は？",
    "options": [
      "A. 行指向DB",
      "B. 列指向の高速OLAP（分析処理）用データベース",
      "C. グラフDB",
      "D. キーバリューストア"
    ],
    "correct": 1,
    "explanation": "ClickHouseは列指向ストレージで、大量データの集約クエリ（SUM, COUNT, AVG等）を高速処理するOLAP分析特化のDBです。"
  },
  {
    "id": 808,
    "question": "OLTPとOLAPの違いは？",
    "options": [
      "A. 同じ用途",
      "B. OLTPはトランザクション処理（更新多）、OLAPは分析処理（読取り多）",
      "C. OLAPがトランザクション",
      "D. OLTPが分析"
    ],
    "correct": 1,
    "explanation": "OLTP（Online Transaction Processing）は日常の業務処理で更新頻度が高く、OLAP（Online Analytical Processing）は大量データの分析に使われます。"
  },
  {
    "id": 809,
    "question": "データウェアハウス（DWH）の目的は？",
    "options": [
      "A. トランザクション処理",
      "B. 複数システムからデータを集約し分析・レポーティングに使う中央リポジトリ",
      "C. キャッシュ",
      "D. リアルタイムメッセージング"
    ],
    "correct": 1,
    "explanation": "DWHは業務システム等からETLでデータを収集・整形し、BI・分析のために最適化された大容量データストアです。"
  },
  {
    "id": 810,
    "question": "ETLとは？",
    "options": [
      "A. データベースの種類",
      "B. Extract（抽出）、Transform（変換）、Load（格納）のデータ統合プロセス",
      "C. SQLのコマンド",
      "D. インデックスの種類"
    ],
    "correct": 1,
    "explanation": "ETLはソースからデータを抽出し、変換・クレンジングして、ターゲット（DWH等）にロードするデータパイプラインプロセスです。"
  },
  {
    "id": 811,
    "question": "SQLのCASE式の用途は？",
    "options": [
      "A. テーブルの作成",
      "B. 条件に基づいて異なる値を返す条件分岐式",
      "C. ループ処理",
      "D. トリガーの作成"
    ],
    "correct": 1,
    "explanation": "CASE式はSQLのIF-THENロジックで、条件に応じて異なる値を返します。SELECT、WHERE、ORDER BY等で幅広く使用可能です。"
  },
  {
    "id": 812,
    "question": "SQLのCOALESCE関数の動作は？",
    "options": [
      "A. 最大値を返す",
      "B. 引数リストから最初のNULLでない値を返す",
      "C. 平均値を返す",
      "D. 行数を返す"
    ],
    "correct": 1,
    "explanation": "COALESCEは引数を左から順に評価し、最初のNULLでない値を返します。NULLのデフォルト値設定に便利です。"
  },
  {
    "id": 813,
    "question": "SQLの「DISTINCT」キーワードの用途は？",
    "options": [
      "A. データの並び替え",
      "B. 重複行を除外してユニークな結果のみを返す",
      "C. NULL値の除外",
      "D. テーブル結合"
    ],
    "correct": 1,
    "explanation": "SELECT DISTINCTは結果セットから重複行を削除し、一意の値のみを返します。重複排除のオーバーヘッドがあります。"
  },
  {
    "id": 814,
    "question": "MySQLのAUTO_INCREMENTの用途は？",
    "options": [
      "A. データの暗号化",
      "B. 新レコード挿入時に自動で一意の連番を生成する",
      "C. インデックスの作成",
      "D. バックアップ"
    ],
    "correct": 1,
    "explanation": "AUTO_INCREMENTはPRIMARY KEYと組み合わせ、INSERT時に自動的にインクリメントされた一意の整数値を割り当てます。"
  },
  {
    "id": 815,
    "question": "PostgreSQLのSERIAL型はMySQLの何に相当？",
    "options": ["A. VARCHAR", "B. AUTO_INCREMENT", "C. TEXT", "D. BLOB"],
    "correct": 1,
    "explanation": "PostgreSQLのSERIAL（BIGSERIAL含む）は自動連番の整数型で、MySQLのAUTO_INCREMENTに相当するシーケンス生成器を内部で使用します。"
  },
  {
    "id": 816,
    "question": "NOT NULL制約の役割は？",
    "options": [
      "A. 値の一意性保証",
      "B. 列にNULL値を許容しないことを強制",
      "C. 外部キー制約",
      "D. デフォルト値の設定"
    ],
    "correct": 1,
    "explanation": "NOT NULL制約は列にNULL値の挿入を禁止し、必ず有効な値が入ることを保証する制約です。"
  },
  {
    "id": 817,
    "question": "UNIQUE制約の役割は？",
    "options": [
      "A. NULL不許可",
      "B. 列の値が重複しないことを保証（NULLは許可する場合あり）",
      "C. 外部キー制約",
      "D. デフォルト値"
    ],
    "correct": 1,
    "explanation": "UNIQUE制約は指定列の値がテーブル内で重複しないことを保証します。多くのDBではNULLは重複とみなしません。"
  },
  {
    "id": 818,
    "question": "CHECK制約の役割は？",
    "options": [
      "A. NULLチェック",
      "B. 列に挿入/更新される値が指定した条件を満たすことを保証",
      "C. 外部キーチェック",
      "D. インデックスチェック"
    ],
    "correct": 1,
    "explanation": "CHECK制約は列の値に条件（例：price > 0、age BETWEEN 0 AND 150）を設定し、条件を満たさない値の挿入を防ぎます。"
  },
  {
    "id": 819,
    "question": "SQLのLIKE演算子のワイルドカード「%」の意味は？",
    "options": [
      "A. 任意の1文字",
      "B. 任意の0文字以上の文字列",
      "C. 数字のみ",
      "D. アルファベットのみ"
    ],
    "correct": 1,
    "explanation": "%は任意の0文字以上の文字列にマッチします。例：WHERE name LIKE '%田%' は「田」を含む全ての名前に一致。"
  },
  {
    "id": 820,
    "question": "SQLのLIKE演算子のワイルドカード「_」の意味は？",
    "options": [
      "A. 任意の0文字以上",
      "B. 任意の1文字",
      "C. アンダースコア文字",
      "D. スペース"
    ],
    "correct": 1,
    "explanation": "_は任意の1文字にマッチします。例：WHERE code LIKE 'A_B' は「A」＋任意1文字＋「B」のパターンに一致。"
  },
  {
    "id": 821,
    "question": "GRANTコマンドの用途は？",
    "options": [
      "A. テーブルの作成",
      "B. ユーザーにデータベースの権限（SELECT、INSERT等）を付与",
      "C. データの削除",
      "D. バックアップ"
    ],
    "correct": 1,
    "explanation": "GRANTはユーザーやロールに対してテーブルやDB単位でSELECT、INSERT、UPDATE、DELETE等の権限を付与するDCLコマンドです。"
  },
  {
    "id": 822,
    "question": "REVOKEコマンドの用途は？",
    "options": [
      "A. 権限の付与",
      "B. ユーザーから付与された権限を取り消す",
      "C. テーブルの作成",
      "D. データの更新"
    ],
    "correct": 1,
    "explanation": "REVOKEはGRANTで付与された権限をユーザーやロールから取り消すDCLコマンドです。"
  },
  {
    "id": 823,
    "question": "SQLの集約関数でNULL値はどう扱われる？",
    "options": [
      "A. 0として計算",
      "B. COUNT(*)以外の集約関数（SUM, AVG等）ではNULL値は無視される",
      "C. エラーになる",
      "D. NULLとして返される"
    ],
    "correct": 1,
    "explanation": "COUNT(*)は全行をカウントしますが、SUM、AVG、MIN、MAX等はNULL値をスキップして計算します。COUNT(列名)もNULLを除外。"
  },
  {
    "id": 824,
    "question": "Redisのpub/sub機能とは？",
    "options": [
      "A. データベースのレプリケーション",
      "B. チャンネルベースのメッセージのパブリッシュ/サブスクライブ機能",
      "C. トランザクション管理",
      "D. データの永続化"
    ],
    "correct": 1,
    "explanation": "RedisのPub/Subはチャンネルにメッセージを発行し、購読者にリアルタイム配信するメッセージング機能です。"
  },
  {
    "id": 825,
    "question": "Redis Clusterの特徴は？",
    "options": [
      "A. 単一ノード構成",
      "B. データを16384個のハッシュスロットに分割して複数ノードに分散",
      "C. レプリケーションのみ",
      "D. SQLサポート"
    ],
    "correct": 1,
    "explanation": "Redis Clusterはキーをハッシュスロット（0-16383）に分割して複数ノードに分散し、自動フェイルオーバーも提供します。"
  },
  {
    "id": 826,
    "question": "MongoDBのアグリゲーションパイプラインとは？",
    "options": [
      "A. インデックスの作成",
      "B. データ変換・集計処理をステージごとに順次処理するフレームワーク",
      "C. レプリケーション",
      "D. シャーディング"
    ],
    "correct": 1,
    "explanation": "アグリゲーションパイプラインは$match、$group、$sort等のステージを連結し、ドキュメントの変換・集計を段階的に処理します。"
  },
  {
    "id": 827,
    "question": "SQLのEXISTS述語の用途は？",
    "options": [
      "A. テーブルの存在確認",
      "B. サブクエリが結果を返すかどうかをブール値で判定",
      "C. NULL値の確認",
      "D. インデックスの確認"
    ],
    "correct": 1,
    "explanation": "EXISTSはサブクエリが1行以上の結果を返す場合にTRUEを返し、相関サブクエリで条件に合う関連レコードの存在確認に使います。"
  },
  {
    "id": 828,
    "question": "SQLのINとEXISTSの性能の違いは？",
    "options": [
      "A. 常にINが速い",
      "B. サブクエリの結果が大きい場合EXISTSが有利、小さい場合INが有利な傾向",
      "C. 常にEXISTSが速い",
      "D. 性能差なし"
    ],
    "correct": 1,
    "explanation": "INはサブクエリ結果をリスト化するため小さいセットで効率的、EXISTSは見つかった時点で停止するため大きいセットで効率的な傾向です。"
  },
  {
    "id": 829,
    "question": "DB接続の「コネクションプーリング」ツールの代表例は？",
    "options": [
      "A. nginx",
      "B. PgBouncer（PostgreSQL用）",
      "C. Redis",
      "D. Elasticsearch"
    ],
    "correct": 1,
    "explanation": "PgBouncerはPostgreSQL用の軽量なコネクションプーラーで、アプリケーションとDB間の接続を効率的にプールして再利用します。"
  },
  {
    "id": 830,
    "question": "データベースの「リードレプリカ」の目的は？",
    "options": [
      "A. 書込み性能の向上",
      "B. 読取り専用の複製DBを作成して読取りクエリの負荷を分散",
      "C. データの暗号化",
      "D. バックアップのみ"
    ],
    "correct": 1,
    "explanation": "リードレプリカはプライマリDBの読取り専用コピーで、SELECTクエリをレプリカに分散してプライマリの負荷を軽減します。"
  }
]
