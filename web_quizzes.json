[
  {
    "id": 931,
    "question": "HTMLの正式名称は？",
    "options": [
      "A. Hyper Text Makeup Language",
      "B. HyperText Markup Language",
      "C. High Tech Modern Language",
      "D. Hyper Tool Multi Language"
    ],
    "correct": 1,
    "explanation": "HTMLはHyperText Markup Languageの略で、Webページの構造をマークアップ（タグ付け）する言語です。"
  },
  {
    "id": 932,
    "question": "HTMLのセマンティックタグの利点は？",
    "options": [
      "A. 見た目の装飾",
      "B. 文書構造に意味を与え、アクセシビリティとSEOを向上",
      "C. JavaScriptの実行",
      "D. 通信速度の向上"
    ],
    "correct": 1,
    "explanation": "header, nav, main, article, section, footer等のセマンティックタグは内容の意味を明示し、スクリーンリーダーや検索エンジンに情報を提供します。"
  },
  {
    "id": 933,
    "question": "HTMLの<meta charset=\"UTF-8\">の役割は？",
    "options": [
      "A. 見た目の指定",
      "B. ページの文字エンコーディングをUTF-8に指定し文字化けを防止",
      "C. CSSの読み込み",
      "D. JavaScriptの実行"
    ],
    "correct": 1,
    "explanation": "meta charsetはブラウザにHTMLの文字コードを伝えます。UTF-8は日本語を含む多言語対応の国際標準エンコーディングです。"
  },
  {
    "id": 934,
    "question": "HTMLのブロック要素とインライン要素の違いは？",
    "options": [
      "A. 同じ",
      "B. ブロック要素は幅全体を占め改行する、インライン要素は内容分だけの幅で改行しない",
      "C. インラインが幅全体",
      "D. ブロックは改行しない"
    ],
    "correct": 1,
    "explanation": "div, p, h1等のブロック要素は前後に改行が入り幅いっぱい。span, a, strong等のインライン要素は内容分の幅で横に並びます。"
  },
  {
    "id": 935,
    "question": "HTMLのDOM（Document Object Model）とは？",
    "options": [
      "A. CSSの一部",
      "B. HTML文書をツリー構造のオブジェクトとして表現し、JSから動的に操作可能にするAPI",
      "C. サーバーのモデル",
      "D. データベースモデル"
    ],
    "correct": 1,
    "explanation": "DOMはHTMLをノードのツリー構造で表現し、JavaScriptからdocument.getElementById()等で要素の追加・変更・削除が可能です。"
  },
  {
    "id": 936,
    "question": "HTMLの<form>タグのmethod属性「GET」と「POST」の違いは？",
    "options": [
      "A. 同じ動作",
      "B. GETはURLにパラメータ付加（長さ制限あり）、POSTはボディに格納（機密データ向き）",
      "C. POSTの方が高速",
      "D. GETの方が安全"
    ],
    "correct": 1,
    "explanation": "GETはデータをURLクエリパラメータで送信し検索等に適用。POSTはHTTPボディで送信しパスワード等の機密データに適しています。"
  },
  {
    "id": 937,
    "question": "HTMLのdata-*属性の用途は？",
    "options": [
      "A. CSS専用",
      "B. カスタムデータをHTML要素に付与し、JavaScriptからdatasetで読取り可能",
      "C. SEO用",
      "D. サーバー通信用"
    ],
    "correct": 1,
    "explanation": "data-user-id=\"123\"等のカスタム属性はHTMLの仕様に準拠してデータを埋め込み、JS側でelement.dataset.userIdとして参照できます。"
  },
  {
    "id": 938,
    "question": "CSSのボックスモデルの構成要素は？",
    "options": [
      "A. width, height のみ",
      "B. content, padding, border, margin の4層",
      "C. content, margin のみ",
      "D. padding, border のみ"
    ],
    "correct": 1,
    "explanation": "CSSのボックスモデルは内側からcontent（内容）→padding（内余白）→border（枠線）→margin（外余白）の4層で構成されます。"
  },
  {
    "id": 939,
    "question": "CSSの「box-sizing: border-box」の効果は？",
    "options": [
      "A. marginを含めた計算",
      "B. widthとheightにpaddingとborderを含めて計算する",
      "C. contentのみの計算",
      "D. borderを無視"
    ],
    "correct": 1,
    "explanation": "border-boxはwidth/heightの指定値にpaddingとborderを含むため、レイアウト計算が直感的になります。デフォルトのcontent-boxは含みません。"
  },
  {
    "id": 940,
    "question": "CSSのFlexboxの主な用途は？",
    "options": [
      "A. 3Dレイアウト",
      "B. 1次元（行または列）での要素の配置・整列・間隔調整",
      "C. 印刷レイアウト",
      "D. アニメーション"
    ],
    "correct": 1,
    "explanation": "Flexboxはdisplay: flexで1方向（行/列）の要素配置を柔軟に制御します。justify-content, align-items等で整列を指定。"
  },
  {
    "id": 941,
    "question": "CSS Gridの主な用途は？",
    "options": [
      "A. テキスト装飾",
      "B. 2次元（行と列の両方）のグリッドベースのレイアウト",
      "C. アニメーション",
      "D. フォントの設定"
    ],
    "correct": 1,
    "explanation": "CSS Gridはdisplay: gridで行と列の2次元レイアウトを定義し、grid-template-columns/rowsで複雑なレイアウトを効率的に構築します。"
  },
  {
    "id": 942,
    "question": "CSSのメディアクエリ（@media）の用途は？",
    "options": [
      "A. JavaScriptの実行",
      "B. 画面サイズや条件に応じて異なるスタイルを適用（レスポンシブデザイン）",
      "C. データベース接続",
      "D. サーバー通信"
    ],
    "correct": 1,
    "explanation": "@media (max-width: 768px) { ... } のように画面幅等に応じてCSSを切り替え、モバイル・タブレット・PC各画面に対応します。"
  },
  {
    "id": 943,
    "question": "CSSの「position: relative」と「position: absolute」の違いは？",
    "options": [
      "A. 同じ動作",
      "B. relativeは元の位置を基準に移動、absoluteは最も近いposition付き親を基準に配置",
      "C. absoluteは元の位置基準",
      "D. relativeは親を基準"
    ],
    "correct": 1,
    "explanation": "relativeは通常フローの位置からオフセット。absoluteは通常フローから外れ、positionが指定された最も近い祖先要素を基準に配置されます。"
  },
  {
    "id": 944,
    "question": "CSSのz-indexの用途は？",
    "options": [
      "A. 文字サイズ",
      "B. 要素の重なり順（前後関係）を制御する",
      "C. 透明度",
      "D. 回転角度"
    ],
    "correct": 1,
    "explanation": "z-indexはpositionが設定された要素の重なり順を制御します。値が大きいほど前面に表示されます。スタッキングコンテキストに注意。"
  },
  {
    "id": 945,
    "question": "CSSの詳細度（Specificity）の優先順は？",
    "options": [
      "A. 要素 > クラス > ID",
      "B. !important > インライン > ID > クラス/属性/擬似クラス > 要素/擬似要素",
      "C. クラス > ID > 要素",
      "D. アルファベット順"
    ],
    "correct": 1,
    "explanation": "CSSの優先度は !important → inline style → #id (0,1,0,0) → .class (0,0,1,0) → element (0,0,0,1) の順で高い方が適用されます。"
  },
  {
    "id": 946,
    "question": "CSSの「:hover」擬似クラスの用途は？",
    "options": [
      "A. ページ読込時に適用",
      "B. マウスカーソルが要素上にある時にスタイルを適用",
      "C. クリック時に適用",
      "D. フォーカス時に適用"
    ],
    "correct": 1,
    "explanation": ":hoverはマウスポインタが要素上にある状態で適用されるインタラクティブなスタイルで、ボタンの色変化等に使います。"
  },
  {
    "id": 947,
    "question": "CSS変数（カスタムプロパティ）の定義方法は？",
    "options": [
      "A. $color: red;",
      "B. --primary-color: #333; で定義し var(--primary-color) で使用",
      "C. @color: red;",
      "D. color = red;"
    ],
    "correct": 1,
    "explanation": "CSS変数は--で始まる名前で定義し、var()で参照します。:rootに定義すればグローバルに使え、テーマ管理に便利です。"
  },
  {
    "id": 948,
    "question": "CSSのtransitionの用途は？",
    "options": [
      "A. レイアウト変更",
      "B. プロパティの値の変化を滑らかにアニメーションさせる",
      "C. フォントの変更",
      "D. 要素の削除"
    ],
    "correct": 1,
    "explanation": "transitionはhover等でプロパティが変わる際に、指定した時間をかけて滑らかに変化させます。例：transition: background-color 0.3s ease;"
  },
  {
    "id": 949,
    "question": "REST APIの「REST」の意味は？",
    "options": [
      "A. Remote Execution Server Technology",
      "B. Representational State Transfer",
      "C. Request-Response Service Technology",
      "D. Rapid Endpoint Service Tool"
    ],
    "correct": 1,
    "explanation": "RESTはRepresentational State Transferの略で、HTTPメソッドとURLでリソースを操作するアーキテクチャスタイルです。"
  },
  {
    "id": 950,
    "question": "RESTのHTTPメソッド「GET」「POST」「PUT」「DELETE」の対応は？",
    "options": [
      "A. すべて同じ操作",
      "B. GET=取得、POST=作成、PUT=更新、DELETE=削除（CRUD操作に対応）",
      "C. GET=作成、POST=取得",
      "D. PUT=削除、DELETE=更新"
    ],
    "correct": 1,
    "explanation": "RESTではHTTPメソッドがCRUD操作に対応: GET(Read), POST(Create), PUT(Update), DELETE(Delete)。"
  },
  {
    "id": 951,
    "question": "RESTful APIで「ステートレス」とは？",
    "options": [
      "A. サーバーが状態を保持",
      "B. 各リクエストが必要な情報を全て含み、サーバーはクライアントの状態を保持しない",
      "C. クライアントが状態を保持しない",
      "D. セッションを使用する"
    ],
    "correct": 1,
    "explanation": "RESTのステートレス制約はサーバーがリクエスト間のクライアント状態を保持せず、各リクエストが完結していることを要求します。"
  },
  {
    "id": 952,
    "question": "HTTPステータスコード「200」の意味は？",
    "options": [
      "A. リダイレクト",
      "B. OK（リクエスト成功）",
      "C. Not Found",
      "D. Server Error"
    ],
    "correct": 1,
    "explanation": "200 OKはリクエストが正常に処理され、レスポンスボディに結果が含まれることを示す最も一般的な成功ステータスです。"
  },
  {
    "id": 953,
    "question": "HTTPステータスコード「201」の意味は？",
    "options": [
      "A. OK",
      "B. Created（リソースの作成成功）",
      "C. No Content",
      "D. Bad Request"
    ],
    "correct": 1,
    "explanation": "201 CreatedはPOSTリクエスト等で新しいリソースが正常に作成されたことを示します。Locationヘッダに新リソースのURLを含むことが多い。"
  },
  {
    "id": 954,
    "question": "HTTPステータスコード「404」の意味は？",
    "options": [
      "A. サーバーエラー",
      "B. Not Found（リソースが見つからない）",
      "C. 認証エラー",
      "D. OK"
    ],
    "correct": 1,
    "explanation": "404 Not Foundは指定されたURLのリソースがサーバー上に存在しないことを示すクライアントエラーです。"
  },
  {
    "id": 955,
    "question": "HTTPステータスコード「401」と「403」の違いは？",
    "options": [
      "A. 同じ意味",
      "B. 401は認証未済（ログインが必要）、403は認証済みだが権限不足（アクセス禁止）",
      "C. 401が権限不足",
      "D. 403が認証未済"
    ],
    "correct": 1,
    "explanation": "401 Unauthorized は認証情報が未提供/無効。403 Forbidden は認証済みですが、そのリソースへのアクセス権限がありません。"
  },
  {
    "id": 956,
    "question": "HTTPステータスコード「500」の意味は？",
    "options": [
      "A. クライアントエラー",
      "B. Internal Server Error（サーバー内部エラー）",
      "C. リダイレクト",
      "D. 成功"
    ],
    "correct": 1,
    "explanation": "500 Internal Server Errorはサーバー側で予期しないエラーが発生したことを示す汎用サーバーエラーです。"
  },
  {
    "id": 957,
    "question": "RESTful APIのURLパス設計のベストプラクティスは？",
    "options": [
      "A. 動詞を使う",
      "B. リソースを複数形名詞で表す（/api/users, /api/users/123）",
      "C. アクションをURLに含める",
      "D. パラメータをパスに含めない"
    ],
    "correct": 1,
    "explanation": "RESTful URLはリソースを名詞（複数形）で表現し、HTTPメソッドでアクションを示します。/api/users (GET=一覧, POST=作成) /api/users/123 (GET=詳細)."
  },
  {
    "id": 958,
    "question": "GraphQLとREST APIの主な違いは？",
    "options": [
      "A. 同じもの",
      "B. GraphQLはクライアントが必要なデータの形を指定し、1つのエンドポイントで取得",
      "C. RESTの方が柔軟",
      "D. GraphQLはサーバー側が形を決定"
    ],
    "correct": 1,
    "explanation": "GraphQLはクライアントがクエリで必要なフィールドを指定するため、オーバーフェッチ/アンダーフェッチを防ぎ、単一エンドポイント(/graphql)で操作します。"
  },
  {
    "id": 959,
    "question": "GraphQLの3つの操作タイプは？",
    "options": [
      "A. GET, POST, PUT",
      "B. Query（取得）, Mutation（変更）, Subscription（リアルタイム購読）",
      "C. SELECT, INSERT, UPDATE",
      "D. Read, Write, Delete"
    ],
    "correct": 1,
    "explanation": "QueryはREST GETに相当する取得、MutationはPOST/PUT/DELETEに相当する変更、Subscriptionはリアルタイムでデータ変更を受信します。"
  },
  {
    "id": 960,
    "question": "GraphQLの「スキーマ」の役割は？",
    "options": [
      "A. データのバリデーション",
      "B. APIで利用可能な型、クエリ、ミューテーションを定義するコントラクト",
      "C. データベース設計",
      "D. 認証設定"
    ],
    "correct": 1,
    "explanation": "GraphQLスキーマはtype Query { users: [User] } のように型システムでAPIの仕様を定義し、クライアントとサーバーの契約として機能します。"
  },
  {
    "id": 961,
    "question": "GraphQLの「N+1問題」を防ぐ方法は？",
    "options": [
      "A. キャッシュのみ",
      "B. DataLoaderパターンでバッチ処理とキャッシュを実現",
      "C. REST APIに変更",
      "D. クエリを制限"
    ],
    "correct": 1,
    "explanation": "DataLoaderはリクエストをバッチ化してまとめてDB取得し、N+1クエリ問題を解決します。Facebook開発のdataloader等が代表的。"
  },
  {
    "id": 962,
    "question": "JWT（JSON Web Token）の構造は？",
    "options": [
      "A. 1つのパート",
      "B. Header（ヘッダ）.Payload（ペイロード）.Signature（署名）の3パート",
      "C. 2つのパート",
      "D. 4つのパート"
    ],
    "correct": 1,
    "explanation": "JWTはBase64URLエンコードされた3部分をドット(.)で結合: Header（アルゴリズム等）、Payload（クレーム）、Signature（改ざん検知用署名）。"
  },
  {
    "id": 963,
    "question": "JWTのPayloadに保存すべきでないデータは？",
    "options": [
      "A. ユーザーID",
      "B. パスワードなどの機密情報（JWTは暗号化ではなくBase64エンコード）",
      "C. 有効期限",
      "D. トークンの発行者"
    ],
    "correct": 1,
    "explanation": "JWTのPayloadはBase64URLでエンコードされるだけで暗号化されていないため、パスワード等の機密情報は含めるべきではありません。"
  },
  {
    "id": 964,
    "question": "JWTの「Access Token」と「Refresh Token」の使い分けは？",
    "options": [
      "A. 同じもの",
      "B. Access Tokenは短寿命でAPI認証に使用、Refresh Tokenは長寿命でAccess Tokenの再発行に使用",
      "C. Refresh Tokenは直接API認証",
      "D. Access Tokenは長寿命"
    ],
    "correct": 1,
    "explanation": "Access Tokenは短寿命（数分〜数時間）でAPIリクエストに添付。Refresh Tokenは長寿命でAccess Tokenの期限切れ時に新しいものを取得します。"
  },
  {
    "id": 965,
    "question": "JWTの署名検証の仕組みは？",
    "options": [
      "A. パスワードで検証",
      "B. Header+PayloadをシークレットキーでHMACまたは公開鍵で署名し改ざんを検出",
      "C. ハッシュ値の比較",
      "D. ユーザーIDで検証"
    ],
    "correct": 1,
    "explanation": "署名はHeader+Payloadをシークレットキー（HMAC）または秘密鍵（RSA等）で生成し、受信側が同じ計算で改ざんの有無を検証します。"
  },
  {
    "id": 966,
    "question": "Cookie のHttpOnly属性の効果は？",
    "options": [
      "A. HTTPSのみで送信",
      "B. JavaScriptからdocument.cookieでアクセスできなくなりXSS対策になる",
      "C. HTTP通信専用",
      "D. サーバー側でのみ生成可能"
    ],
    "correct": 1,
    "explanation": "HttpOnlyフラグが付いたCookieはJavaScriptから読み取り不可になり、XSS攻撃でCookieを盗まれるリスクを軽減します。"
  },
  {
    "id": 967,
    "question": "CookieのSecure属性の効果は？",
    "options": [
      "A. 暗号化して保存",
      "B. HTTPS接続時のみCookieが送信される（HTTP通信では送信されない）",
      "C. HttpOnlyと同じ",
      "D. SameSiteと同じ"
    ],
    "correct": 1,
    "explanation": "Secure属性が付いたCookieはHTTPS接続でのみサーバーに送信され、暗号化されていないHTTP通信での盗聴を防ぎます。"
  },
  {
    "id": 968,
    "question": "CookieのSameSite属性の「Strict」「Lax」「None」の違いは？",
    "options": [
      "A. すべて同じ",
      "B. Strictは同一サイトのみ、Laxはトップレベルナビゲーション許可、NoneはクロスサイトOK（Secure必須）",
      "C. Noneが最も安全",
      "D. Strictはクロスサイト許可"
    ],
    "correct": 1,
    "explanation": "StrictはCSRF対策最強だがユーザー体験に影響。LaxはGETナビゲーションは許可。NoneはSecure必須でクロスサイト送信を許可。"
  },
  {
    "id": 969,
    "question": "セッション（Session）管理の基本的な仕組みは？",
    "options": [
      "A. クライアント側にすべて保存",
      "B. サーバー側にセッションデータを保存し、クライアントにはセッションIDのみをCookieで渡す",
      "C. URLにデータを付加",
      "D. LocalStorageに保存"
    ],
    "correct": 1,
    "explanation": "サーバーはセッションIDに紐付くデータ（ログイン状態等）をメモリ/DBに保存し、CookieでセッションIDをクライアントに渡します。"
  },
  {
    "id": 970,
    "question": "セッション固定攻撃（Session Fixation）の対策は？",
    "options": [
      "A. セッションIDを変更しない",
      "B. ログイン成功時にセッションIDを再生成する",
      "C. Cookieを使わない",
      "D. HTTPSを使わない"
    ],
    "correct": 1,
    "explanation": "セッション固定攻撃は攻撃者が事前にセッションIDを設定する手法で、ログイン後にセッションIDを再発行（regenerate）することで対策します。"
  },
  {
    "id": 971,
    "question": "CORS（Cross-Origin Resource Sharing）とは？",
    "options": [
      "A. Cookieの共有",
      "B. 異なるオリジンからのHTTPリクエストを許可するブラウザのセキュリティ機構",
      "C. CSS共有機能",
      "D. サーバー間通信"
    ],
    "correct": 1,
    "explanation": "CORSはSame-Origin Policyの制限を緩和し、サーバーがAccess-Control-Allow-Originヘッダで許可したオリジンからのリクエストを受け付ける仕組みです。"
  },
  {
    "id": 972,
    "question": "CORSの「プリフライトリクエスト」とは？",
    "options": [
      "A. GETリクエスト",
      "B. ブラウザが本リクエスト前にOPTIONSメソッドで送信可否をサーバーに確認する事前確認",
      "C. POSTリクエスト",
      "D. リダイレクト"
    ],
    "correct": 1,
    "explanation": "プリフライトはPUT/DELETE等やカスタムヘッダ使用時にブラウザが自動でOPTIONSリクエストを送り、サーバーの許可を事前確認するCORSの仕組みです。"
  },
  {
    "id": 973,
    "question": "「オリジン」の構成要素は？",
    "options": [
      "A. ドメインのみ",
      "B. スキーム（プロトコル）+ ホスト（ドメイン）+ ポート の3つ",
      "C. URLパス全体",
      "D. IPアドレスのみ"
    ],
    "correct": 1,
    "explanation": "オリジンはhttps://example.com:443のようにスキーム、ホスト、ポートの3つの組み合わせです。いずれか1つでも異なれば別オリジンです。"
  },
  {
    "id": 974,
    "question": "SPA（Single Page Application）の特徴は？",
    "options": [
      "A. ページごとにリロード",
      "B. 1つのHTMLページ上でJavaScriptが動的にコンテンツを切り替え、フルリロードなし",
      "C. サーバーサイドで全HTMLを生成",
      "D. 静的サイトのみ"
    ],
    "correct": 1,
    "explanation": "SPAは初回に1つのHTMLを読み込み、以降はJSがAjax/fetchでデータを取得してDOMを更新するため、高速なUXを提供します。"
  },
  {
    "id": 975,
    "question": "SPAの欠点は？",
    "options": [
      "A. UXが悪い",
      "B. 初期ロードが遅い、SEOが困難、JavaScriptが必須",
      "C. サーバー負荷が高い",
      "D. セキュリティが高い"
    ],
    "correct": 1,
    "explanation": "SPAはJSバンドルが大きいため初期表示が遅く、クローラーがJSを実行できないとSEOに不利。SSR/SSGとの併用が解決策です。"
  },
  {
    "id": 976,
    "question": "SSR（Server-Side Rendering）とは？",
    "options": [
      "A. クライアント側でレンダリング",
      "B. サーバー側でHTMLを生成してからクライアントに送信するレンダリング方式",
      "C. 静的ファイルの提供",
      "D. CDNキャッシュ"
    ],
    "correct": 1,
    "explanation": "SSRはサーバーでReact等のコンポーネントをHTMLとして構築し、完全なHTMLをクライアントに送信します。初期表示が高速でSEOにも有利。"
  },
  {
    "id": 977,
    "question": "SSG（Static Site Generation）とは？",
    "options": [
      "A. SSRと同じ",
      "B. ビルド時に全ページのHTMLを事前生成し、CDNから配信する方式",
      "C. クライアント側生成",
      "D. APIサーバー"
    ],
    "correct": 1,
    "explanation": "SSGはビルド時にHTMLを生成して静的ファイルとして配信するため、最高速でCDN配信に適しています。更新頻度の低いコンテンツに最適。"
  },
  {
    "id": 978,
    "question": "CSR（Client-Side Rendering）とは？",
    "options": [
      "A. SSRと同じ",
      "B. ブラウザでJavaScriptが実行されてDOMを構築するレンダリング方式",
      "C. ビルド時生成",
      "D. サーバーがHTMLを生成"
    ],
    "correct": 1,
    "explanation": "CSRはサーバーから最小限のHTMLとJSバンドルを受け取り、ブラウザがJSを実行してUIを構築するSPAの標準的なレンダリング方式です。"
  },
  {
    "id": 979,
    "question": "ハイドレーション（Hydration）とは？",
    "options": [
      "A. CSSのアニメーション",
      "B. SSRで生成した静的HTMLにクライアント側のJSのイベントハンドラを結び付ける処理",
      "C. データベース接続",
      "D. CDNキャッシュ"
    ],
    "correct": 1,
    "explanation": "ハイドレーションはSSRされた静的HTMLにReact等のJSフレームワークがイベントリスナー等を付与して対話的にする処理です。"
  },
  {
    "id": 980,
    "question": "Next.jsの特徴は？",
    "options": [
      "A. バックエンド専用",
      "B. React ベースでSSR/SSG/CSR/ISRを統合したフルスタックWebフレームワーク",
      "C. Vue.jsベース",
      "D. 静的サイトのみ"
    ],
    "correct": 1,
    "explanation": "Next.jsはReactをベースに、SSR、SSG、ISR、API Routes、ミドルウェア等を提供するVercel開発のフルスタックフレームワークです。"
  },
  {
    "id": 981,
    "question": "Next.jsのApp RouterとPages Routerの違いは？",
    "options": [
      "A. 同じもの",
      "B. App Routerはフォルダベースでサーバーコンポーネント対応、Pages Routerはファイルベースの従来方式",
      "C. Pages Routerが新しい",
      "D. App Routerは廃止予定"
    ],
    "correct": 1,
    "explanation": "App Router（v13+）はappディレクトリでReact Server Components、ネストレイアウト等を活用。Pages Routerはpagesディレクトリの従来方式です。"
  },
  {
    "id": 982,
    "question": "Next.jsのISR（Incremental Static Regeneration）とは？",
    "options": [
      "A. SSRと同じ",
      "B. ビルド後も指定間隔で静的ページをバックグラウンドで再生成する方式",
      "C. CSRの一種",
      "D. キャッシュ無効化"
    ],
    "correct": 1,
    "explanation": "ISRはSSGのメリット（高速配信）を持ちながら、revalidate時間を指定してバックグラウンドでページを再生成し、コンテンツの鮮度を保ちます。"
  },
  {
    "id": 983,
    "question": "Next.jsのServer Componentsの利点は？",
    "options": [
      "A. クライアントで実行",
      "B. サーバーでレンダリングされJSバンドルに含まれないため、バンドルサイズを削減",
      "C. 状態管理可能",
      "D. useEffectが使える"
    ],
    "correct": 1,
    "explanation": "Server Componentsはサーバーで実行されクライアントにJSが送信されないため、バンドルサイズ削減とサーバー資源（DB等）への直接アクセスが可能。"
  },
  {
    "id": 984,
    "question": "Next.jsのAPI Routes の用途は？",
    "options": [
      "A. フロントエンドのみ",
      "B. Next.jsプロジェクト内にサーバーサイドのAPIエンドポイントを作成",
      "C. CSSの適用",
      "D. 静的ファイル配信"
    ],
    "correct": 1,
    "explanation": "API RoutesはNext.js内にバックエンドAPIを構築でき、pages/api/またはapp/api/にファイルを作るとAPIエンドポイントになります。"
  },
  {
    "id": 985,
    "question": "Next.jsのミドルウェア（middleware.ts）の用途は？",
    "options": [
      "A. CSSの変換",
      "B. リクエスト処理前に認証チェック、リダイレクト、ヘッダー変更等を行うEdge関数",
      "C. データベース接続",
      "D. ビルド設定"
    ],
    "correct": 1,
    "explanation": "middleware.tsはリクエストがページに到達する前にEdge Runtimeで実行され、認証チェック、リダイレクト、地理制限等を処理します。"
  },
  {
    "id": 986,
    "question": "Reactの「仮想DOM（Virtual DOM）」の仕組みは？",
    "options": [
      "A. 実DOMを直接操作",
      "B. メモリ上に軽量なDOMコピーを保持し差分だけ実DOMに反映（Reconciliation）",
      "C. Shadow DOM と同じ",
      "D. サーバーサイドDOM"
    ],
    "correct": 1,
    "explanation": "仮想DOMは状態変更後にメモリ上のDOM表現を再計算し、前回との差分（diffing）を検出して最小限の実DOM操作で更新します。"
  },
  {
    "id": 987,
    "question": "Reactのコンポーネントのpropsとstateの違いは？",
    "options": [
      "A. 同じもの",
      "B. propsは親から渡される読取り専用データ、stateはコンポーネント内部で管理する可変データ",
      "C. stateは親から渡す",
      "D. propsは内部管理"
    ],
    "correct": 1,
    "explanation": "propsは親→子への一方向データフローで不変。stateはuseState等で管理するコンポーネント固有の可変データで、変更するとre-renderされます。"
  },
  {
    "id": 988,
    "question": "ReactのuseState フックの用途は？",
    "options": [
      "A. 副作用の処理",
      "B. 関数コンポーネントに状態変数を追加し、変更時に再レンダリング",
      "C. コンテキスト作成",
      "D. メモ化"
    ],
    "correct": 1,
    "explanation": "const [count, setCount] = useState(0) のように状態変数と更新関数のペアを返し、setCountで値を更新するとコンポーネントが再描画されます。"
  },
  {
    "id": 989,
    "question": "ReactのuseEffect フックの用途は？",
    "options": [
      "A. 状態管理",
      "B. 副作用（API呼出し、DOM操作、タイマー等）をレンダリング後に実行",
      "C. スタイルの適用",
      "D. ルーティング"
    ],
    "correct": 1,
    "explanation": "useEffectは描画後にデータ取得やeventListener登録等の副作用を実行し、第2引数の依存配列で実行タイミングを制御します。"
  },
  {
    "id": 990,
    "question": "ReactのuseContext フックの用途は？",
    "options": [
      "A. ルーティング",
      "B. コンポーネントツリーの深いネストにprops drilling無しでデータを渡す",
      "C. 非同期処理",
      "D. フォームバリデーション"
    ],
    "correct": 1,
    "explanation": "useContextはReact.createContextで作成したコンテキストの値を子孫コンポーネントがpropsを中継せず直接取得するフックです。"
  },
  {
    "id": 991,
    "question": "ReactのuseMemo フックの用途は？",
    "options": [
      "A. 状態管理",
      "B. 計算コストの高い値をメモ化し、依存値が変わらなければ再計算を回避",
      "C. 副作用の実行",
      "D. DOMの参照"
    ],
    "correct": 1,
    "explanation": "useMemo(() => expensiveCalc(a, b), [a, b]) は依存配列の値が変わらなければキャッシュした値を返し、不要な再計算を防ぎます。"
  },
  {
    "id": 992,
    "question": "ReactのuseCallback フックの用途は？",
    "options": [
      "A. 値のメモ化",
      "B. 関数をメモ化し、依存値が変わらなければ同じ参照を保持（子コンポーネントの不要な再レンダリング防止）",
      "C. 状態管理",
      "D. 副作用"
    ],
    "correct": 1,
    "explanation": "useCallbackは関数自体をメモ化し、React.memoされた子コンポーネントへのprops変更を防ぎ、不要な再レンダリングを回避します。"
  },
  {
    "id": 993,
    "question": "ReactのuseRef フックの用途は？",
    "options": [
      "A. 状態管理",
      "B. レンダリングをトリガーしない可変値の保持やDOM要素への直接参照",
      "C. コンテキスト",
      "D. ルーティング"
    ],
    "correct": 1,
    "explanation": "useRefは{current: value}オブジェクトを返し、値変更では再レンダリングが発生しません。DOM参照（ref.current）やタイマーID保持等に使用。"
  },
  {
    "id": 994,
    "question": "Reactのカスタムフックの目的は？",
    "options": [
      "A. コンポーネントの作成",
      "B. ロジックを再利用可能な関数として切り出す（use〇〇という命名規約）",
      "C. CSSの適用",
      "D. ルーティング設定"
    ],
    "correct": 1,
    "explanation": "カスタムフックはuseXxxの命名でフック呼び出しを含むロジックを関数に抽出し、複数コンポーネントで再利用可能にします。"
  },
  {
    "id": 995,
    "question": "Reactの「Key」propsの重要性は？",
    "options": [
      "A. セキュリティ用",
      "B. リスト内の要素を一意に識別し、効率的なDOM差分更新（Reconciliation）を可能にする",
      "C. スタイリング用",
      "D. ルーティング用"
    ],
    "correct": 1,
    "explanation": "keyはリスト要素に付ける一意の識別子で、Reactのdiffingアルゴリズムが効率的に要素の追加・削除・並替えを検出するために必須です。"
  },
  {
    "id": 996,
    "question": "Reactの状態管理ライブラリはどれか？",
    "options": [
      "A. Express",
      "B. Redux / Zustand / Jotai / Recoil",
      "C. Axios",
      "D. Webpack"
    ],
    "correct": 1,
    "explanation": "Redux（Flux型）、Zustand（軽量）、Jotai/Recoil（アトム型）はReactのグローバル状態管理ライブラリの代表例です。"
  },
  {
    "id": 997,
    "question": "LocalStorageとSessionStorageの違いは？",
    "options": [
      "A. 同じ動作",
      "B. LocalStorageは永続保存、SessionStorageはタブ/ウィンドウを閉じると削除",
      "C. SessionStorageが永続",
      "D. LocalStorageはサーバー側"
    ],
    "correct": 1,
    "explanation": "LocalStorageはブラウザを閉じてもデータが残る。SessionStorageはブラウザタブを閉じるとクリアされる。どちらもCookieより大容量（5MB程度）。"
  },
  {
    "id": 998,
    "question": "Webアクセシビリティ（a11y）の「WAI-ARIA」とは？",
    "options": [
      "A. CSSフレームワーク",
      "B. Webコンテンツをスクリーンリーダー等の支援技術に意味を伝えるための属性仕様",
      "C. JavaScriptライブラリ",
      "D. HTMLの新しいバージョン"
    ],
    "correct": 1,
    "explanation": "WAI-ARIAはrole, aria-label, aria-hidden等の属性で、動的UIの意味や状態を支援技術に伝えるW3Cの仕様です。"
  },
  {
    "id": 999,
    "question": "Webパフォーマンスの指標「LCP（Largest Contentful Paint）」とは？",
    "options": [
      "A. ページの総ロード時間",
      "B. ビューポート内の最大コンテンツ要素が描画されるまでの時間",
      "C. JavaScriptの実行時間",
      "D. DNS解決時間"
    ],
    "correct": 1,
    "explanation": "LCPはCore Web Vitalsの1つで、ページの主要コンテンツ（画像、テキストブロック等）が表示されるまでの時間。2.5秒以内が目標。"
  },
  {
    "id": 1000,
    "question": "レスポンシブデザインの「モバイルファースト」アプローチとは？",
    "options": [
      "A. デスクトップから設計",
      "B. モバイル向けデザインを基準にし、メディアクエリのmin-widthで大画面向けに拡張",
      "C. アプリ専用設計",
      "D. テキストのみ設計"
    ],
    "correct": 1,
    "explanation": "モバイルファーストはモバイル向けCSSをデフォルトとし、@media(min-width:768px)等で大画面用スタイルを追加するアプローチです。"
  },
  {
    "id": 1001,
    "question": "CSSの「rem」と「em」の違いは？",
    "options": [
      "A. 同じ単位",
      "B. remはルート要素のfont-size基準、emは親要素のfont-size基準",
      "C. emがルート基準",
      "D. remがピクセル"
    ],
    "correct": 1,
    "explanation": "1remは<html>のfont-size（デフォルト16px）を基準。1emは親要素のfont-sizeを基準。ネストで値が変わるemよりremの方が予測しやすい。"
  },
  {
    "id": 1002,
    "question": "fetchAPIの基本的な使い方は？",
    "options": [
      "A. XMLHttpRequestと同じ",
      "B. fetch(url).then(res => res.json()).then(data => ...) でPromiseベースのHTTPリクエスト",
      "C. 同期実行",
      "D. Node.js専用"
    ],
    "correct": 1,
    "explanation": "fetch APIはPromiseベースのモダンなHTTPリクエストAPIで、async/awaitと組み合わせてconst data = await (await fetch(url)).json()のように使います。"
  },
  {
    "id": 1003,
    "question": "WebSocketとHTTPの違いは？",
    "options": [
      "A. 同じプロトコル",
      "B. WebSocketは双方向のリアルタイム通信、HTTPはリクエスト-レスポンスの一方向",
      "C. HTTPの方がリアルタイム",
      "D. WebSocketはステートレス"
    ],
    "correct": 1,
    "explanation": "WebSocketはサーバーとクライアント間の持続的な双方向接続で、サーバーからプッシュ通知が可能。チャット、リアルタイム更新に最適。"
  },
  {
    "id": 1004,
    "question": "Service Workerの役割は？",
    "options": [
      "A. DOMの操作",
      "B. ブラウザのバックグラウンドで動作し、オフラインキャッシュやプッシュ通知を実現するプロキシ",
      "C. データベース操作",
      "D. CSS処理"
    ],
    "correct": 1,
    "explanation": "Service Workerはブラウザとネットワークの間で動作するプロキシで、リクエストの傍受、キャッシュ管理、オフライン対応、プッシュ通知を実現します。"
  },
  {
    "id": 1005,
    "question": "PWA（Progressive Web App）の主な特徴は？",
    "options": [
      "A. ネイティブアプリのみ",
      "B. Webアプリにオフライン対応、ホーム画面追加、プッシュ通知等のネイティブ的機能を追加",
      "C. サーバーサイドのみ",
      "D. デスクトップ専用"
    ],
    "correct": 1,
    "explanation": "PWAはService Worker、manifest.json、HTTPSにより、Webアプリにオフライン機能、インストール、プッシュ通知等のネイティブ体験を提供します。"
  },
  {
    "id": 1006,
    "question": "CSP（Content Security Policy）の目的は？",
    "options": [
      "A. CSSの最適化",
      "B. XSS攻撃を緩和するため、許可するリソースの読込み元をHTTPヘッダで制限",
      "C. キャッシュ制御",
      "D. CORS設定"
    ],
    "correct": 1,
    "explanation": "CSPはContent-Security-Policyヘッダでスクリプト、スタイル、画像等の読込みを許可するオリジンを指定し、XSSやデータインジェクションを防ぎます。"
  },
  {
    "id": 1007,
    "question": "Webバンドラーの代表例は？",
    "options": [
      "A. Express",
      "B. Webpack、Vite、esbuild、Rollup",
      "C. React",
      "D. Node.js"
    ],
    "correct": 1,
    "explanation": "バンドラーはJS/CSS/画像等をまとめて最適化します。Webpack（設定豊富）、Vite（高速開発サーバー）、esbuild（超高速ビルド）等が代表的。"
  },
  {
    "id": 1008,
    "question": "コード分割（Code Splitting）の目的は？",
    "options": [
      "A. コードの暗号化",
      "B. JavaScriptバンドルを複数チャンクに分割し、初期ロード時間を短縮",
      "C. コードの圧縮",
      "D. コードの難読化"
    ],
    "correct": 1,
    "explanation": "Code Splittingは巨大なJSバンドルをルート単位やコンポーネント単位で分割し、必要な時だけロード（遅延読込み）して初期表示を高速化します。"
  },
  {
    "id": 1009,
    "question": "Reactの「React.lazy」の用途は？",
    "options": [
      "A. 状態の遅延初期化",
      "B. コンポーネントを動的インポートしてコード分割を実現（遅延ローディング）",
      "C. CSSの遅延読込み",
      "D. APIの遅延呼出し"
    ],
    "correct": 1,
    "explanation": "React.lazy(() => import('./Component'))でコンポーネントを動的インポートし、Suspenseと組み合わせてロード中のフォールバックを表示します。"
  },
  {
    "id": 1010,
    "question": "Tree Shakingとは？",
    "options": [
      "A. DOMツリーの操作",
      "B. バンドル時に使用されていないコード（デッドコード）を除去して出力サイズを削減",
      "C. CSSの最適化",
      "D. テストの実行"
    ],
    "correct": 1,
    "explanation": "Tree ShakingはES Modulesのstaticインポートを分析し、参照されていないexportをバンドルから除去します。Webpack、Vite等が対応。"
  },
  {
    "id": 1011,
    "question": "SSE（Server-Sent Events）とは？",
    "options": [
      "A. WebSocketと同じ",
      "B. サーバーからクライアントへの一方向リアルタイムストリーミング（HTTP上で動作）",
      "C. 双方向通信",
      "D. ファイル転送"
    ],
    "correct": 1,
    "explanation": "SSEはHTTP上でサーバーからクライアントへの一方向イベントストリームを提供します。WebSocketより軽量で、通知やフィード更新に適しています。"
  },
  {
    "id": 1012,
    "question": "OAuth 2.0の「認可コードフロー」の流れは？",
    "options": [
      "A. トークンを直接発行",
      "B. 認可コード取得→コードとシークレットでアクセストークン取得の2段階",
      "C. パスワード送信のみ",
      "D. APIキーのみ"
    ],
    "correct": 1,
    "explanation": "認可コードフローは①クライアントが認可サーバーにリダイレクト②ユーザー認証後に認可コード取得③コード+client_secretでアクセストークン取得の2段階です。"
  },
  {
    "id": 1013,
    "question": "HTTPの「Content-Type: application/json」の意味は？",
    "options": [
      "A. HTMLを送信",
      "B. リクエスト/レスポンスのボディがJSON形式であることを示すMIMEタイプ",
      "C. XMLを送信",
      "D. テキストを送信"
    ],
    "correct": 1,
    "explanation": "Content-Typeヘッダはボディのデータ形式を示し、application/jsonはJSON形式、text/htmlはHTML、multipart/form-dataはファイルアップロードに使います。"
  },
  {
    "id": 1014,
    "question": "HTTPヘッダ「Cache-Control: no-cache」の意味は？",
    "options": [
      "A. キャッシュしない",
      "B. キャッシュは保存するが、使用前にサーバーに再検証（revalidation）が必要",
      "C. 永久キャッシュ",
      "D. no-storeと同じ"
    ],
    "correct": 1,
    "explanation": "no-cacheはキャッシュを禁止するのではなく、使用前にサーバーにETag等で鮮度を確認する必要があります。一切キャッシュしないのはno-store。"
  },
  {
    "id": 1015,
    "question": "React Router の<Link>コンポーネントと通常の<a>タグの違いは？",
    "options": [
      "A. 同じ動作",
      "B. Linkはページ全体をリロードせずクライアントサイドでルーティング（SPA遷移）",
      "C. aタグの方が高速",
      "D. Linkはサーバーに遷移"
    ],
    "correct": 1,
    "explanation": "React RouterのLinkはブラウザ履歴APIを使ってURLを変更し、対応するコンポーネントをレンダリングします。フルリロードは発生しません。"
  },
  {
    "id": 1016,
    "question": "ダークモードをCSSで検出する方法は？",
    "options": [
      "A. JavaScriptのみ",
      "B. @media (prefers-color-scheme: dark) メディアクエリを使用",
      "C. HTMLの属性",
      "D. サーバーサイド検出"
    ],
    "correct": 1,
    "explanation": "prefers-color-schemeメディアクエリでOSのダークモード設定を検出し、CSSでダーク/ライトテーマのスタイルを切り替えられます。"
  },
  {
    "id": 1017,
    "question": "CSSの「clamp()」関数の用途は？",
    "options": [
      "A. アニメーション",
      "B. clamp(最小値, 推奨値, 最大値) でレスポンシブなフォントサイズ等を範囲制限付きで指定",
      "C. 色の指定",
      "D. レイアウト"
    ],
    "correct": 1,
    "explanation": "clamp(1rem, 2.5vw, 2rem) のように最小/最大値の範囲内で推奨値を使い、画面サイズに応じた流動的なサイズ指定ができます。"
  },
  {
    "id": 1018,
    "question": "Next.jsの<Image>コンポーネントの利点は？",
    "options": [
      "A. 通常の<img>と同じ",
      "B. 自動画像最適化（WebP変換、遅延読込み、サイズ最適化）でパフォーマンス向上",
      "C. CSSの適用",
      "D. SVG専用"
    ],
    "correct": 1,
    "explanation": "Next.jsのImageは画像を自動でWebP等に変換、リサイズ、遅延読込みし、CLS防止のためサイズ予約も行いパフォーマンスを最適化します。"
  },
  {
    "id": 1019,
    "question": "CSSの「:is()」疑似クラスの用途は？",
    "options": [
      "A. アニメーション",
      "B. 複数セレクタをグループ化して記述を簡潔にする（:is(h1, h2, h3) { ... }）",
      "C. 変数定義",
      "D. メディアクエリ"
    ],
    "correct": 1,
    "explanation": ":is(h1, h2, h3) .title は h1 .title, h2 .title, h3 .title と同等で、冗長なセレクタの繰り返しを削減します。"
  },
  {
    "id": 1020,
    "question": "HTMLの<picture>要素の用途は？",
    "options": [
      "A. 画像の装飾",
      "B. 画面サイズや解像度に応じて異なる画像ソースを提供するレスポンシブ画像",
      "C. 動画の埋め込み",
      "D. 音声の再生"
    ],
    "correct": 1,
    "explanation": "<picture>は<source>要素で条件（media, type等）に応じた画像を指定し、最適な画像をブラウザが選択して表示するレスポンシブ画像要素です。"
  },
  {
    "id": 1021,
    "question": "Next.jsのdynamic importの用途は？",
    "options": [
      "A. 静的インポート",
      "B. コンポーネントを動的にインポートしてサーバーサイドでの実行を回避（ssr: false等）",
      "C. CSSのインポート",
      "D. 画像のインポート"
    ],
    "correct": 1,
    "explanation": "next/dynamicはコンポーネントの動的インポートを簡素化し、{ ssr: false }でクライアント専用レンダリング、loadingでフォールバックUIを指定できます。"
  },
  {
    "id": 1022,
    "question": "バックエンドのBFF（Backend For Frontend）パターンとは？",
    "options": [
      "A. モノリシックAPI",
      "B. フロントエンドの要件に合わせた専用バックエンドAPIを中間に配置",
      "C. データベース直接接続",
      "D. CDN"
    ],
    "correct": 1,
    "explanation": "BFFはWeb/モバイル等のクライアントごとに最適化されたAPIサーバーを配置し、複数マイクロサービスのデータを集約・変換するパターンです。"
  },
  {
    "id": 1023,
    "question": "Reactの「Suspense」コンポーネントの役割は？",
    "options": [
      "A. エラー処理",
      "B. 子コンポーネントの読込み中にフォールバックUIを表示する宣言的なローディング",
      "C. スタイリング",
      "D. ルーティング"
    ],
    "correct": 1,
    "explanation": "Suspenseはfallback属性にローディングUIを指定し、React.lazyやデータフェッチで読込み中にスピナー等を表示する宣言的な仕組みです。"
  },
  {
    "id": 1024,
    "question": "Reactの「Error Boundary」の役割は？",
    "options": [
      "A. CSSエラーの処理",
      "B. 子コンポーネントのレンダリングエラーをキャッチしフォールバックUIを表示",
      "C. ネットワークエラー処理",
      "D. 非同期エラー処理"
    ],
    "correct": 1,
    "explanation": "Error Boundaryはクラスコンポーネントで実装し、componentDidCatchで子ツリーのエラーをキャッチしてアプリ全体のクラッシュを防ぎます。"
  },
  {
    "id": 1025,
    "question": "CSSモジュール（CSS Modules）の利点は？",
    "options": [
      "A. グローバルスコープ",
      "B. クラス名が自動でユニーク化されコンポーネント単位のスコープで名前衝突を防止",
      "C. インラインスタイル",
      "D. Less/Sass必須"
    ],
    "correct": 1,
    "explanation": "CSSモジュールは.module.cssでインポートすると、クラス名がハッシュ付きでユニーク化され、他コンポーネントとのクラス名衝突を防ぎます。"
  },
  {
    "id": 1026,
    "question": "Tailwind CSSの特徴は？",
    "options": [
      "A. コンポーネントライブラリ",
      "B. ユーティリティファーストのCSSフレームワークで、HTMLにクラスを直接記述してスタイリング",
      "C. CSS-in-JS",
      "D. CSSプリプロセッサ"
    ],
    "correct": 1,
    "explanation": "Tailwind CSSはflex, p-4, text-lg等のユーティリティクラスをHTMLに直接記述してスタイリングし、カスタムCSS記述を最小限にします。"
  },
  {
    "id": 1027,
    "question": "REST APIの「べき等性（Idempotent）」なHTTPメソッドは？",
    "options": [
      "A. POSTのみ",
      "B. GET、PUT、DELETE（同じリクエストを何回送っても結果が同じ）",
      "C. GETのみ",
      "D. 全メソッド"
    ],
    "correct": 1,
    "explanation": "べき等なメソッドは複数回呼んでも同じ結果：GET（取得）、PUT（完全置換）、DELETE（削除）。POSTは毎回新しいリソースを作る可能性がありべき等ではない。"
  },
  {
    "id": 1028,
    "question": "APIのレート制限（Rate Limiting）の目的は？",
    "options": [
      "A. APIの速度向上",
      "B. 一定時間内のリクエスト数を制限してサーバー過負荷やDDoSを防止",
      "C. 認証の強化",
      "D. データの暗号化"
    ],
    "correct": 1,
    "explanation": "レート制限は429 Too Many Requestsを返してAPIの過負荷を防ぎ、X-RateLimit-Remaining等のヘッダで残りリクエスト数を通知します。"
  },
  {
    "id": 1029,
    "question": "APIのページネーションの一般的な方式は？",
    "options": [
      "A. 全データ返却のみ",
      "B. オフセットベース（page/limit）とカーソルベース（next_cursor）",
      "C. ランダム順のみ",
      "D. ソートのみ"
    ],
    "correct": 1,
    "explanation": "オフセット方式は?page=2&limit=20のように簡易。カーソル方式は?cursor=xxx&limit=20で大量データに効率的で、リアルタイムデータに適しています。"
  },
  {
    "id": 1030,
    "question": "Next.jsの「use server」ディレクティブの用途は？",
    "options": [
      "A. クライアントサイド実行",
      "B. Server Actionsを定義し、フォーム送信等のサーバーサイド処理をコンポーネントから直接呼出し",
      "C. CSSの適用",
      "D. ルーティング"
    ],
    "correct": 1,
    "explanation": "\"use server\"はサーバーでのみ実行される関数を定義し、フォームのaction属性等からAPI Route不要で直接サーバー処理を呼び出せるServer Actions機能です。"
  },
  {
    "id": 1031,
    "question": "RSSフィードの正式名称と主な用途は？",
    "options": [
      "A. Really Simple Syndication、Webサイトの更新情報を配信するXMLフォーマット",
      "B. Remote Server System、サーバー間通信プロトコル",
      "C. Rapid Search Service、検索エンジンの技術",
      "D. Responsive Style Sheet、レスポンシブデザインのCSS"
    ],
    "correct": 0,
    "explanation": "RSSはReally Simple Syndicationの略で、ブログやニュースサイトの更新情報をXML形式で配信する規格です。RSSリーダーで複数サイトを一元管理できます。"
  },
  {
    "id": 1032,
    "question": "XMLの特徴として正しいのは？",
    "options": [
      "A. プログラミング言語の一種",
      "B. マークアップ言語で、独自タグを定義可能、データ構造を階層的に表現可能",
      "C. HTMLと完全に同じ仕様",
      "D. バイナリ形式のデータフォーマット"
    ],
    "correct": 1,
    "explanation": "XML（Extensible Markup Language）は拡張可能なマークアップ言語で、独自タグを定義してデータを階層構造で表現できます。RSS、SOAP、SVGなど様々な用途で使われます。"
  }
]
