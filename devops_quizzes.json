[
  {
    "id": 701,
    "question": "「CI/CD」のCI（継続的インテグレーション）の目的として正しいものはどれか？",
    "options": [
      "A. 手動でテストを実施しリリース前に品質を検証する仕組み",
      "B. コード変更を頻繁に統合し自動テストで品質を継続的に検証",
      "C. 本番環境に直接コードをデプロイする自動化の仕組みのこと",
      "D. コードレビューを自動化して人的チェックを省略する仕組み"
    ],
    "correct": 1,
    "explanation": "CIは開発者のコード変更を頻繁にメインブランチに統合し、自動ビルド・テストで品質を継続的に検証する手法です。"
  },
  {
    "id": 702,
    "question": "Gitの「rebase」と「merge」の違いとして正しいものはどれか？",
    "options": [
      "A. rebaseはマージコミットを作成しmergeは履歴を直線化する",
      "B. rebaseは履歴を直線化しmergeはマージコミットを作成する",
      "C. rebaseとmergeは完全に同じ動作で名前が異なるだけのもの",
      "D. rebaseはリモートでのみ使用しmergeはローカル限定の操作"
    ],
    "correct": 1,
    "explanation": "rebaseはブランチの変更を別ブランチの先端に付け替えて履歴を直線化します。mergeはマージコミットを作成して履歴を合流させます。"
  },
  {
    "id": 703,
    "question": "GitHubの「Pull Request」の目的として正しいものはどれか？",
    "options": [
      "A. リモートリポジトリからローカルにコードを取得する操作のこと",
      "B. コード変更のレビューと議論を経てブランチを統合する機能",
      "C. リポジトリのフォークを削除してクリーンアップする機能のこと",
      "D. ローカルのコミット履歴をリモートに強制的に上書きする機能"
    ],
    "correct": 1,
    "explanation": "Pull Requestはブランチの変更を本流に統合する前に、コードレビュー・議論・CIチェックを行う仕組みです。"
  },
  {
    "id": 704,
    "question": "「Git Flow」でfeatureブランチの派生元として正しいものはどれか？",
    "options": [
      "A. mainブランチから派生してmainにマージされるフロー",
      "B. developブランチから派生してdevelopにマージされるフロー",
      "C. releaseブランチから派生してreleaseにマージされるフロー",
      "D. hotfixブランチから派生してhotfixにマージされるフロー流れ"
    ],
    "correct": 1,
    "explanation": "Git Flowではfeatureブランチはdevelopから派生し、機能完成後にdevelopにマージされます。mainには直接派生しません。"
  },
  {
    "id": 705,
    "question": "「Docker Compose」の主な用途として正しいものはどれか？",
    "options": [
      "A. 単一コンテナのDockerイメージをビルドするためのツール処理",
      "B. 複数コンテナの定義と管理をYAMLファイルで一括管理する",
      "C. Dockerイメージをレジストリに公開するためのツールのこと",
      "D. Dockerコンテナのネットワーク監視に特化したツールのこと"
    ],
    "correct": 1,
    "explanation": "Docker Composeはdocker-compose.ymlで複数コンテナの構成を定義し、docker compose upで一括起動・管理するツールです。"
  },
  {
    "id": 706,
    "question": "「Terraform」のIaCツールとしての特徴はどれか？",
    "options": [
      "A. 手続き型でインフラの設定手順をスクリプトとして記述する",
      "B. 宣言型でインフラの望ましい状態をコードとして定義する形式",
      "C. GUIベースでインフラの構成をドラッグ＆ドロップで設定する",
      "D. コンテナのオーケストレーションに特化したツールのことを指す"
    ],
    "correct": 1,
    "explanation": "TerraformはHCL（HashiCorp Configuration Language）で望ましいインフラ状態を宣言的に定義し、差分を自動適用するIaCツールです。"
  },
  {
    "id": 707,
    "question": "「Ansible」の特徴として正しいものはどれか？",
    "options": [
      "A. 管理対象サーバーに専用エージェントのインストールが必要",
      "B. エージェントレスでSSHを使って構成管理を行う自動化ツール",
      "C. コンテナの構築とデプロイに特化した構成管理ツールのこと",
      "D. JSONファイルで設定を記述するインフラ管理ツールのこと指す"
    ],
    "correct": 1,
    "explanation": "AnsibleはSSH接続でエージェントレスに構成管理を行います。PlaybookはYAML形式で記述し、冪等性のある自動化を実現します。"
  },
  {
    "id": 708,
    "question": "「Prometheus」の用途として正しいものはどれか？",
    "options": [
      "A. ログの収集と検索に特化した分析プラットフォームのこと指す",
      "B. メトリクスの収集・保存・クエリを行う監視システムのこと",
      "C. APMとして分散トレーシングを行う監視ツールのことを指す仕組",
      "D. インシデント管理とアラートのエスカレーションを行うツール"
    ],
    "correct": 1,
    "explanation": "Prometheusは時系列データベースでメトリクス（CPU使用率、リクエスト数等）を収集・保存し、PromQLでクエリ・アラート設定を行います。"
  },
  {
    "id": 709,
    "question": "「Grafana」の主な機能として正しいものはどれか？",
    "options": [
      "A. メトリクスの収集とアラート発火に特化したツールのこと指す",
      "B. 多様なデータソースからダッシュボードを作成する可視化ツール",
      "C. コンテナのオーケストレーションを行うプラットフォームの機能",
      "D. CI/CDパイプラインの構築と管理を行う自動化ツールのこと"
    ],
    "correct": 1,
    "explanation": "GrafanaはPrometheus、Elasticsearch等の多様なデータソースに接続し、ダッシュボードでメトリクスやログを可視化するツールです。"
  },
  {
    "id": 710,
    "question": "Gitの「cherry-pick」コマンドの機能として正しいものはどれか？",
    "options": [
      "A. ブランチの全コミットを別ブランチに統合するコマンドのこと",
      "B. 特定のコミットだけを選んで現在のブランチに適用するコマンド",
      "C. 直前のコミットを取り消して作業ツリーに戻すコマンドのこと",
      "D. リモートブランチの一覧を表示して選択するコマンドのこと指す"
    ],
    "correct": 1,
    "explanation": "cherry-pickは指定したコミットの変更だけを現在のブランチに新しいコミットとして適用します。特定の修正を他ブランチに反映したい時に使います。"
  },
  {
    "id": 711,
    "question": "「GitHub Actions」のワークフロー定義ファイルの配置場所はどれか？",
    "options": [
      "A. リポジトリのルートディレクトリに.github.ymlとして配置する",
      "B. .github/workflows/ディレクトリにYAMLファイルとして配置",
      "C. .ci/ディレクトリにJSONファイルとして配置するルールがある",
      "D. package.jsonのscriptsセクションに定義するルールがある形式"
    ],
    "correct": 1,
    "explanation": "GitHub Actionsのワークフローは.github/workflows/ディレクトリにYAMLファイル（.yml）として配置します。"
  },
  {
    "id": 712,
    "question": "「ブルーグリーンデプロイメント」の説明として正しいものはどれか？",
    "options": [
      "A. 一部のユーザーにのみ新バージョンを配信する方式のこと指す",
      "B. 本番環境を2系統用意し切り替えてダウンタイムを最小化する",
      "C. 段階的に新バージョンのインスタンスを増やす方式のこと指す",
      "D. 全サーバーを同時に新バージョンに更新する方式のことを指す"
    ],
    "correct": 1,
    "explanation": "ブルーグリーンデプロイメントは本番環境を2系統（Blue/Green）用意し、新版をGreenに配備後トラフィックを切り替えることでダウンタイムを最小化します。"
  },
  {
    "id": 713,
    "question": "「カナリアリリース」の説明として正しいものはどれか？",
    "options": [
      "A. 全ユーザーに対して一斉に新バージョンをリリースする方式",
      "B. 少数のユーザーに先行配信し問題がなければ段階的に拡大する",
      "C. テスト環境でのみ新バージョンを検証しリリースしない方式",
      "D. ロールバック不可能な方式でリリースの確実性を重視する方式"
    ],
    "correct": 1,
    "explanation": "カナリアリリースは新バージョンを少数のユーザー（カナリア群）に先行配信し、問題がなければ段階的に全体に展開する方式です。"
  },
  {
    "id": 714,
    "question": "「インフラストラクチャ・アズ・コード（IaC）」のメリットはどれか？",
    "options": [
      "A. インフラ設定の手動変更が容易になる点がメリットとなる",
      "B. 構成をバージョン管理でき再現性と一貫性が向上する点がメリット",
      "C. GUIベースの操作で直感的にインフラを管理できるメリット",
      "D. インフラのコスト削減のみが目的でありメリットはそれだけ処理"
    ],
    "correct": 1,
    "explanation": "IaCはインフラ構成をコードで管理し、バージョン管理、コードレビュー、自動テスト、再現性、一貫性の向上を実現します。"
  },
  {
    "id": 715,
    "question": "Gitの「stash」コマンドの用途として正しいものはどれか？",
    "options": [
      "A. コミットを削除してリポジトリの履歴をクリーンにする操作",
      "B. 作業中の変更を一時退避しクリーンな状態でブランチ切替可能",
      "C. リモートリポジトリの変更をローカルにフェッチする操作の事",
      "D. ブランチの名前を変更してリモートに反映する操作のこと指す"
    ],
    "correct": 1,
    "explanation": "git stashは未コミットの変更を一時的に退避し、作業ツリーをクリーンにします。後でgit stash popで復元できます。"
  },
  {
    "id": 716,
    "question": "「SonarQube」の主な機能として正しいものはどれか？",
    "options": [
      "A. コンテナイメージのセキュリティスキャンを行うツールのこと",
      "B. コード品質とセキュリティの静的解析を継続的に行うツール",
      "C. CI/CDパイプラインの実行環境を提供するプラットフォームの",
      "D. アプリケーションのパフォーマンステストを行うツールのこと"
    ],
    "correct": 1,
    "explanation": "SonarQubeはソースコードの静的解析ツールで、バグ、脆弱性、コードスメル、カバレッジ等を継続的に分析・レポートします。"
  },
  {
    "id": 717,
    "question": "「Helm」の役割として正しいものはどれか？",
    "options": [
      "A. Dockerイメージをビルドしてレジストリにプッシュするツール",
      "B. Kubernetesアプリケーションのパッケージ管理を行うツール",
      "C. サーバーのSSH接続を管理するターミナルツールのことを指す",
      "D. GitリポジトリのブランチをGUIで管理するツールのことを指す"
    ],
    "correct": 1,
    "explanation": "HelmはKubernetesのパッケージマネージャで、Chart（テンプレート群）を使ってアプリケーションの定義・インストール・管理を行います。"
  },
  {
    "id": 718,
    "question": "「GitOps」の原則として正しいものはどれか？",
    "options": [
      "A. 手動でサーバーにログインしてインフラを変更する運用方式",
      "B. Gitリポジトリを単一の信頼源としてインフラ変更を管理する",
      "C. CI/CDを使わず手動デプロイで確実性を重視する運用方式運用",
      "D. 本番環境の設定をバックアップせず常に新規構築する方式方法"
    ],
    "correct": 1,
    "explanation": "GitOpsはGitリポジトリを信頼の唯一の源とし、宣言的な設定の変更をGit経由で管理・自動適用する運用手法です。"
  },
  {
    "id": 719,
    "question": "「Rolling Update」デプロイメント戦略の特徴はどれか？",
    "options": [
      "A. すべてのインスタンスを同時に新バージョンに置き換える方式",
      "B. インスタンスを段階的に新バージョンに置き換える方式で展開",
      "C. 新旧環境を並行稼働し一括でトラフィックを切り替える方式",
      "D. テスト環境でのみ新バージョンを検証し本番には適用しない方式"
    ],
    "correct": 1,
    "explanation": "Rolling Updateは古いインスタンスを1つずつ新バージョンに置き換え、常にサービスを稼働させたままデプロイを行う戦略です。"
  },
  {
    "id": 720,
    "question": "Gitの「git bisect」の用途として正しいものはどれか？",
    "options": [
      "A. ブランチを2つに分割して別々に開発を進めるコマンドのこと",
      "B. 二分探索でバグが混入したコミットを特定するコマンドのこと",
      "C. 2つのブランチの差分をマージするコマンドのことを指す操作",
      "D. リポジトリのサイズを半分に圧縮するコマンドのことを指す操作"
    ],
    "correct": 1,
    "explanation": "git bisectは正常なコミットと不具合のあるコミットの間を二分探索し、バグが混入したコミットを効率的に特定するコマンドです。"
  },
  {
    "id": 721,
    "question": "「Jenkinsfile」の用途として正しいものはどれか？",
    "options": [
      "A. Jenkinsのインストール手順を記述する設定ファイルのこと指す",
      "B. CI/CDパイプラインをコードとして定義するファイルのこと指す",
      "C. Jenkinsのユーザー認証設定を管理するファイルのことを指す",
      "D. Jenkinsのプラグイン一覧を記述するファイルのことを指す管理"
    ],
    "correct": 1,
    "explanation": "JenkinsfileはJenkinsのパイプラインをコードとして定義するファイルで、SCMと一緒に管理できます。宣言型とスクリプト型があります。"
  },
  {
    "id": 722,
    "question": "「ArgoCD」の特徴として正しいものはどれか？",
    "options": [
      "A. CI/CDパイプラインのビルド・テスト実行に特化したツール",
      "B. KubernetesのGitOps型CDツールで望ましい状態を自動適用",
      "C. Dockerイメージの脆弱性スキャンに特化したツールのこと指す",
      "D. サーバーレス関数のデプロイに特化したツールのことを指す機能"
    ],
    "correct": 1,
    "explanation": "ArgoCDはKubernetes向けのGitOps型CDツールで、Gitリポジトリの定義とクラスタの状態を同期し、自動的に望ましい状態を適用します。"
  },
  {
    "id": 723,
    "question": "「Feature Flag（フィーチャーフラグ）」の目的として正しいものはどれか？",
    "options": [
      "A. コードのコンパイルオプションを切り替えるための仕組み指す",
      "B. デプロイ済みコードの機能のオンオフを実行時に切り替える",
      "C. Git上のブランチを自動的にマージするための仕組みのこと指す",
      "D. テストケースの実行順序を制御するための仕組みのことを指す"
    ],
    "correct": 1,
    "explanation": "フィーチャーフラグは設定値（フラグ）で機能の有効/無効を実行時に切り替える手法です。段階的リリースやA/Bテストに利用されます。"
  },
  {
    "id": 724,
    "question": "Gitの「.gitignore」ファイルの目的として正しいものはどれか？",
    "options": [
      "A. Gitリポジトリの設定（ユーザー名等）を管理するファイル",
      "B. Gitの追跡対象から除外するファイルやディレクトリを指定する",
      "C. Gitフックの実行順序を定義するファイルのことを指す設定管理",
      "D. リモートリポジトリのURLを管理するファイルのことを指す設定"
    ],
    "correct": 1,
    "explanation": ".gitignoreはGitの追跡対象から除外するファイルパターンを指定します。ビルド成果物や環境設定ファイル等を除外するために使います。"
  },
  {
    "id": 725,
    "question": "「Makefile」のDevOpsでの用途として正しいものはどれか？",
    "options": [
      "A. C/C++のコンパイルにのみ使用可能な専用ツールのこと指す処理",
      "B. ビルドやデプロイ等の定型タスクをターゲットとして定義する",
      "C. Dockerfileの代替としてコンテナをビルドする仕組みのこと指す",
      "D. テストの実行結果をHTMLレポートに変換するツールのこと指す"
    ],
    "correct": 1,
    "explanation": "MakefileはDevOpsでビルド、テスト、デプロイ等の定型タスクをmakeコマンドのターゲットとして定義し、チーム共通のタスクランナーとして使用します。"
  },
  {
    "id": 726,
    "question": "「Fluentd」の主な役割として正しいものはどれか？",
    "options": [
      "A. アプリケーションのメトリクスを収集する監視ツールのこと指す",
      "B. 統一的なログ収集・転送・変換を行うデータコレクターの役割",
      "C. コンテナのオーケストレーションを行うツールのことを指す機能",
      "D. ダッシュボードの作成と可視化に特化したツールのことを指す"
    ],
    "correct": 1,
    "explanation": "Fluentdは多様なソースからログを収集し、フィルタ・変換後に複数の宛先（Elasticsearch等）に転送する統一ログ基盤です。"
  },
  {
    "id": 727,
    "question": "「Vault（HashiCorp Vault）」の主な機能として正しいものはどれか？",
    "options": [
      "A. コンテナのネットワーク設定を管理するツールのことを指す機能",
      "B. シークレット（APIキーやパスワード等）を安全に管理するツール",
      "C. CI/CDパイプラインのスケジューリングを管理するツールの機能",
      "D. インフラの構成をコードとして定義するIaCツールのことを指す"
    ],
    "correct": 1,
    "explanation": "Vaultはシークレット管理ツールで、APIキー、パスワード、証明書等の機密情報を暗号化して安全に保管・アクセス制御します。"
  },
  {
    "id": 728,
    "question": "「Terraform state」ファイルの役割として正しいものはどれか？",
    "options": [
      "A. Terraformの設定ファイル（.tf）のバックアップを保存する役割",
      "B. 管理中のインフラの現在の状態を記録し差分管理に使用する",
      "C. Terraformのプラグインとプロバイダの一覧を管理する役割目的",
      "D. Terraformのログとエラー情報を記録するファイルのことを指す"
    ],
    "correct": 1,
    "explanation": "terraform.tfstateは管理中のリソースの現在の状態を記録するファイルで、plan時にコードとの差分を検出するために使用されます。"
  },
  {
    "id": 729,
    "question": "「Semantic Versioning（セマンティックバージョニング）」の形式はどれか？",
    "options": [
      "A. YEAR.MONTH.DAYの形式で日付ベースにバージョンを管理する",
      "B. MAJOR.MINOR.PATCHの形式で互換性に基づき番号を付与する",
      "C. BUILD.RELEASE.HOTFIXの形式でリリース種別で管理する方式",
      "D. ALPHA.BETA.STABLEの形式で安定度に基づき管理する方式法"
    ],
    "correct": 1,
    "explanation": "セマンティックバージョニングはMAJOR（後方互換性なし）.MINOR（後方互換あり）.PATCH（バグ修正）の形式でバージョンを管理します。"
  },
  {
    "id": 730,
    "question": "「Chaos Engineering」の目的として正しいものはどれか？",
    "options": [
      "A. 開発中のコードに意図的にバグを混入してテストする手法目的",
      "B. 本番環境に意図的に障害を注入しシステムの耐障害性を検証",
      "C. セキュリティ脆弱性を意図的に作成して侵入テストを行う目的",
      "D. コードの品質を意図的に下げてリファクタリングの効果を測定"
    ],
    "correct": 1,
    "explanation": "Chaos Engineeringは本番に近い環境で意図的に障害を注入し、システムが予期しない状況でも正常に動作するか検証する手法です。"
  }
]
