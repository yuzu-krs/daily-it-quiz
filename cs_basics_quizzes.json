[
  {
    "id": 431,
    "question": "10進数の「13」を2進数に変換すると正しいのはどれか？",
    "options": ["A. 1101", "B. 1011", "C. 1110", "D. 1010"],
    "correct": 0,
    "explanation": "13 = 8+4+1 = 1101(2進数)です。1011は11、1110は14、1010は10に相当します。"
  },
  {
    "id": 432,
    "question": "16進数の「0x1F」を10進数に変換するといくつになるか？",
    "options": ["A. 32", "B. 31", "C. 30", "D. 33"],
    "correct": 1,
    "explanation": "0x1F = 1×16 + 15 = 31です。Fは10進数で15を表します。"
  },
  {
    "id": 433,
    "question": "論理演算「1 AND 0」の結果として正しいものはどれか？",
    "options": ["A. 1", "B. 0", "C. -1", "D. 未定義"],
    "correct": 1,
    "explanation": "AND演算は両方が1のときのみ1を返します。片方が0なので結果は0です。"
  },
  {
    "id": 434,
    "question": "論理演算「1 XOR 1」の結果として正しいものはどれか？",
    "options": ["A. 1", "B. 0", "C. 2", "D. -1"],
    "correct": 1,
    "explanation": "XOR（排他的論理和）は両方が同じ値のとき0を返します。異なるときに1を返します。"
  },
  {
    "id": 435,
    "question": "8ビットの2の補数表現で表せる符号付き整数の範囲はどれか？",
    "options": ["A. -127〜127", "B. -128〜127", "C. -128〜128", "D. -256〜255"],
    "correct": 1,
    "explanation": "8ビットの2の補数表現では-128〜127の範囲を表現できます。最上位ビットが符号ビットとなります。"
  },
  {
    "id": 436,
    "question": "CPUが命令を実行する基本サイクルの正しい順序はどれか？",
    "options": [
      "A. フェッチ→デコード→実行→ライトバック",
      "B. デコード→フェッチ→実行→ライトバック",
      "C. フェッチ→実行→デコード→ライトバック",
      "D. デコード→実行→フェッチ→ライトバック"
    ],
    "correct": 0,
    "explanation": "CPUの命令サイクルは、命令フェッチ→命令デコード→実行→結果の書き戻し（ライトバック）の順です。"
  },
  {
    "id": 437,
    "question": "CPUのレジスタに関する説明として正しいものはどれか？",
    "options": [
      "A. 主記憶装置より容量が大きく速度も速い",
      "B. 主記憶装置より容量が小さいが速度は速い",
      "C. 主記憶装置と同等の容量で速度も同じである",
      "D. 主記憶装置より容量が小さく速度も遅い"
    ],
    "correct": 1,
    "explanation": "レジスタはCPU内部の超高速な記憶領域で、容量は非常に小さいですがアクセス速度は最速です。"
  },
  {
    "id": 438,
    "question": "仮想メモリのページフォールトが発生する状況として正しいものはどれか？",
    "options": [
      "A. アクセスしたいページが物理メモリ上にない場合",
      "B. アクセスしたいページが物理メモリ上にある場合",
      "C. CPUのキャッシュがすべて使用されている場合",
      "D. アクセスしたいページのサイズが大きすぎる場合"
    ],
    "correct": 0,
    "explanation": "ページフォールトは、参照したページが物理メモリ上に存在せず、ディスクから読み込む必要があるときに発生します。"
  },
  {
    "id": 439,
    "question": "L1キャッシュとL2キャッシュの関係として正しいものはどれか？",
    "options": [
      "A. L1はL2より大容量で低速である",
      "B. L1はL2より小容量で高速である",
      "C. L1はL2より大容量で高速である",
      "D. L1はL2より小容量で低速である"
    ],
    "correct": 1,
    "explanation": "L1キャッシュはCPUコアに最も近く、L2より容量は小さいですがアクセス速度は高速です。"
  },
  {
    "id": 440,
    "question": "RISC（Reduced Instruction Set Computer）の特徴として正しいものはどれか？",
    "options": [
      "A. 命令数が多く1命令の実行に複数クロックを要する",
      "B. 命令数が少なく1命令を1クロックで実行できる",
      "C. 命令長が可変でマイクロプログラムを多用する",
      "D. 命令数が少なく1命令の実行に複数クロックを要する"
    ],
    "correct": 1,
    "explanation": "RISCは命令セットを単純化し、各命令を原則1クロックサイクルで実行できるよう設計されています。"
  },
  {
    "id": 441,
    "question": "CISCアーキテクチャの代表的なCPUとして正しいものはどれか？",
    "options": [
      "A. ARM Cortex-A",
      "B. MIPS R4000",
      "C. Intel x86",
      "D. RISC-V"
    ],
    "correct": 2,
    "explanation": "Intel x86はCISCの代表例です。ARM、MIPS、RISC-VはいずれもRISCアーキテクチャに分類されます。"
  },
  {
    "id": 442,
    "question": "アセンブリ言語の「MOV AX, 5」が行う処理として正しいものはどれか？",
    "options": [
      "A. メモリの5番地の値をAXレジスタに転送する",
      "B. AXレジスタに即値5を格納する処理を行う",
      "C. AXレジスタの値を5番地のメモリに転送する",
      "D. AXレジスタの値と5を加算して格納する処理"
    ],
    "correct": 1,
    "explanation": "MOV命令は第2オペランドの値を第1オペランドに格納します。この場合、即値5がAXに入ります。"
  },
  {
    "id": 443,
    "question": "スタックのデータ構造の操作原則として正しいものはどれか？",
    "options": [
      "A. 先入れ先出し（FIFO）の原則に従う",
      "B. 後入れ先出し（LIFO）の原則に従う",
      "C. 優先度が高い順に取り出す原則に従う",
      "D. ランダムにアクセスして取り出す原則に従う"
    ],
    "correct": 1,
    "explanation": "スタックはLIFO（Last-In, First-Out）の原則に従い、最後に追加した要素が最初に取り出されます。"
  },
  {
    "id": 444,
    "question": "ハッシュテーブルの平均的な検索時間計算量として正しいものはどれか？",
    "options": ["A. O(n)", "B. O(log n)", "C. O(1)", "D. O(n log n)"],
    "correct": 2,
    "explanation": "ハッシュテーブルは平均O(1)で検索できます。ただし最悪の場合は衝突によりO(n)になります。"
  },
  {
    "id": 445,
    "question": "二分探索を適用するための前提条件として正しいものはどれか？",
    "options": [
      "A. データが連結リストに格納されていること",
      "B. データがあらかじめソートされていること",
      "C. データの件数が2の累乗であること必要",
      "D. データにハッシュ値が付与されていること"
    ],
    "correct": 1,
    "explanation": "二分探索はソート済みのデータに対して適用できるアルゴリズムで、計算量はO(log n)です。"
  },
  {
    "id": 446,
    "question": "計算量O(n²)のソートアルゴリズムとして正しいものはどれか？",
    "options": [
      "A. マージソート",
      "B. クイックソート",
      "C. バブルソート",
      "D. ヒープソート"
    ],
    "correct": 2,
    "explanation": "バブルソートは平均・最悪ともにO(n²)です。マージソート・ヒープソートはO(n log n)、クイックソートは平均O(n log n)です。"
  },
  {
    "id": 447,
    "question": "ビット演算「0b1010 << 2」の結果として正しいものはどれか？",
    "options": ["A. 0b101000", "B. 0b001010", "C. 0b101010", "D. 0b010100"],
    "correct": 0,
    "explanation": "左シフト演算<<は指定ビット数分だけ左にシフトし、右側に0を埋めます。1010を2つ左に移すと101000です。"
  },
  {
    "id": 448,
    "question": "ビット演算「0b1100 & 0b1010」の結果として正しいものはどれか？",
    "options": ["A. 0b1110", "B. 0b1000", "C. 0b0110", "D. 0b1010"],
    "correct": 1,
    "explanation": "ビットAND演算は各ビットごとにANDを取ります。1&1=1, 1&0=0, 0&1=0, 0&0=0で結果は1000です。"
  },
  {
    "id": 449,
    "question": "連結リストと配列の比較で正しい説明はどれか？",
    "options": [
      "A. 連結リストは先頭への挿入がO(n)である",
      "B. 配列はランダムアクセスがO(n)で行える",
      "C. 連結リストは先頭への挿入がO(1)である",
      "D. 配列は末尾への挿入が常にO(1)で行える"
    ],
    "correct": 2,
    "explanation": "連結リストは先頭への挿入がO(1)で行えます。配列のランダムアクセスはO(1)ですが、挿入は要素移動が必要です。"
  },
  {
    "id": 450,
    "question": "二分木（Binary Tree）において、ノード数nの完全二分木の高さはどれか？",
    "options": ["A. O(n)", "B. O(log n)", "C. O(n log n)", "D. O(√n)"],
    "correct": 1,
    "explanation": "完全二分木の高さはO(log n)です。各レベルでノード数が倍になるため、高さは対数的に増加します。"
  },
  {
    "id": 451,
    "question": "パイプライン処理の「ハザード」として正しくないものはどれか？",
    "options": [
      "A. 構造ハザード（リソース競合による停止）",
      "B. データハザード（依存関係による停止）",
      "C. 制御ハザード（分岐命令による停止）",
      "D. 論理ハザード（演算結果の誤りによる停止）"
    ],
    "correct": 3,
    "explanation": "パイプラインハザードには構造・データ・制御の3種類があります。論理ハザードはパイプラインの分類には含まれません。"
  },
  {
    "id": 452,
    "question": "メモリ管理で「ガベージコレクション」の説明として正しいものはどれか？",
    "options": [
      "A. 使用中のメモリを圧縮して断片化を防ぐ機構",
      "B. 不要になったメモリ領域を自動的に解放する機構",
      "C. メモリの読み書き速度を向上させるための機構",
      "D. メモリアクセスの排他制御を行うための機構処理"
    ],
    "correct": 1,
    "explanation": "ガベージコレクションは、プログラムが使用しなくなったメモリ領域を自動的に検出・解放する仕組みです。"
  },
  {
    "id": 453,
    "question": "10進数の「255」を16進数で表すと正しいものはどれか？",
    "options": ["A. 0xFE", "B. 0xFF", "C. 0xEF", "D. 0xF0"],
    "correct": 1,
    "explanation": "255 = 15×16 + 15 = 0xFF です。0xFEは254、0xEFは239、0xF0は240に対応します。"
  },
  {
    "id": 454,
    "question": "キャッシュの「ライトバック方式」の説明として正しいものはどれか？",
    "options": [
      "A. 書き込み時にキャッシュと主記憶を同時に更新する",
      "B. 書き込み時はキャッシュのみ更新し追い出し時に主記憶に反映",
      "C. 読み出し時にキャッシュと主記憶の内容を比較して更新する",
      "D. 書き込み時にキャッシュを経由せず直接主記憶に書き込む"
    ],
    "correct": 1,
    "explanation": "ライトバック方式はキャッシュのみを更新し、キャッシュラインが追い出される時に主記憶へ書き戻します。"
  },
  {
    "id": 455,
    "question": "再帰関数でフィボナッチ数列を素朴に実装した場合の計算量はどれか？",
    "options": ["A. O(n)", "B. O(n²)", "C. O(2^n)", "D. O(log n)"],
    "correct": 2,
    "explanation": "素朴な再帰によるフィボナッチ計算は指数時間O(2^n)です。メモ化で O(n)に改善できます。"
  },
  {
    "id": 456,
    "question": "「ド・モルガンの法則」として正しい式はどれか？",
    "options": [
      "A. NOT(A AND B) = (NOT A) OR (NOT B)",
      "B. NOT(A AND B) = (NOT A) AND (NOT B)",
      "C. NOT(A OR B) = (NOT A) OR (NOT B)である",
      "D. NOT(A AND B) = A OR B が成り立つもの"
    ],
    "correct": 0,
    "explanation": "ド・モルガンの法則：NOT(A AND B) = (NOT A) OR (NOT B)、NOT(A OR B) = (NOT A) AND (NOT B)です。"
  },
  {
    "id": 457,
    "question": "ヒープデータ構造における最小値の取得の計算量はどれか？",
    "options": ["A. O(n)", "B. O(log n)", "C. O(1)", "D. O(n log n)"],
    "correct": 2,
    "explanation": "最小ヒープでは最小値はルートに位置するため、O(1)で取得できます。削除にはO(log n)かかります。"
  },
  {
    "id": 458,
    "question": "CPUのパイプライン処理で「分岐予測」が必要な理由はどれか？",
    "options": [
      "A. メモリアクセスの遅延を隠蔽するためである",
      "B. 条件分岐で後続命令が確定しないことへの対処",
      "C. 複数コア間でのデータ整合性を保つためである",
      "D. 命令デコードのエラーを検出するためである処理"
    ],
    "correct": 1,
    "explanation": "条件分岐では分岐先が確定するまで次の命令を取得できず、パイプラインが停止します。分岐予測で投機的に実行します。"
  },
  {
    "id": 459,
    "question": "安定ソートアルゴリズムの説明として正しいものはどれか？",
    "options": [
      "A. 入力サイズに関わらず実行時間が一定である",
      "B. 同じキー値を持つ要素の順序が保持されるもの",
      "C. 追加のメモリ領域を一切使用しないものである",
      "D. 常に最悪計算量がO(n log n)であるものこと"
    ],
    "correct": 1,
    "explanation": "安定ソートは同じキー値を持つ要素の相対的な順序がソート後も維持されるアルゴリズムです。"
  },
  {
    "id": 460,
    "question": "2進数の浮動小数点表現（IEEE 754）で発生する問題はどれか？",
    "options": [
      "A. 整数の加算で桁あふれが起こることがある問題",
      "B. 0.1+0.2が正確に0.3にならない丸め誤差の問題",
      "C. 負の数を表現できないという制約上の問題である",
      "D. 小数と整数を同時に扱えないという制約の問題"
    ],
    "correct": 1,
    "explanation": "IEEE 754の2進浮動小数点では0.1や0.2を正確に表現できず、0.1+0.2≠0.3となる丸め誤差が発生します。"
  }
]
