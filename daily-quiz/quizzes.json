[
  {
    "id": 1,
    "question": "Pythonで使用されるインタプリタは何ですか？",
    "options": ["A. CPython", "B. JVM", "C. CLR", "D. V8"],
    "correct": 0,
    "explanation": "CPythonはPythonの標準的な実装で、C言語で書かれたインタプリタです。"
  },
  {
    "id": 2,
    "question": "HTTPステータスコード404は何を意味しますか？",
    "options": [
      "A. サーバーエラー",
      "B. リソースが見つからない",
      "C. リクエストが成功",
      "D. リダイレクト"
    ],
    "correct": 1,
    "explanation": "404 Not Foundは、リクエストされたリソースがサーバー上に見つからないことを示します。"
  },
  {
    "id": 3,
    "question": "SQLで\"SELECT * FROM users WHERE age > 20\"の意味は？",
    "options": [
      "A. 20歳以下のユーザーを取得",
      "B. 20歳のユーザーを削除",
      "C. 20歳より上のユーザーを取得",
      "D. 全ユーザーを削除"
    ],
    "correct": 2,
    "explanation": "WHERE age > 20は、年齢が20より大きい（20歳より上の）レコードを選択します。"
  },
  {
    "id": 4,
    "question": "Gitでリモートリポジトリからコードをダウンロードするコマンドは？",
    "options": ["A. git push", "B. git pull", "C. git commit", "D. git branch"],
    "correct": 1,
    "explanation": "git pullはリモートリポジトリから最新の変更をダウンロードしてマージします。"
  },
  {
    "id": 5,
    "question": "CSSで要素を中央揃えにするプロパティはどれ？",
    "options": [
      "A. align-center",
      "B. center-align",
      "C. text-align: center",
      "D. position: center"
    ],
    "correct": 2,
    "explanation": "text-align: centerはテキストや画像などのインライン要素を中央揃えにします。"
  },
  {
    "id": 6,
    "question": "OSI参照モデルの第4層は何ですか？",
    "options": [
      "A. データリンク層",
      "B. ネットワーク層",
      "C. トランスポート層",
      "D. セッション層"
    ],
    "correct": 2,
    "explanation": "第4層はトランスポート層で、TCP/UDPなどのプロトコルが動作します。"
  },
  {
    "id": 7,
    "question": "JSONの正式名称は？",
    "options": [
      "A. Java Simple Object Notation",
      "B. JavaScript Object Notation",
      "C. Java Structured Object Network",
      "D. JavaScript Object Network"
    ],
    "correct": 1,
    "explanation": "JSONはJavaScript Object Notationの略で、軽量なデータ交換フォーマットです。"
  },
  {
    "id": 8,
    "question": "データベースの正規化の主な目的は？",
    "options": [
      "A. データの冗長性を減らす",
      "B. データベースを大きくする",
      "C. クエリを遅くする",
      "D. テーブルを削除する"
    ],
    "correct": 0,
    "explanation": "正規化はデータの冗長性を減らし、データ整合性を向上させることが主な目的です。"
  },
  {
    "id": 9,
    "question": "どのプロトコルが安全な通信を提供しますか？",
    "options": ["A. HTTP", "B. FTP", "C. HTTPS", "D. SMTP"],
    "correct": 2,
    "explanation": "HTTPSはSSL/TLSを使用して暗号化された安全な通信を提供します。"
  },
  {
    "id": 10,
    "question": "プログラミングにおける\"デバッグ\"とは？",
    "options": [
      "A. コードを書くこと",
      "B. バグを見つけて修正すること",
      "C. コードをコンパイルすること",
      "D. コードを削除すること"
    ],
    "correct": 1,
    "explanation": "デバッグはプログラム内のバグ（エラー）を見つけて修正する作業です。"
  },
  {
    "id": 11,
    "question": "IPv4アドレスは何ビットで構成されていますか？",
    "options": ["A. 16ビット", "B. 32ビット", "C. 64ビット", "D. 128ビット"],
    "correct": 1,
    "explanation": "IPv4アドレスは32ビット（4オクテット）で構成されています。"
  },
  {
    "id": 12,
    "question": "RESTful APIで使用される主なHTTPメソッドでないものは？",
    "options": ["A. GET", "B. POST", "C. FIND", "D. DELETE"],
    "correct": 2,
    "explanation": "主なHTTPメソッドはGET、POST、PUT、DELETE、PATCHなどです。FINDは標準メソッドではありません。"
  },
  {
    "id": 13,
    "question": "Dockerの主な用途は？",
    "options": [
      "A. データベース管理",
      "B. コンテナ仮想化",
      "C. テキスト編集",
      "D. 画像編集"
    ],
    "correct": 1,
    "explanation": "Dockerはアプリケーションをコンテナとしてパッケージ化し、実行するためのプラットフォームです。"
  },
  {
    "id": 14,
    "question": "クロスサイトスクリプティング（XSS）は何の種類の攻撃ですか？",
    "options": [
      "A. 物理的攻撃",
      "B. ネットワーク攻撃",
      "C. Webアプリケーション攻撃",
      "D. OS攻撃"
    ],
    "correct": 2,
    "explanation": "XSSはWebアプリケーションに悪意のあるスクリプトを注入する攻撃です。"
  },
  {
    "id": 15,
    "question": "JavaScriptで非同期処理を扱う方法でないものは？",
    "options": ["A. Promise", "B. async/await", "C. callback", "D. loop"],
    "correct": 3,
    "explanation": "Promise、async/await、callbackは非同期処理のパターンです。loopは非同期専用ではありません。"
  },
  {
    "id": 16,
    "question": "LinuxでファイルのパーミッションをREADとWRITEのみにするには？",
    "options": ["A. chmod 777", "B. chmod 600", "C. chmod 000", "D. chmod 111"],
    "correct": 1,
    "explanation": "chmod 600は所有者に読み取りと書き込み権限のみを付与します（6=4+2）。"
  },
  {
    "id": 17,
    "question": "CIとCDの\"CD\"は何の略ですか？",
    "options": [
      "A. Compact Disc",
      "B. Continuous Delivery",
      "C. Central Database",
      "D. Code Download"
    ],
    "correct": 1,
    "explanation": "CDはContinuous Delivery（継続的デリバリー）の略で、ソフトウェアを継続的にリリースする手法です。"
  },
  {
    "id": 18,
    "question": "SQLインジェクションを防ぐ最も効果的な方法は？",
    "options": [
      "A. ファイアウォールを使う",
      "B. プリペアドステートメントを使う",
      "C. パスワードを強化する",
      "D. HTTPSを使う"
    ],
    "correct": 1,
    "explanation": "プリペアドステートメントは、SQLクエリとデータを分離し、SQLインジェクションを防ぎます。"
  },
  {
    "id": 19,
    "question": "オブジェクト指向プログラミングの4大原則に含まれないものは？",
    "options": ["A. カプセル化", "B. 継承", "C. 多態性", "D. 暗号化"],
    "correct": 3,
    "explanation": "OOPの4大原則は、カプセル化、継承、多態性、抽象化です。暗号化は含まれません。"
  },
  {
    "id": 20,
    "question": "ビッグO記法でO(1)が意味するのは？",
    "options": ["A. 線形時間", "B. 定数時間", "C. 対数時間", "D. 二次時間"],
    "correct": 1,
    "explanation": "O(1)は定数時間を意味し、入力サイズに関わらず実行時間が一定です。"
  },
  {
    "id": 21,
    "question": "CSSのFlexboxで主軸に沿って要素を配置するプロパティは？",
    "options": [
      "A. align-items",
      "B. justify-content",
      "C. flex-direction",
      "D. flex-wrap"
    ],
    "correct": 1,
    "explanation": "justify-contentは主軸（メイン軸）に沿って要素を配置します。"
  },
  {
    "id": 22,
    "question": "APIのGETメソッドは何に使用されますか？",
    "options": [
      "A. データの取得",
      "B. データの削除",
      "C. データの更新",
      "D. データの作成"
    ],
    "correct": 0,
    "explanation": "GETメソッドはサーバーからデータを取得するために使用されます。"
  },
  {
    "id": 23,
    "question": "DDoS攻撃の\"D\"は何の略ですか？",
    "options": ["A. Direct", "B. Distributed", "C. Dynamic", "D. Digital"],
    "correct": 1,
    "explanation": "DDoSはDistributed Denial of Service（分散型サービス拒否）攻撃の略です。"
  },
  {
    "id": 24,
    "question": "NoSQLデータベースの特徴でないものは？",
    "options": [
      "A. スキーマレス",
      "B. 水平スケーラビリティ",
      "C. 厳密なACID保証",
      "D. 柔軟なデータモデル"
    ],
    "correct": 2,
    "explanation": "NoSQLはACID保証よりもBASE原則を採用することが多く、厳密なACIDはRDBMSの特徴です。"
  },
  {
    "id": 25,
    "question": "MVC アーキテクチャの\"V\"は何を表しますか？",
    "options": ["A. Variable", "B. View", "C. Version", "D. Virtual"],
    "correct": 1,
    "explanation": "MVCはModel-View-Controllerの略で、Vはユーザーインターフェース（View）を表します。"
  },
  {
    "id": 26,
    "question": "TCP/IPモデルで、HTTPが動作する層は？",
    "options": [
      "A. ネットワークインターフェース層",
      "B. インターネット層",
      "C. トランスポート層",
      "D. アプリケーション層"
    ],
    "correct": 3,
    "explanation": "HTTPはアプリケーション層のプロトコルです。"
  },
  {
    "id": 27,
    "question": "Pythonでリストの末尾に要素を追加するメソッドは？",
    "options": ["A. add()", "B. append()", "C. insert()", "D. push()"],
    "correct": 1,
    "explanation": "append()メソッドはリストの末尾に要素を追加します。"
  },
  {
    "id": 28,
    "question": "JavaScriptの\"this\"キーワードは何を参照しますか？",
    "options": [
      "A. グローバルオブジェクト",
      "B. コンテキストに依存するオブジェクト",
      "C. 常にwindowオブジェクト",
      "D. 常にnull"
    ],
    "correct": 1,
    "explanation": "\"this\"は実行コンテキストに応じて、呼び出し元のオブジェクトなどを参照します。"
  },
  {
    "id": 29,
    "question": "Agile開発手法の特徴でないものは？",
    "options": [
      "A. 反復的開発",
      "B. 顧客との協調",
      "C. 変更への適応",
      "D. 詳細な初期計画の固定"
    ],
    "correct": 3,
    "explanation": "Agileは変化を受け入れ、詳細な初期計画よりも適応性を重視します。"
  },
  {
    "id": 30,
    "question": "データベースのインデックスの主な目的は？",
    "options": [
      "A. データを削除する",
      "B. 検索速度を向上させる",
      "C. データを暗号化する",
      "D. データをバックアップする"
    ],
    "correct": 1,
    "explanation": "インデックスは特定のカラムに対する検索やソートの速度を向上させます。"
  },

  {
    "id": 31,
    "question": "10進数の「13」を2進数に変換すると？",
    "options": ["A. 1011", "B. 1101", "C. 1110", "D. 1010"],
    "correct": 1,
    "explanation": "13 = 8+4+1 = 1101(2)。8の位、4の位が1、2の位が0、1の位が1です。"
  },
  {
    "id": 32,
    "question": "2進数「11001010」を16進数に変換すると？",
    "options": ["A. CA", "B. AC", "C. CB", "D. BC"],
    "correct": 0,
    "explanation": "4ビットずつ区切り、1100=C、1010=A なのでCAです。"
  },
  {
    "id": 33,
    "question": "16進数「FF」を10進数に変換すると？",
    "options": ["A. 250", "B. 255", "C. 256", "D. 260"],
    "correct": 1,
    "explanation": "F=15なので、15×16+15=255です。"
  },
  {
    "id": 34,
    "question": "8ビットで表現できる符号なし整数の最大値は？",
    "options": ["A. 128", "B. 255", "C. 256", "D. 512"],
    "correct": 1,
    "explanation": "8ビットでは0～255（2^8-1）まで表現できます。"
  },
  {
    "id": 35,
    "question": "2進数の「1111」を10進数に変換すると？",
    "options": ["A. 14", "B. 15", "C. 16", "D. 17"],
    "correct": 1,
    "explanation": "1111(2) = 8+4+2+1 = 15です。"
  },
  {
    "id": 36,
    "question": "2の補数表現で-1を8ビットで表すと？",
    "options": ["A. 10000001", "B. 11111111", "C. 11111110", "D. 10000000"],
    "correct": 1,
    "explanation": "2の補数では-1は全ビットが1（11111111）になります。"
  },
  {
    "id": 37,
    "question": "16進数「A3」を2進数に変換すると？",
    "options": ["A. 10100011", "B. 10110011", "C. 10100010", "D. 11000011"],
    "correct": 0,
    "explanation": "A=1010、3=0011なので、10100011です。"
  },
  {
    "id": 38,
    "question": "2進数の加算 1011 + 0110 の結果は？",
    "options": ["A. 10000", "B. 10001", "C. 10010", "D. 10011"],
    "correct": 1,
    "explanation": "1011(11) + 0110(6) = 10001(17)です。"
  },
  {
    "id": 39,
    "question": "浮動小数点数のIEEE 754規格で、単精度は何ビット？",
    "options": ["A. 16ビット", "B. 32ビット", "C. 64ビット", "D. 128ビット"],
    "correct": 1,
    "explanation": "IEEE 754の単精度浮動小数点数は32ビット（符号1、指数8、仮数23）です。"
  },
  {
    "id": 40,
    "question": "1キロバイト（KB）は何バイト？（IEC基準）",
    "options": [
      "A. 1000バイト",
      "B. 1024バイト",
      "C. 512バイト",
      "D. 2048バイト"
    ],
    "correct": 1,
    "explanation": "IEC基準では1KiB=1024バイトです。なお、SI基準では1KB=1000バイトとなります。"
  },
  {
    "id": 41,
    "question": "BCDコード（Binary Coded Decimal）で「25」を表すと？",
    "options": ["A. 00100101", "B. 00011001", "C. 00110101", "D. 00101010"],
    "correct": 0,
    "explanation": "BCDでは各10進数桁を4ビットで表現。2=0010、5=0101で00100101です。"
  },
  {
    "id": 42,
    "question": "2進数で「0.5」はどう表されるか？",
    "options": ["A. 0.01", "B. 0.1", "C. 0.11", "D. 0.001"],
    "correct": 1,
    "explanation": "0.5 = 1/2 = 0.1(2) です。2の-1乗が0.5に相当します。"
  },
  {
    "id": 43,
    "question": "16進数の「1F」と「2A」の和は？",
    "options": ["A. 49(16)", "B. 39(16)", "C. 4A(16)", "D. 3F(16)"],
    "correct": 0,
    "explanation": "1F(31) + 2A(42) = 73 = 49(16)です。"
  },
  {
    "id": 44,
    "question": "符号付き8ビット整数で表現できる最小値は？",
    "options": ["A. -127", "B. -128", "C. -255", "D. -256"],
    "correct": 1,
    "explanation": "2の補数表現の8ビットでは-128（10000000）が最小値です。"
  },
  {
    "id": 45,
    "question": "論理演算 AND（1, 0）の結果は？",
    "options": ["A. 0", "B. 1", "C. -1", "D. 2"],
    "correct": 0,
    "explanation": "AND演算は両方が1の場合のみ1を返します。1 AND 0 = 0です。"
  },
  {
    "id": 46,
    "question": "論理演算 OR（0, 1）の結果は？",
    "options": ["A. 0", "B. 1", "C. -1", "D. 未定義"],
    "correct": 1,
    "explanation": "OR演算はどちらか一方でも1なら1を返します。0 OR 1 = 1です。"
  },
  {
    "id": 47,
    "question": "論理演算 XOR（1, 1）の結果は？",
    "options": ["A. 0", "B. 1", "C. 2", "D. -1"],
    "correct": 0,
    "explanation": "XOR（排他的論理和）は値が異なるとき1、同じとき0を返します。1 XOR 1 = 0です。"
  },
  {
    "id": 48,
    "question": "NOT演算は何と呼ばれますか？",
    "options": ["A. 論理積", "B. 論理和", "C. 否定", "D. 排他的論理和"],
    "correct": 2,
    "explanation": "NOT演算は否定（ネゲーション）と呼ばれ、0を1に、1を0に反転します。"
  },
  {
    "id": 49,
    "question": "NAND演算の特徴として正しいものは？",
    "options": [
      "A. AND演算と同じ",
      "B. AND演算の否定",
      "C. OR演算の否定",
      "D. XOR演算の否定"
    ],
    "correct": 1,
    "explanation": "NANDはNOT ANDの略で、AND演算の結果を反転したものです。"
  },
  {
    "id": 50,
    "question": "ド・モルガンの定理で NOT(A AND B) は何に等しい？",
    "options": [
      "A. NOT A AND NOT B",
      "B. NOT A OR NOT B",
      "C. A OR B",
      "D. A AND B"
    ],
    "correct": 1,
    "explanation": "ド・モルガンの定理：NOT(A AND B) = NOT A OR NOT B です。"
  },
  {
    "id": 51,
    "question": "真理値表で2入力の場合、行数は何行？",
    "options": ["A. 2行", "B. 4行", "C. 8行", "D. 16行"],
    "correct": 1,
    "explanation": "入力がn個の場合、2^n行になります。2入力なら2^2=4行です。"
  },
  {
    "id": 52,
    "question": "ユニバーサルゲートと呼ばれるのは？",
    "options": ["A. ANDとOR", "B. NANDとNOR", "C. XORとXNOR", "D. NOTのみ"],
    "correct": 1,
    "explanation": "NANDとNORは任意の論理回路を構成できるため、ユニバーサルゲートと呼ばれます。"
  },
  {
    "id": 53,
    "question": "A XOR B XOR A の結果は？",
    "options": ["A. A", "B. B", "C. 0", "D. 1"],
    "correct": 1,
    "explanation": "XORは同じ値で打ち消し合うため、A XOR A = 0、0 XOR B = B となります。"
  },
  {
    "id": 54,
    "question": "半加算器（Half Adder）の出力は？",
    "options": ["A. 和のみ", "B. 和と桁上げ", "C. 桁上げのみ", "D. 差と借り"],
    "correct": 1,
    "explanation": "半加算器は2つの1ビット入力から和（Sum）と桁上げ（Carry）を出力します。"
  },
  {
    "id": 55,
    "question": "ビットの左シフト演算（<<1）は何倍になる？",
    "options": ["A. 1倍", "B. 2倍", "C. 4倍", "D. 8倍"],
    "correct": 1,
    "explanation": "左に1ビットシフトすると値が2倍になります。例：0011(3)→0110(6)。"
  },
  {
    "id": 56,
    "question": "ビットの右シフト演算（>>2）は何分の1になる？",
    "options": ["A. 1/2", "B. 1/4", "C. 1/8", "D. 1/16"],
    "correct": 1,
    "explanation": "右に2ビットシフトすると、2^2=4で割ることに相当します。"
  },
  {
    "id": 57,
    "question": "ビットマスクの主な用途は？",
    "options": [
      "A. データの暗号化",
      "B. 特定のビットの抽出・操作",
      "C. データの圧縮",
      "D. エラー検出"
    ],
    "correct": 1,
    "explanation": "ビットマスクはAND/OR演算と組み合わせて、特定のビットを抽出・設定・クリアします。"
  },
  {
    "id": 58,
    "question": "0xFF AND 0x0F の結果は？",
    "options": ["A. 0xFF", "B. 0x0F", "C. 0xF0", "D. 0x00"],
    "correct": 1,
    "explanation": "11111111 AND 00001111 = 00001111 = 0x0F。下位4ビットのみ残ります。"
  },
  {
    "id": 59,
    "question": "ビット演算でフラグをONにするにはどの演算を使う？",
    "options": ["A. AND", "B. OR", "C. XOR", "D. NOT"],
    "correct": 1,
    "explanation": "OR演算でフラグのビット位置を1にすると、他のビットを変更せずにフラグをONにできます。"
  },
  {
    "id": 60,
    "question": "ビット演算でフラグをOFFにするにはどの操作をする？",
    "options": ["A. OR", "B. XOR", "C. ANDとNOT", "D. 左シフト"],
    "correct": 2,
    "explanation": "フラグのビットをNOTで反転してからANDを取ると、そのビットだけ0にできます。"
  },
  {
    "id": 61,
    "question": "ビット演算でフラグの切り替え（トグル）にはどの演算を使う？",
    "options": ["A. AND", "B. OR", "C. XOR", "D. NOT"],
    "correct": 2,
    "explanation": "XOR演算は、対象ビットが0なら1に、1なら0に切り替えます。"
  },
  {
    "id": 62,
    "question": "算術右シフトと論理右シフトの違いは？",
    "options": [
      "A. 違いはない",
      "B. 符号ビットの扱い",
      "C. シフト速度",
      "D. シフト量の制限"
    ],
    "correct": 1,
    "explanation": "算術右シフトは符号ビットを保持し、論理右シフトは0で埋めます。"
  },
  {
    "id": 63,
    "question": "CPUの基本動作サイクルの正しい順序は？",
    "options": [
      "A. 実行→命令取得→解読",
      "B. 命令取得→解読→実行",
      "C. 解読→命令取得→実行",
      "D. 実行→解読→命令取得"
    ],
    "correct": 1,
    "explanation": "CPUはフェッチ（命令取得）→デコード（解読）→エクスキュート（実行）の順で動作します。"
  },
  {
    "id": 64,
    "question": "CPUのクロック周波数3GHzとは、1秒間に何回のクロックが発生する？",
    "options": ["A. 3千万回", "B. 3億回", "C. 30億回", "D. 300億回"],
    "correct": 2,
    "explanation": "G（ギガ）= 10^9 なので、3GHz = 30億回/秒です。"
  },
  {
    "id": 65,
    "question": "CPUのレジスタとは何ですか？",
    "options": [
      "A. 外部記憶装置",
      "B. CPU内部の高速小容量メモリ",
      "C. メインメモリの一種",
      "D. キャッシュメモリ"
    ],
    "correct": 1,
    "explanation": "レジスタはCPU内部にある最も高速だが容量が小さい記憶装置です。"
  },
  {
    "id": 66,
    "question": "プログラムカウンタ (PC) の役割は？",
    "options": [
      "A. 演算結果を保持",
      "B. 次に実行する命令のアドレスを保持",
      "C. メモリの空き容量を管理",
      "D. I/Oデバイスを制御"
    ],
    "correct": 1,
    "explanation": "プログラムカウンタは次に実行すべき命令のメモリアドレスを指し示します。"
  },
  {
    "id": 67,
    "question": "ALU (Arithmetic Logic Unit) の役割は？",
    "options": [
      "A. メモリ管理",
      "B. 算術演算と論理演算の実行",
      "C. 命令のデコード",
      "D. バスの制御"
    ],
    "correct": 1,
    "explanation": "ALUはCPU内で加減算や論理演算を実際に行う回路です。"
  },
  {
    "id": 68,
    "question": "パイプライン処理の利点は？",
    "options": [
      "A. 1命令の実行時間が短くなる",
      "B. 命令の並列処理でスループットが向上",
      "C. 消費電力が減る",
      "D. メモリ使用量が減る"
    ],
    "correct": 1,
    "explanation": "パイプラインは複数の命令をステージごとに並行実行し、単位時間の命令処理数を向上させます。"
  },
  {
    "id": 69,
    "question": "パイプラインハザードとは何ですか？",
    "options": [
      "A. パイプラインの高速化",
      "B. パイプラインが正常に動作しなくなる状況",
      "C. パイプラインの段数を増やすこと",
      "D. パイプラインの電力管理"
    ],
    "correct": 1,
    "explanation": "ハザードはデータ依存や分岐などでパイプラインが停滞する問題のことです。"
  },
  {
    "id": 70,
    "question": "スーパースカラとは何ですか？",
    "options": [
      "A. 一度に複数の命令を並列実行する方式",
      "B. クロック周波数を上げる技術",
      "C. メモリの高速化手法",
      "D. パイプラインの段数を減らす技術"
    ],
    "correct": 0,
    "explanation": "スーパースカラは複数の実行ユニットを持ち、1クロックで複数命令を実行する方式です。"
  },
  {
    "id": 71,
    "question": "分岐予測（Branch Prediction）の目的は？",
    "options": [
      "A. メモリの使用量削減",
      "B. パイプラインの効率を維持する",
      "C. クロック周波数を上げる",
      "D. レジスタの数を増やす"
    ],
    "correct": 1,
    "explanation": "分岐予測は条件分岐の結果を予測し、パイプラインの停滞を減らします。"
  },
  {
    "id": 72,
    "question": "割り込み (Interrupt) の主な目的は？",
    "options": [
      "A. CPUを停止させる",
      "B. 外部イベントに対し迅速に対応する",
      "C. メモリをクリアする",
      "D. プログラムを削除する"
    ],
    "correct": 1,
    "explanation": "割り込みにより、CPUは現在の処理を中断して緊急のイベント処理に移行できます。"
  },
  {
    "id": 73,
    "question": "CPUのコア数が2のプロセッサを何と呼ぶ？",
    "options": [
      "A. シングルコア",
      "B. デュアルコア",
      "C. クアッドコア",
      "D. オクタコア"
    ],
    "correct": 1,
    "explanation": "2つのCPUコアを持つプロセッサをデュアルコアと呼びます。"
  },
  {
    "id": 74,
    "question": "マルチスレッドの利点として正しいものは？",
    "options": [
      "A. 常にプログラムの実行速度が倍になる",
      "B. CPUコアの利用効率を向上させる",
      "C. メモリ使用量が半減する",
      "D. バグが減る"
    ],
    "correct": 1,
    "explanation": "マルチスレッドによりCPUの空き時間を活用でき、コアの利用効率が向上します。"
  },
  {
    "id": 75,
    "question": "仮想メモリ (Virtual Memory) の主な目的は？",
    "options": [
      "A. CPUの速度を上げる",
      "B. 物理メモリ以上のメモリ空間を利用可能にする",
      "C. ハードディスクを高速化する",
      "D. ネットワーク速度を向上させる"
    ],
    "correct": 1,
    "explanation": "仮想メモリはディスクを利用して、物理メモリ以上のアドレス空間を提供します。"
  },
  {
    "id": 76,
    "question": "ページングとは何ですか？",
    "options": [
      "A. メモリを固定サイズのブロック（ページ）に分割する方式",
      "B. ディスクにデータを書き込む方式",
      "C. CPUの命令を並べ替える方式",
      "D. ネットワークパケットを分割する方式"
    ],
    "correct": 0,
    "explanation": "ページングはメモリを固定サイズのページに分割し、仮想アドレスを物理アドレスにマッピングします。"
  },
  {
    "id": 77,
    "question": "ページフォールトとは何ですか？",
    "options": [
      "A. メモリが故障した状態",
      "B. 参照したページが物理メモリにない状態",
      "C. CPUがエラーを起こした状態",
      "D. ディスクが満杯の状態"
    ],
    "correct": 1,
    "explanation": "ページフォールトは仮想メモリのページが物理メモリに存在せず、ディスクから読み込む必要がある状態です。"
  },
  {
    "id": 78,
    "question": "メモリのスワッピングとは？",
    "options": [
      "A. メモリの速度を上げること",
      "B. メモリ上のプロセスをディスクに退避すること",
      "C. メモリのエラーを修正すること",
      "D. メモリの容量を増やすこと"
    ],
    "correct": 1,
    "explanation": "スワッピングはメモリ不足時にプロセスのデータをディスクに退避し、メモリを確保する仕組みです。"
  },
  {
    "id": 79,
    "question": "メモリリーク（Memory Leak）とは？",
    "options": [
      "A. メモリが物理的に壊れること",
      "B. 確保したメモリが解放されず使用不能になること",
      "C. メモリの読み書き速度が低下すること",
      "D. メモリが外部に漏えいすること"
    ],
    "correct": 1,
    "explanation": "メモリリークはプログラムが確保したメモリを解放しないまま参照を失うことで、利用可能なメモリが減少する問題です。"
  },
  {
    "id": 80,
    "question": "ガベージコレクション (GC) の役割は？",
    "options": [
      "A. ファイルの削除",
      "B. 不要になったメモリの自動解放",
      "C. ディスクの最適化",
      "D. CPUのクロック制御"
    ],
    "correct": 1,
    "explanation": "GCは使用されなくなったメモリ領域を自動的に検出し、解放する仕組みです。"
  },
  {
    "id": 81,
    "question": "スタック領域の特徴として正しいものは？",
    "options": [
      "A. FIFOで管理される",
      "B. LIFOで管理される",
      "C. ランダムアクセスのみ",
      "D. サイズが動的に拡大する"
    ],
    "correct": 1,
    "explanation": "スタックはLIFO（Last In First Out）方式で管理され、関数呼び出しの管理に使われます。"
  },
  {
    "id": 82,
    "question": "ヒープ領域の特徴として正しいものは？",
    "options": [
      "A. 自動的にメモリが解放される",
      "B. プログラマが動的にメモリを確保・解放する",
      "C. CPU内部に存在する",
      "D. 常に連続領域"
    ],
    "correct": 1,
    "explanation": "ヒープはプログラムが動的にメモリを割り当て（mallocなど）、必要に応じて解放する領域です。"
  },
  {
    "id": 83,
    "question": "ECC メモリの「ECC」は何の略？",
    "options": [
      "A. Enhanced Cache Control",
      "B. Error Correcting Code",
      "C. External Clock Controller",
      "D. Extended Capacity Chip"
    ],
    "correct": 1,
    "explanation": "ECCはError Correcting Codeの略で、メモリのビットエラーを検出・訂正する機能です。"
  },
  {
    "id": 84,
    "question": "DRAMとSRAMの違いで正しいものは？",
    "options": [
      "A. DRAMの方が高速",
      "B. SRAMはリフレッシュが不要",
      "C. DRAMの方が高価",
      "D. SRAMはメインメモリに使われる"
    ],
    "correct": 1,
    "explanation": "SRAMはフリップフロップ回路を使いリフレッシュ不要で高速ですが、DRAMより高価で容量が小さいです。"
  },
  {
    "id": 85,
    "question": "キャッシュメモリの目的は？",
    "options": [
      "A. ストレージの容量を増やす",
      "B. CPUとメインメモリの速度差を埋める",
      "C. ネットワーク通信を高速化する",
      "D. バッテリ寿命を延ばす"
    ],
    "correct": 1,
    "explanation": "キャッシュメモリはCPUの高速な処理とメインメモリの低速なアクセスの間を仲介し、速度差を緩和します。"
  },
  {
    "id": 86,
    "question": "L1キャッシュとL2キャッシュの関係で正しいのは？",
    "options": [
      "A. L1の方が大容量",
      "B. L1の方が高速でCPUに近い",
      "C. L2の方が高速",
      "D. L1とL2は同じ速度"
    ],
    "correct": 1,
    "explanation": "L1キャッシュはCPUコアに最も近く、小容量だが最も高速。L2はL1より大容量だがやや低速です。"
  },
  {
    "id": 87,
    "question": "キャッシュヒット率が90%で、キャッシュアクセス10ns、メインメモリアクセス100nsの場合の平均アクセス時間は？",
    "options": ["A. 10ns", "B. 19ns", "C. 55ns", "D. 100ns"],
    "correct": 1,
    "explanation": "平均 = 0.9 × 10 + 0.1 × 100 = 9 + 10 = 19ns です。"
  },
  {
    "id": 88,
    "question": "キャッシュの「ライトバック」方式とは？",
    "options": [
      "A. 書き込み時に常にメインメモリも更新",
      "B. キャッシュのみ更新し、追い出し時にメインメモリへ書き戻す",
      "C. メインメモリのみに書き込む",
      "D. 書き込みを無視する"
    ],
    "correct": 1,
    "explanation": "ライトバック方式はキャッシュにのみ書き込み、キャッシュラインが追い出される時にメモリに書き戻します。"
  },
  {
    "id": 89,
    "question": "キャッシュの「ライトスルー」方式とは？",
    "options": [
      "A. キャッシュのみに書き込む",
      "B. キャッシュとメインメモリに同時に書き込む",
      "C. メインメモリのみに書き込む",
      "D. 書き込みを遅延する"
    ],
    "correct": 1,
    "explanation": "ライトスルー方式はキャッシュとメインメモリの両方に同時に書き込みます。一貫性は保たれますが書き込みが遅くなります。"
  },
  {
    "id": 90,
    "question": "キャッシュの局所性の原理で、「時間的局所性」とは？",
    "options": [
      "A. 近くのデータが参照されやすい",
      "B. 最近使ったデータは再び参照されやすい",
      "C. 古いデータほど使われない",
      "D. キャッシュの更新頻度のこと"
    ],
    "correct": 1,
    "explanation": "時間的局所性は、最近アクセスされたデータが近い将来再びアクセスされやすいという性質です。"
  },
  {
    "id": 91,
    "question": "キャッシュの局所性の原理で、「空間的局所性」とは？",
    "options": [
      "A. キャッシュの物理的な配置",
      "B. アクセスしたデータの近くのデータも参照されやすい",
      "C. 同じCPUコアでの局所性",
      "D. L1とL2の距離"
    ],
    "correct": 1,
    "explanation": "空間的局所性は、アクセスされたアドレスの近くのアドレスも近い将来アクセスされやすいという性質です。"
  },
  {
    "id": 92,
    "question": "LRU (Least Recently Used) キャッシュ置換方式とは？",
    "options": [
      "A. 最も古いデータを置き換える",
      "B. 最近最も使われていないデータを置き換える",
      "C. ランダムに置き換える",
      "D. 最も大きいデータを置き換える"
    ],
    "correct": 1,
    "explanation": "LRUは最後に参照されてから最も長い時間が経過したキャッシュラインを置換します。"
  },
  {
    "id": 93,
    "question": "RISC アーキテクチャの特徴は？",
    "options": [
      "A. 命令数が多く複雑",
      "B. 命令数が少なく単純で固定長",
      "C. 可変長命令",
      "D. マイクロコードを多用"
    ],
    "correct": 1,
    "explanation": "RISC（Reduced Instruction Set Computer）は命令セットを少数に絞り、固定長で単純な命令を高速に実行します。"
  },
  {
    "id": 94,
    "question": "CISC アーキテクチャの特徴は？",
    "options": [
      "A. 命令が少なく固定長",
      "B. 命令数が多く可変長で複雑な処理を1命令で実行",
      "C. レジスタ数が多い",
      "D. パイプラインが使えない"
    ],
    "correct": 1,
    "explanation": "CISC（Complex Instruction Set Computer）は多数の複雑な命令を持ち、1命令で複雑な処理が可能です。"
  },
  {
    "id": 95,
    "question": "ARM プロセッサはどちらのアーキテクチャに分類される？",
    "options": ["A. CISC", "B. RISC", "C. MISC", "D. VLIW"],
    "correct": 1,
    "explanation": "ARMはRISCアーキテクチャを採用しており、低消費電力で高効率なのが特徴です。"
  },
  {
    "id": 96,
    "question": "x86 プロセッサはどちらのアーキテクチャに分類される？",
    "options": ["A. RISC", "B. CISC", "C. MISC", "D. EPIC"],
    "correct": 1,
    "explanation": "x86はIntelが開発したCISCアーキテクチャです（内部的にRISC的な変換を行うことも）。"
  },
  {
    "id": 97,
    "question": "RISC-Vとは何ですか？",
    "options": [
      "A. RISCの第5世代プロセッサ",
      "B. オープンソースのRISC命令セットアーキテクチャ",
      "C. CISCの新バージョン",
      "D. ARMの互換アーキテクチャ"
    ],
    "correct": 1,
    "explanation": "RISC-Vはオープンソースの命令セットアーキテクチャで、誰でも無料で使用・実装できます。"
  },
  {
    "id": 98,
    "question": "フォンノイマン型アーキテクチャの特徴は？",
    "options": [
      "A. プログラムとデータを別のメモリに格納",
      "B. プログラムとデータを同一メモリに格納",
      "C. プログラムをハードウェアに固定",
      "D. データをレジスタのみに格納"
    ],
    "correct": 1,
    "explanation": "フォンノイマン型はプログラム(命令)とデータを同一のメモリに格納し、逐次的に実行します。"
  },
  {
    "id": 99,
    "question": "ハーバードアーキテクチャの特徴は？",
    "options": [
      "A. プログラムとデータが同一メモリ",
      "B. プログラムとデータのメモリが物理的に分離",
      "C. メモリがない構造",
      "D. プログラムをディスクから直接実行"
    ],
    "correct": 1,
    "explanation": "ハーバードアーキテクチャは命令用とデータ用のメモリを分離し、同時アクセスが可能です。"
  },
  {
    "id": 100,
    "question": "アセンブリ言語とは何ですか？",
    "options": [
      "A. 高級言語",
      "B. 機械語を人間が読みやすい記号で表現した低級言語",
      "C. スクリプト言語",
      "D. マークアップ言語"
    ],
    "correct": 1,
    "explanation": "アセンブリ言語は機械語の命令をニーモニック（ADD、MOVなど）で表現した低級プログラミング言語です。"
  },
  {
    "id": 101,
    "question": "アセンブリ言語で「MOV」命令の役割は？",
    "options": [
      "A. データの加算",
      "B. データの移動（コピー）",
      "C. プログラムの終了",
      "D. 条件分岐"
    ],
    "correct": 1,
    "explanation": "MOV命令はソースからデスティネーションへデータをコピーします（実際は移動ではなくコピー）。"
  },
  {
    "id": 102,
    "question": "アセンブリ言語で「JMP」命令の役割は？",
    "options": [
      "A. データの加算",
      "B. 無条件ジャンプ（分岐）",
      "C. スタック操作",
      "D. レジスタのクリア"
    ],
    "correct": 1,
    "explanation": "JMP命令は指定されたアドレスに無条件でジャンプし、プログラムの実行位置を変更します。"
  },
  {
    "id": 103,
    "question": "アセンブラの役割は？",
    "options": [
      "A. C言語を機械語に変換",
      "B. アセンブリ言語を機械語に変換",
      "C. 機械語をアセンブリに変換",
      "D. 高級言語を中間言語に変換"
    ],
    "correct": 1,
    "explanation": "アセンブラはアセンブリ言語のソースコードを機械語（バイナリ）に変換するプログラムです。"
  },
  {
    "id": 104,
    "question": "スタック操作で「PUSH」の意味は？",
    "options": [
      "A. スタックからデータを取り出す",
      "B. スタックにデータを積む",
      "C. スタックを初期化する",
      "D. スタックのサイズを確認する"
    ],
    "correct": 1,
    "explanation": "PUSHはスタックの頂上にデータを積む操作です。対になるPOPで取り出します。"
  },
  {
    "id": 105,
    "question": "配列（Array）の特徴として正しいものは？",
    "options": [
      "A. 挿入が高速",
      "B. インデックスによるランダムアクセスがO(1)",
      "C. サイズが動的に変化しやすい",
      "D. ポインタで要素を繋ぐ"
    ],
    "correct": 1,
    "explanation": "配列はメモリ上に連続して配置され、インデックスで直接アクセスできるためO(1)です。"
  },
  {
    "id": 106,
    "question": "連結リスト（Linked List）の挿入の時間計算量は？",
    "options": ["A. O(1)（先頭の場合）", "B. O(n)", "C. O(log n)", "D. O(n^2)"],
    "correct": 0,
    "explanation": "連結リストの先頭への挿入はO(1)です。途中への挿入は探索にO(n)かかる場合があります。"
  },
  {
    "id": 107,
    "question": "スタックのデータ構造の特徴は？",
    "options": [
      "A. FIFO（First In First Out）",
      "B. LIFO（Last In First Out）",
      "C. ランダムアクセス",
      "D. 優先度順"
    ],
    "correct": 1,
    "explanation": "スタックはLIFO方式で、最後に入れたデータが最初に取り出されます。"
  },
  {
    "id": 108,
    "question": "キュー（Queue）のデータ構造の特徴は？",
    "options": [
      "A. LIFO",
      "B. FIFO",
      "C. ランダムアクセス",
      "D. ハッシュアクセス"
    ],
    "correct": 1,
    "explanation": "キューはFIFO方式で、最初に入れたデータが最初に取り出されます（先入れ先出し）。"
  },
  {
    "id": 109,
    "question": "ハッシュテーブルの平均的な検索時間計算量は？",
    "options": ["A. O(n)", "B. O(log n)", "C. O(1)", "D. O(n^2)"],
    "correct": 2,
    "explanation": "ハッシュテーブルはハッシュ関数で直接位置を計算するため、平均的にO(1)で検索できます。"
  },
  {
    "id": 110,
    "question": "二分探索木で平均的な検索の時間計算量は？",
    "options": ["A. O(1)", "B. O(log n)", "C. O(n)", "D. O(n log n)"],
    "correct": 1,
    "explanation": "バランスの取れた二分探索木では、各ノードで左右を選択するので平均O(log n)です。"
  },
  {
    "id": 111,
    "question": "ヒープ（Heap）データ構造に適した用途は？",
    "options": [
      "A. ランダムアクセス",
      "B. 優先度付きキューの実装",
      "C. 文字列検索",
      "D. グラフの表現"
    ],
    "correct": 1,
    "explanation": "ヒープは最大値/最小値を効率的に取り出せるため、優先度付きキューの実装に最適です。"
  },
  {
    "id": 112,
    "question": "グラフのデータ構造で「隣接リスト」とは？",
    "options": [
      "A. 各頂点が隣接する頂点のリストを持つ",
      "B. 全頂点をソートしたリスト",
      "C. 辺の重みをリストにしたもの",
      "D. 頂点のラベルをリストにしたもの"
    ],
    "correct": 0,
    "explanation": "隣接リストは各頂点に対して、その頂点と直接つながっている頂点のリストを保持する表現方法です。"
  },
  {
    "id": 113,
    "question": "B木（B-Tree）が主に使われる場面は？",
    "options": [
      "A. メモリ内のソート",
      "B. データベースのインデックス",
      "C. 画像処理",
      "D. ネットワーク通信"
    ],
    "correct": 1,
    "explanation": "B木はディスクI/Oを最小化する構造のため、データベースやファイルシステムのインデックスに広く使われます。"
  },
  {
    "id": 114,
    "question": "トライ木（Trie）が適した用途は？",
    "options": [
      "A. 数値のソート",
      "B. 文字列の高速検索・補完",
      "C. グラフ探索",
      "D. 行列演算"
    ],
    "correct": 1,
    "explanation": "トライ木は文字列の各文字をノードとする木構造で、辞書検索や自動補完に最適です。"
  },
  {
    "id": 115,
    "question": "ハッシュの衝突（コリジョン）とは？",
    "options": [
      "A. ハッシュ値が大きすぎること",
      "B. 異なるキーが同じハッシュ値を持つこと",
      "C. ハッシュ関数が遅いこと",
      "D. ハッシュテーブルが満杯になること"
    ],
    "correct": 1,
    "explanation": "衝突は二つ以上の異なるキーが同じハッシュ値（同じ格納位置）にマッピングされることです。"
  },
  {
    "id": 116,
    "question": "双方向連結リスト（Doubly Linked List）の特徴は？",
    "options": [
      "A. 各ノードが次のノードのみを指す",
      "B. 各ノードが前後のノードを指す",
      "C. 循環構造を持つ",
      "D. インデックスでアクセスできる"
    ],
    "correct": 1,
    "explanation": "双方向連結リストは各ノードが前のノードと次のノードへのポインタを持ち、双方向に走査可能です。"
  },
  {
    "id": 117,
    "question": "赤黒木（Red-Black Tree）の特徴は？",
    "options": [
      "A. ソートされていない木",
      "B. 自己平衡二分探索木",
      "C. 非二分木",
      "D. ハッシュベースの木"
    ],
    "correct": 1,
    "explanation": "赤黒木は各ノードに赤か黒の色を付け、挿入・削除時にバランスを保つ自己平衡二分探索木です。"
  },
  {
    "id": 118,
    "question": "バブルソートの最悪時間計算量は？",
    "options": ["A. O(n)", "B. O(n log n)", "C. O(n^2)", "D. O(log n)"],
    "correct": 2,
    "explanation": "バブルソートは隣接要素を比較交換する方式で、最悪の場合O(n^2)の比較が必要です。"
  },
  {
    "id": 119,
    "question": "クイックソートの平均時間計算量は？",
    "options": ["A. O(n)", "B. O(n log n)", "C. O(n^2)", "D. O(log n)"],
    "correct": 1,
    "explanation": "クイックソートはピボットを使って分割統治法で並べ替え、平均O(n log n)で動作します。"
  },
  {
    "id": 120,
    "question": "マージソートの特徴として正しいものは？",
    "options": [
      "A. インプレースソート",
      "B. 安定ソートでO(n log n)",
      "C. 最悪O(n^2)",
      "D. 比較を行わないソート"
    ],
    "correct": 1,
    "explanation": "マージソートは安定ソートで、最悪計算量もO(n log n)が保証されますが、追加メモリが必要です。"
  },
  {
    "id": 121,
    "question": "二分探索の前提条件は？",
    "options": [
      "A. データがランダム",
      "B. データがソート済み",
      "C. データが連結リスト",
      "D. データが木構造"
    ],
    "correct": 1,
    "explanation": "二分探索はソート済みの配列に対してのみ適用でき、中央値と比較して探索範囲を半分にします。"
  },
  {
    "id": 122,
    "question": "深さ優先探索（DFS）で使われるデータ構造は？",
    "options": ["A. キュー", "B. スタック", "C. ヒープ", "D. ハッシュテーブル"],
    "correct": 1,
    "explanation": "DFSは再帰またはスタックを使い、行けるところまで深く探索してからバックトラックします。"
  },
  {
    "id": 123,
    "question": "幅優先探索（BFS）で使われるデータ構造は？",
    "options": ["A. スタック", "B. キュー", "C. ヒープ", "D. 配列"],
    "correct": 1,
    "explanation": "BFSはキューを使い、始点から近い順に全ての隣接ノードを探索します。"
  },
  {
    "id": 124,
    "question": "ダイクストラ法の用途は？",
    "options": [
      "A. ソート",
      "B. 最短経路の探索",
      "C. 文字列検索",
      "D. 行列計算"
    ],
    "correct": 1,
    "explanation": "ダイクストラ法は重み付きグラフで、始点から各頂点への最短経路を求めるアルゴリズムです。"
  },
  {
    "id": 125,
    "question": "動的計画法（DP）の特徴は？",
    "options": [
      "A. ランダムな最適化",
      "B. 部分問題の結果を再利用して効率化",
      "C. 分割統治法と同じ",
      "D. 全探索の方法"
    ],
    "correct": 1,
    "explanation": "DPは重複する部分問題の結果をメモ化（保存）し、再計算を避けることで効率化します。"
  },
  {
    "id": 126,
    "question": "貪欲法（Greedy Algorithm）の特徴は？",
    "options": [
      "A. 全通りを調べる",
      "B. 常に局所的に最適な選択をする",
      "C. ランダムに選択する",
      "D. 逆順に処理する"
    ],
    "correct": 1,
    "explanation": "貪欲法は各ステップで局所的に最適な選択をしますが、常にグローバル最適になるとは限りません。"
  },
  {
    "id": 127,
    "question": "計算量O(log n)のアルゴリズムの代表例は？",
    "options": [
      "A. バブルソート",
      "B. 二分探索",
      "C. 線形探索",
      "D. クイックソート"
    ],
    "correct": 1,
    "explanation": "二分探索は各ステップで探索範囲を半分にするため、O(log n)で動作します。"
  },
  {
    "id": 128,
    "question": "O(n!) の計算量はどのレベル？",
    "options": [
      "A. 非常に高速",
      "B. 線形的",
      "C. 多項式時間",
      "D. 非常に遅い（指数・階乗）"
    ],
    "correct": 3,
    "explanation": "O(n!)は階乗時間で、nが増えると爆発的に計算量が増加し、実用的に不可能になります。"
  },
  {
    "id": 129,
    "question": "以下の計算量を速い順に並べたものは？ O(1), O(n), O(log n), O(n^2)",
    "options": [
      "A. O(1) < O(n) < O(log n) < O(n^2)",
      "B. O(1) < O(log n) < O(n) < O(n^2)",
      "C. O(log n) < O(1) < O(n) < O(n^2)",
      "D. O(n) < O(1) < O(log n) < O(n^2)"
    ],
    "correct": 1,
    "explanation": "速い順に O(1) < O(log n) < O(n) < O(n^2) となります。"
  },
  {
    "id": 130,
    "question": "最悪計算量がO(n^2)のソートアルゴリズムはどれ？",
    "options": [
      "A. マージソート",
      "B. ヒープソート",
      "C. クイックソート",
      "D. 基数ソート"
    ],
    "correct": 2,
    "explanation": "クイックソートは平均O(n log n)ですが、ピボット選択が悪いと最悪O(n^2)になります。"
  },
  {
    "id": 131,
    "question": "NP完全問題の例はどれ？",
    "options": [
      "A. 二分探索",
      "B. 巡回セールスマン問題",
      "C. バブルソート",
      "D. 行列の積"
    ],
    "correct": 1,
    "explanation": "巡回セールスマン問題はNP完全問題の代表で、全都市を最短で巡回する経路を求める問題です。"
  },
  {
    "id": 132,
    "question": "計算量 O(n log n) のソートアルゴリズムでないものは？",
    "options": [
      "A. マージソート",
      "B. ヒープソート",
      "C. 挿入ソート",
      "D. ティムソート"
    ],
    "correct": 2,
    "explanation": "挿入ソートは最悪O(n^2)です。マージソート、ヒープソート、ティムソートはO(n log n)です。"
  },
  {
    "id": 133,
    "question": "空間計算量とは何ですか？",
    "options": [
      "A. 実行にかかる時間",
      "B. アルゴリズムが使用するメモリの量",
      "C. ディスクの使用量",
      "D. ネットワーク帯域の使用量"
    ],
    "correct": 1,
    "explanation": "空間計算量はアルゴリズムの実行に必要なメモリ量を入力サイズの関数として表したものです。"
  },
  {
    "id": 134,
    "question": "償却計算量（Amortized Complexity）とは？",
    "options": [
      "A. 最悪の場合の計算量",
      "B. 一連の操作全体を平均した1回あたりの計算量",
      "C. 最良の場合の計算量",
      "D. メモリの使用量"
    ],
    "correct": 1,
    "explanation": "償却計算量は一連の操作を全体で評価し、1回あたりの平均コストを求める分析手法です。"
  },
  {
    "id": 135,
    "question": "OSI参照モデルは何層構造ですか？",
    "options": ["A. 4層", "B. 5層", "C. 6層", "D. 7層"],
    "correct": 3,
    "explanation": "OSI参照モデルは物理層、データリンク層、ネットワーク層、トランスポート層、セッション層、プレゼンテーション層、アプリケーション層の7層です。"
  },
  {
    "id": 136,
    "question": "OSI参照モデルの第1層（最下層）は？",
    "options": [
      "A. データリンク層",
      "B. ネットワーク層",
      "C. 物理層",
      "D. トランスポート層"
    ],
    "correct": 2,
    "explanation": "第1層は物理層で、電気信号や光信号によるビットの伝送を担当します。"
  },
  {
    "id": 137,
    "question": "OSI参照モデルの第2層（データリンク層）で使われるアドレスは？",
    "options": ["A. IPアドレス", "B. MACアドレス", "C. ポート番号", "D. URL"],
    "correct": 1,
    "explanation": "データリンク層ではMACアドレス（物理アドレス）を使って同一ネットワーク内の通信を行います。"
  },
  {
    "id": 138,
    "question": "OSI参照モデルの第3層（ネットワーク層）の主な役割は？",
    "options": [
      "A. データの暗号化",
      "B. ルーティングとアドレッシング",
      "C. ファイルの転送",
      "D. セッション管理"
    ],
    "correct": 1,
    "explanation": "ネットワーク層はIPアドレスを使ったルーティング（経路選択）と論理アドレッシングを担当します。"
  },
  {
    "id": 139,
    "question": "OSI参照モデルの第5層は？",
    "options": [
      "A. トランスポート層",
      "B. セッション層",
      "C. プレゼンテーション層",
      "D. アプリケーション層"
    ],
    "correct": 1,
    "explanation": "第5層はセッション層で、通信のセションの確立・維持・終了を管理します。"
  },
  {
    "id": 140,
    "question": "OSI参照モデルの第6層（プレゼンテーション層）の役割は？",
    "options": [
      "A. ルーティング",
      "B. データ形式の変換・暗号化",
      "C. 物理的な接続",
      "D. エラー検出"
    ],
    "correct": 1,
    "explanation": "プレゼンテーション層はデータの表現形式の変換（文字コード、暗号化、圧縮）を担当します。"
  },
  {
    "id": 141,
    "question": "MACアドレスは何ビットで構成されていますか？",
    "options": ["A. 32ビット", "B. 48ビット", "C. 64ビット", "D. 128ビット"],
    "correct": 1,
    "explanation": "MACアドレスは48ビット（6バイト）で構成され、例えば00:1A:2B:3C:4D:5Eのように表記されます。"
  },
  {
    "id": 142,
    "question": "イーサネットフレームのMTU（最大転送単位）は通常何バイト？",
    "options": [
      "A. 512バイト",
      "B. 1000バイト",
      "C. 1500バイト",
      "D. 9000バイト"
    ],
    "correct": 2,
    "explanation": "標準的なイーサネットのMTUは1500バイトです。ジャンボフレームでは9000バイトまで対応できます。"
  },
  {
    "id": 143,
    "question": "TCP/IPモデルは何層構造ですか？",
    "options": ["A. 3層", "B. 4層", "C. 5層", "D. 7層"],
    "correct": 1,
    "explanation": "TCP/IPモデルはネットワークインターフェース層、インターネット層、トランスポート層、アプリケーション層の4層です。"
  },
  {
    "id": 144,
    "question": "TCPの特徴として正しいものは？",
    "options": [
      "A. コネクションレス型",
      "B. コネクション型で信頼性のある通信",
      "C. 低遅延だが信頼性なし",
      "D. ブロードキャスト専用"
    ],
    "correct": 1,
    "explanation": "TCPはコネクション型プロトコルで、3ウェイハンドシェイクによる接続確立と再送制御で信頼性を提供します。"
  },
  {
    "id": 145,
    "question": "TCPの3ウェイハンドシェイクの正しい順序は？",
    "options": [
      "A. SYN → ACK → SYN-ACK",
      "B. SYN → SYN-ACK → ACK",
      "C. ACK → SYN → SYN-ACK",
      "D. SYN-ACK → SYN → ACK"
    ],
    "correct": 1,
    "explanation": "クライアントがSYN送信→サーバーがSYN-ACK返信→クライアントがACK送信の順です。"
  },
  {
    "id": 146,
    "question": "UDPの特徴として正しいものは？",
    "options": [
      "A. 信頼性が高い",
      "B. コネクション型",
      "C. 低遅延だが信頼性の保証がない",
      "D. 自動再送機能がある"
    ],
    "correct": 2,
    "explanation": "UDPはコネクションレス型で、再送制御がないため低遅延ですが、パケットロスの保証はありません。"
  },
  {
    "id": 147,
    "question": "UDPが適した用途は？",
    "options": [
      "A. ファイル転送",
      "B. メール送信",
      "C. リアルタイム動画ストリーミング",
      "D. Webページの閲覧"
    ],
    "correct": 2,
    "explanation": "UDPは遅延が少ないため、動画ストリーミングやVoIP、オンラインゲームなどリアルタイム通信に適しています。"
  },
  {
    "id": 148,
    "question": "TCPのウィンドウサイズとは何ですか？",
    "options": [
      "A. パケットのサイズ",
      "B. 確認応答なしに送信できるデータ量",
      "C. 接続数の上限",
      "D. タイムアウトの時間"
    ],
    "correct": 1,
    "explanation": "ウィンドウサイズはACKを受け取る前に送信できるデータ量を制御し、フロー制御を実現します。"
  },
  {
    "id": 149,
    "question": "TCPの輻輳制御で「スロースタート」とは？",
    "options": [
      "A. 通信速度を固定にする",
      "B. 少量のデータから始めて徐々に量を増やす",
      "C. タイムアウトを長くする",
      "D. 再送回数を制限する"
    ],
    "correct": 1,
    "explanation": "スロースタートはウィンドウサイズを指数的に増加させ、ネットワークの輻輳を避けつつ送信量を増やします。"
  },
  {
    "id": 150,
    "question": "IPプロトコルはOSI参照モデルの何層で動作する？",
    "options": ["A. 第2層", "B. 第3層", "C. 第4層", "D. 第7層"],
    "correct": 1,
    "explanation": "IP（Internet Protocol）はOSIの第3層（ネットワーク層）で動作します。"
  },
  {
    "id": 151,
    "question": "ARPの役割は？",
    "options": [
      "A. IPアドレスの自動取得",
      "B. IPアドレスからMACアドレスを解決",
      "C. ドメイン名の解決",
      "D. データの暗号化"
    ],
    "correct": 1,
    "explanation": "ARP（Address Resolution Protocol）はIPアドレスから、同一ネットワーク内のMACアドレスを求めます。"
  },
  {
    "id": 152,
    "question": "ICMPの代表的な使用例は？",
    "options": [
      "A. ファイル転送",
      "B. pingコマンド",
      "C. Webブラウジング",
      "D. メール送信"
    ],
    "correct": 1,
    "explanation": "ICMP（Internet Control Message Protocol）はpingやtracerouteのように、ネットワークの疎通確認に使われます。"
  },
  {
    "id": 153,
    "question": "HTTPが使用するデフォルトのポート番号は？",
    "options": ["A. 21", "B. 25", "C. 80", "D. 443"],
    "correct": 2,
    "explanation": "HTTPはデフォルトでポート80を使用します。"
  },
  {
    "id": 154,
    "question": "HTTPSが使用するデフォルトのポート番号は？",
    "options": ["A. 80", "B. 8080", "C. 443", "D. 8443"],
    "correct": 2,
    "explanation": "HTTPSはデフォルトでポート443を使用します。"
  },
  {
    "id": 155,
    "question": "SSHが使用するデフォルトのポート番号は？",
    "options": ["A. 20", "B. 21", "C. 22", "D. 23"],
    "correct": 2,
    "explanation": "SSH（Secure Shell）はデフォルトでポート22を使用します。"
  },
  {
    "id": 156,
    "question": "FTPのデータ転送用のデフォルトポート番号は？",
    "options": ["A. 20", "B. 21", "C. 22", "D. 25"],
    "correct": 0,
    "explanation": "FTPはポート21が制御用、ポート20がデータ転送用です。"
  },
  {
    "id": 157,
    "question": "SMTPが使用するデフォルトのポート番号は？",
    "options": ["A. 22", "B. 25", "C. 80", "D. 110"],
    "correct": 1,
    "explanation": "SMTP（Simple Mail Transfer Protocol）はデフォルトでポート25を使用してメールを送信します。"
  },
  {
    "id": 158,
    "question": "DNSが使用するデフォルトのポート番号は？",
    "options": ["A. 23", "B. 53", "C. 80", "D. 443"],
    "correct": 1,
    "explanation": "DNS（Domain Name System）はデフォルトでポート53を使用します。（UDP/TCPの両方）"
  },
  {
    "id": 159,
    "question": "POP3が使用するデフォルトのポート番号は？",
    "options": ["A. 25", "B. 110", "C. 143", "D. 993"],
    "correct": 1,
    "explanation": "POP3（Post Office Protocol 3）はデフォルトでポート110を使用してメールを受信します。"
  },
  {
    "id": 160,
    "question": "IMAP4が使用するデフォルトのポート番号は？",
    "options": ["A. 110", "B. 143", "C. 993", "D. 587"],
    "correct": 1,
    "explanation": "IMAP4はデフォルトでポート143を使用します。暗号化版のIMAPSはポート993です。"
  },
  {
    "id": 161,
    "question": "ウェルノウンポート (Well-Known Ports) の範囲は？",
    "options": ["A. 0〜255", "B. 0〜1023", "C. 0〜65535", "D. 1024〜49151"],
    "correct": 1,
    "explanation": "ウェルノウンポートは0〜1023の範囲で、HTTP(80)やHTTPS(443)などの標準サービスに割り当てられています。"
  },
  {
    "id": 162,
    "question": "ポート番号の最大値は？",
    "options": ["A. 1023", "B. 49151", "C. 65535", "D. 99999"],
    "correct": 2,
    "explanation": "ポート番号は16ビットで表現され、0〜65535の範囲です。"
  },
  {
    "id": 163,
    "question": "RDPが使用するデフォルトのポート番号は？",
    "options": ["A. 22", "B. 80", "C. 3306", "D. 3389"],
    "correct": 3,
    "explanation": "RDP（Remote Desktop Protocol）はデフォルトでポート3389を使用します。"
  },
  {
    "id": 164,
    "question": "MySQLが使用するデフォルトのポート番号は？",
    "options": ["A. 1433", "B. 3306", "C. 5432", "D. 27017"],
    "correct": 1,
    "explanation": "MySQLはデフォルトでポート3306を使用します。"
  },
  {
    "id": 165,
    "question": "DNSの主な役割は？",
    "options": [
      "A. IPアドレスの自動割り当て",
      "B. ドメイン名とIPアドレスの相互変換",
      "C. データの暗号化",
      "D. ルーティング"
    ],
    "correct": 1,
    "explanation": "DNSはドメイン名（例: example.com）をIPアドレスに変換する名前解決サービスです。"
  },
  {
    "id": 166,
    "question": "DNSのAレコードの役割は？",
    "options": [
      "A. メールサーバーの指定",
      "B. ドメインの別名",
      "C. ドメイン名とIPv4アドレスの対応",
      "D. ネームサーバーの指定"
    ],
    "correct": 2,
    "explanation": "Aレコードはドメイン名をIPv4アドレスにマッピングするDNSレコードです。"
  },
  {
    "id": 167,
    "question": "DNSのAAAAレコードは何に使われる？",
    "options": [
      "A. IPv4アドレスのマッピング",
      "B. IPv6アドレスのマッピング",
      "C. メールサーバーの指定",
      "D. テキスト情報の格納"
    ],
    "correct": 1,
    "explanation": "AAAAレコードはドメイン名をIPv6アドレスにマッピングするレコードです。"
  },
  {
    "id": 168,
    "question": "DNSのMXレコードの役割は？",
    "options": [
      "A. Webサーバーの指定",
      "B. メールサーバーの指定",
      "C. IPv6のマッピング",
      "D. リバースDNS"
    ],
    "correct": 1,
    "explanation": "MXレコード（Mail Exchange）はドメインのメールを受信するメールサーバーを指定します。"
  },
  {
    "id": 169,
    "question": "DNSのCNAMEレコードの機能は？",
    "options": [
      "A. IPアドレスの指定",
      "B. ドメインの別名（エイリアス）を設定",
      "C. ポート番号の指定",
      "D. TTLの設定"
    ],
    "correct": 1,
    "explanation": "CNAMEは別のドメイン名へのエイリアス（別名）を作成するレコードです。"
  },
  {
    "id": 170,
    "question": "DNSキャッシュポイズニングとは？",
    "options": [
      "A. DNSサーバーの容量不足",
      "B. DNSキャッシュに偽の情報を注入する攻撃",
      "C. DNSサーバーの電源障害",
      "D. DNSのTTLを短くすること"
    ],
    "correct": 1,
    "explanation": "DNSキャッシュポイズニングはDNSキャッシュに偽のIPアドレスを注入し、ユーザーを不正なサイトに誘導する攻撃です。"
  },
  {
    "id": 171,
    "question": "DNSのTTLとは？",
    "options": [
      "A. DNSレコードの種類",
      "B. DNSレコードがキャッシュされる時間",
      "C. DNSサーバーの応答時間",
      "D. DNSの暗号化方式"
    ],
    "correct": 1,
    "explanation": "TTL（Time To Live）はDNSレコードがキャッシュに保持される有効期間（秒数）です。"
  },
  {
    "id": 172,
    "question": "再帰的DNSクエリとは？",
    "options": [
      "A. クライアントが複数のDNSサーバーに直接問い合わせる",
      "B. DNSサーバーが代わりに最終回答を得るまで問い合わせる",
      "C. DNSキャッシュのみを使う",
      "D. 逆引きDNSのこと"
    ],
    "correct": 1,
    "explanation": "再帰的クエリではDNSリゾルバがルートからたどって最終的なIPアドレスを取得し、クライアントに返します。"
  },
  {
    "id": 173,
    "question": "DHCPの主な役割は？",
    "options": [
      "A. ドメイン名の解決",
      "B. IPアドレスの自動割り当て",
      "C. メールの配送",
      "D. ファイルの転送"
    ],
    "correct": 1,
    "explanation": "DHCP（Dynamic Host Configuration Protocol）はネットワーク上のデバイスにIPアドレスなどの設定を自動的に割り当てます。"
  },
  {
    "id": 174,
    "question": "DHCPで割り当てられる情報に含まれないものは？",
    "options": [
      "A. IPアドレス",
      "B. サブネットマスク",
      "C. デフォルトゲートウェイ",
      "D. ユーザーパスワード"
    ],
    "correct": 3,
    "explanation": "DHCPはIPアドレス、サブネットマスク、デフォルトゲートウェイ、DNSサーバーなどを割り当てますが、パスワードは含まれません。"
  },
  {
    "id": 175,
    "question": "DHCPのIPアドレス取得の流れ（DORA）で正しい順序は？",
    "options": [
      "A. Discover→Offer→Request→Acknowledge",
      "B. Discover→Request→Offer→Acknowledge",
      "C. Request→Discover→Offer→Acknowledge",
      "D. Offer→Discover→Request→Acknowledge"
    ],
    "correct": 0,
    "explanation": "DHCPはDiscover→Offer→Request→Acknowledge（DORA）の4ステップでIPアドレスを割り当てます。"
  },
  {
    "id": 176,
    "question": "DHCPリースとは何ですか？",
    "options": [
      "A. DHCPサーバーの購入費用",
      "B. IPアドレスの一時的な貸し出し期間",
      "C. ネットワークの帯域",
      "D. DHCPの暗号化方式"
    ],
    "correct": 1,
    "explanation": "DHCPリースはクライアントに割り当てられたIPアドレスの使用期限で、期限後は更新または返却されます。"
  },
  {
    "id": 177,
    "question": "静的IPアドレスとDHCPによる動的IPアドレスの違いは？",
    "options": [
      "A. 速度が異なる",
      "B. 静的は手動設定で変わらず、動的はDHCPが自動で割り当て",
      "C. セキュリティが異なる",
      "D. 使えるポート番号が異なる"
    ],
    "correct": 1,
    "explanation": "静的IPは管理者が手動で設定し常に同じ、動的IPはDHCPが自動割り当てするため変わることがあります。"
  },
  {
    "id": 178,
    "question": "NAT（Network Address Translation）の主な目的は？",
    "options": [
      "A. ドメイン名の解決",
      "B. プライベートIPとグローバルIPの変換",
      "C. データの暗号化",
      "D. パケットのルーティング"
    ],
    "correct": 1,
    "explanation": "NATはプライベートIPアドレスをグローバルIPアドレスに変換し、インターネットへの接続を可能にします。"
  },
  {
    "id": 179,
    "question": "NAPT（またはPAT）はNATとどう違う？",
    "options": [
      "A. 違いはない",
      "B. ポート番号も変換して複数端末で1つのIPを共有",
      "C. IPアドレスのみを変換",
      "D. IPv6専用"
    ],
    "correct": 1,
    "explanation": "NAPT（PAT）はIPアドレスに加えてポート番号も変換し、1つのグローバルIPで複数の端末がインターネットを利用できます。"
  },
  {
    "id": 180,
    "question": "NATのデメリットとして正しいものは？",
    "options": [
      "A. セキュリティが弱くなる",
      "B. 外部からのインバウンド接続が難しくなる",
      "C. 通信速度が10倍遅くなる",
      "D. IPv6が使えなくなる"
    ],
    "correct": 1,
    "explanation": "NATの内側のデバイスは外部から直接接続できないため、サーバー公開にはポートフォワーディングが必要です。"
  },
  {
    "id": 181,
    "question": "NATトラバーサルとは何ですか？",
    "options": [
      "A. NATを無効にすること",
      "B. NAT越しに端末同士が通信する技術",
      "C. NATのセキュリティ強化",
      "D. NATの速度向上"
    ],
    "correct": 1,
    "explanation": "NATトラバーサルはNATの背後にある端末同士が直接通信できるようにする技術（STUN、TURNなど）です。"
  },
  {
    "id": 182,
    "question": "静的NATとは？",
    "options": [
      "A. IPアドレスを動的に変換",
      "B. プライベートIPとグローバルIPを1対1で固定的にマッピング",
      "C. ポート番号を変換",
      "D. 時間帯で変換先を変更"
    ],
    "correct": 1,
    "explanation": "静的NATは特定のプライベートIPを特定のグローバルIPに1対1で常に変換する方式です。"
  },
  {
    "id": 183,
    "question": "ルーティングテーブルの主な内容は？",
    "options": [
      "A. ユーザー名とパスワード",
      "B. 宛先ネットワークと次のホップ（転送先）",
      "C. ファイルのパス",
      "D. 暗号化キー"
    ],
    "correct": 1,
    "explanation": "ルーティングテーブルには宛先ネットワーク、サブネットマスク、次のホップ（ルータ）、インターフェースなどが含まれます。"
  },
  {
    "id": 184,
    "question": "静的ルーティングと動的ルーティングの違いは？",
    "options": [
      "A. 速度の違い",
      "B. 手動設定か自動学習か",
      "C. IPv4かIPv6かの違い",
      "D. セキュリティの違い"
    ],
    "correct": 1,
    "explanation": "静的ルーティングは管理者が手動でルートを設定、動的ルーティングはルーティングプロトコルが自動で経路を学習します。"
  },
  {
    "id": 185,
    "question": "RIPルーティングプロトコルのメトリックは？",
    "options": ["A. 帯域幅", "B. ホップ数", "C. 遅延", "D. コスト"],
    "correct": 1,
    "explanation": "RIP（Routing Information Protocol）はホップ数（経由するルータの数）をメトリックとして最短経路を選択します。"
  },
  {
    "id": 186,
    "question": "OSPFルーティングプロトコルの特徴は？",
    "options": [
      "A. ディスタンスベクタ型",
      "B. リンクステート型でコストベース",
      "C. ホップ数ベース",
      "D. BGPの一種"
    ],
    "correct": 1,
    "explanation": "OSPFはリンクステート型プロトコルで、帯域幅に基づくコストをメトリックに使用します。"
  },
  {
    "id": 187,
    "question": "デフォルトゲートウェイの役割は？",
    "options": [
      "A. DNSの解決",
      "B. 同一ネットワーク外への通信の転送先ルータ",
      "C. DHCPのアドレス配布",
      "D. ファイアウォール"
    ],
    "correct": 1,
    "explanation": "デフォルトゲートウェイは、宛先が同一サブネット内にない場合にパケットを転送する先のルータです。"
  },
  {
    "id": 188,
    "question": "ルーティングで「最長一致（Longest Prefix Match）」とは？",
    "options": [
      "A. 最も長い経路を選ぶ",
      "B. 宛先IPに最も詳細に一致するルートを選ぶ",
      "C. 最も長い時間使われたルートを選ぶ",
      "D. 最もホップ数が多いルートを選ぶ"
    ],
    "correct": 1,
    "explanation": "最長一致はルーティングテーブルの中で、宛先IPアドレスに最も長いプレフィックスで一致するエントリを選択します。"
  },
  {
    "id": 189,
    "question": "BGPは何の略ですか？",
    "options": [
      "A. Basic Gateway Protocol",
      "B. Border Gateway Protocol",
      "C. Broadband General Protocol",
      "D. Binary Graph Protocol"
    ],
    "correct": 1,
    "explanation": "BGPはBorder Gateway Protocolの略で、インターネット上のAS（自律システム）間の経路情報を交換します。"
  },
  {
    "id": 190,
    "question": "BGPが「インターネットの経路プロトコル」と呼ばれる理由は？",
    "options": [
      "A. 最も高速だから",
      "B. 全てのISP・AS間の経路交換を担当するから",
      "C. 最も古いプロトコルだから",
      "D. 唯一のルーティングプロトコルだから"
    ],
    "correct": 1,
    "explanation": "BGPはISPや大規模ネットワーク（AS）間の経路情報を交換し、全インターネットのルーティングを支えています。"
  },
  {
    "id": 191,
    "question": "AS（Autonomous System）とは？",
    "options": [
      "A. 自動化されたサーバー",
      "B. 単一のルーティングポリシーで管理されるネットワーク群",
      "C. 自律的に動くAI",
      "D. 自動スケーリングシステム"
    ],
    "correct": 1,
    "explanation": "ASは同一のルーティングポリシー下で運用されるIPネットワークの集合で、AS番号で識別されます。"
  },
  {
    "id": 192,
    "question": "eBGPとiBGPの違いは？",
    "options": [
      "A. プロトコルのバージョンの違い",
      "B. AS間（external）かAS内（internal）かの違い",
      "C. 速度の違い",
      "D. 暗号化の有無"
    ],
    "correct": 1,
    "explanation": "eBGPは異なるAS間の経路交換、iBGPは同一AS内での経路情報の共有に使われます。"
  },
  {
    "id": 193,
    "question": "BGPのパス属性で最も優先的に参照されるのは？",
    "options": ["A. MED", "B. AS_PATH", "C. LOCAL_PREF", "D. ORIGIN"],
    "correct": 2,
    "explanation": "BGPの経路選択では、LOCAL_PREFが最も優先度の高い属性として評価されます。"
  },
  {
    "id": 194,
    "question": "BGPハイジャックとは何ですか？",
    "options": [
      "A. BGPセッションの高速化",
      "B. 不正なAS経路情報を広告しトラフィックを奪う攻撃",
      "C. BGPの設定ミス",
      "D. BGPのバージョンアップ"
    ],
    "correct": 1,
    "explanation": "BGPハイジャックは攻撃者が不正な経路情報を広告し、他人宛のトラフィックを自分に引き込む攻撃です。"
  },
  {
    "id": 195,
    "question": "HTTPのGETメソッドとPOSTメソッドの主な違いは？",
    "options": [
      "A. GETは暗号化される",
      "B. GETはURLにデータを含み、POSTはボディにデータを含む",
      "C. POSTの方が高速",
      "D. GETはサーバーサイドのみで使用"
    ],
    "correct": 1,
    "explanation": "GETはクエリ文字列でデータを送信、POSTはリクエストボディに含めて送信します。GETはURLに表示されます。"
  },
  {
    "id": 196,
    "question": "HTTPステータスコード200は何を意味する？",
    "options": [
      "A. リダイレクト",
      "B. 成功（OK）",
      "C. 未認証",
      "D. サーバーエラー"
    ],
    "correct": 1,
    "explanation": "200 OKはリクエストが正常に処理されたことを示すステータスコードです。"
  },
  {
    "id": 197,
    "question": "HTTPステータスコード301は何を意味する？",
    "options": [
      "A. 一時的なリダイレクト",
      "B. 恒久的なリダイレクト",
      "C. 未認証",
      "D. 禁止"
    ],
    "correct": 1,
    "explanation": "301 Moved Permanentlyはリソースが恒久的に新しいURLに移動したことを示します。"
  },
  {
    "id": 198,
    "question": "HTTPステータスコード403は何を意味する？",
    "options": [
      "A. Not Found",
      "B. Forbidden（アクセス禁止）",
      "C. Internal Server Error",
      "D. Bad Request"
    ],
    "correct": 1,
    "explanation": "403 Forbiddenはサーバーがリクエストを理解したが、実行を拒否したことを示します。"
  },
  {
    "id": 199,
    "question": "HTTPステータスコード500は何を意味する？",
    "options": [
      "A. 成功",
      "B. クライアントエラー",
      "C. 内部サーバーエラー",
      "D. リダイレクト"
    ],
    "correct": 2,
    "explanation": "500 Internal Server Errorはサーバー内部で予期しないエラーが発生したことを示します。"
  },
  {
    "id": 200,
    "question": "HTTPSの「S」は何の略？",
    "options": ["A. Simple", "B. Secure", "C. Standard", "D. Server"],
    "correct": 1,
    "explanation": "HTTPSはHTTP over SSL/TLSで、SはSecure（安全な）を意味し、通信が暗号化されます。"
  },
  {
    "id": 201,
    "question": "TLS（Transport Layer Security）の目的は？",
    "options": [
      "A. ルーティングの高速化",
      "B. 通信の暗号化・認証・完全性の提供",
      "C. IPアドレスの割り当て",
      "D. ドメイン名の解決"
    ],
    "correct": 1,
    "explanation": "TLSは通信の機密性（暗号化）、認証（証明書）、完全性（改ざん検出）を提供するプロトコルです。"
  },
  {
    "id": 202,
    "question": "SSL証明書の主な役割は？",
    "options": [
      "A. IPアドレスの発行",
      "B. Webサイトの身元証明と暗号化鍵の提供",
      "C. ドメイン名の登録",
      "D. メモリの管理"
    ],
    "correct": 1,
    "explanation": "SSL証明書はWebサイトの真正性を証明し、暗号化通信のための公開鍵を提供します。"
  },
  {
    "id": 203,
    "question": "HTTP/2の改善点として正しいものは？",
    "options": [
      "A. テキストベースのプロトコル",
      "B. 1つの接続で複数のリクエストを並列処理（多重化）",
      "C. 暗号化の廃止",
      "D. UDPベースに変更"
    ],
    "correct": 1,
    "explanation": "HTTP/2はバイナリプロトコルで、1つのTCP接続上で複数のリクエスト/レスポンスを並行処理できます。"
  },
  {
    "id": 204,
    "question": "HTTP/3が使用するトランスポートプロトコルは？",
    "options": ["A. TCP", "B. UDP", "C. QUIC", "D. SCTP"],
    "correct": 2,
    "explanation": "HTTP/3はQUICプロトコル（UDP上に構築）を使用し、接続確立の高速化やヘッドオブラインブロッキングの解消を実現します。"
  },
  {
    "id": 205,
    "question": "HTTPヘッダの「Content-Type」の役割は？",
    "options": [
      "A. ファイルサイズの指定",
      "B. レスポンスボディのメディアタイプを指定",
      "C. 認証情報",
      "D. キャッシュの有効期限"
    ],
    "correct": 1,
    "explanation": "Content-Typeはレスポンスボディのデータ形式（text/html、application/jsonなど）を指定します。"
  },
  {
    "id": 206,
    "question": "CORSは何の略ですか？",
    "options": [
      "A. Cross-Origin Resource Sharing",
      "B. Client Origin Request System",
      "C. Central Origin Resource Server",
      "D. Common Object Request Service"
    ],
    "correct": 0,
    "explanation": "CORS（Cross-Origin Resource Sharing）は異なるオリジンのリソースへのアクセスを制御するHTTPの仕組みです。"
  },
  {
    "id": 207,
    "question": "HTTPメソッド「PUT」の主な用途は？",
    "options": [
      "A. リソースの取得",
      "B. リソースの新規作成のみ",
      "C. リソースの更新（全体の置き換え）",
      "D. リソースの削除"
    ],
    "correct": 2,
    "explanation": "PUTメソッドは指定されたURIのリソースを送信データで完全に置き換える（更新する）ために使用されます。"
  },
  {
    "id": 208,
    "question": "HTTPメソッド「PATCH」の主な用途は？",
    "options": [
      "A. リソース全体の置き換え",
      "B. リソースの部分的な更新",
      "C. リソースの削除",
      "D. リソースの取得"
    ],
    "correct": 1,
    "explanation": "PATCHメソッドはリソースの一部分だけを更新するために使用されます。PUTは全体の置き換えです。"
  },
  {
    "id": 209,
    "question": "WebSocketの特徴は？",
    "options": [
      "A. リクエスト/レスポンス型の通信",
      "B. クライアントとサーバー間の双方向リアルタイム通信",
      "C. UDPのみ使用",
      "D. HTTPの代替として暗号化を提供"
    ],
    "correct": 1,
    "explanation": "WebSocketは一度接続を確立すると、クライアントとサーバーが双方向にいつでもデータを送受信できます。"
  },
  {
    "id": 210,
    "question": "WebSocketの接続はどのように開始される？",
    "options": [
      "A. 独自のプロトコルで直接接続",
      "B. HTTPアップグレードリクエストで開始",
      "C. UDPパケットで開始",
      "D. FTPセッションから変換"
    ],
    "correct": 1,
    "explanation": "WebSocketはHTTPのUpgradeヘッダを使ってプロトコルをHTTPからWebSocketに切り替えて開始します。"
  },
  {
    "id": 211,
    "question": "WebSocketが適した用途でないものは？",
    "options": [
      "A. チャットアプリ",
      "B. リアルタイム株価表示",
      "C. 静的なWebページ配信",
      "D. オンラインゲーム"
    ],
    "correct": 2,
    "explanation": "静的なWebページは更新が不要なため、通常のHTTPで十分です。WebSocketは双方向リアルタイム通信が必要な場面に適しています。"
  },
  {
    "id": 212,
    "question": "WebSocketとHTTPのポーリングの違いは？",
    "options": [
      "A. 同じ仕組み",
      "B. WebSocketは常時接続、ポーリングは定期的にリクエスト",
      "C. ポーリングの方が高速",
      "D. WebSocketはサーバーからのみ通信可能"
    ],
    "correct": 1,
    "explanation": "WebSocketは常時接続でサーバーから即座にプッシュ可能。ポーリングはクライアントが定期的にリクエストするため遅延があります。"
  },
  {
    "id": 213,
    "question": "Server-Sent Events (SSE) とWebSocketの違いは？",
    "options": [
      "A. SSEは双方向通信",
      "B. SSEはサーバーからクライアントへの一方向通信",
      "C. WebSocketは一方向通信",
      "D. SSEはUDPを使用"
    ],
    "correct": 1,
    "explanation": "SSEはHTTP上でサーバーからクライアントへの一方向プッシュ通信です。WebSocketは双方向通信です。"
  },
  {
    "id": 214,
    "question": "CDNの正式名称は？",
    "options": [
      "A. Central Data Network",
      "B. Content Delivery Network",
      "C. Cloud Distribution Node",
      "D. Cached Domain Network"
    ],
    "correct": 1,
    "explanation": "CDNはContent Delivery Networkの略で、世界各地のサーバーにコンテンツをキャッシュして高速配信します。"
  },
  {
    "id": 215,
    "question": "CDNの主な利点は？",
    "options": [
      "A. データベースの高速化",
      "B. コンテンツ配信の高速化とサーバー負荷の分散",
      "C. プログラムのコンパイル高速化",
      "D. セキュリティの完全な保証"
    ],
    "correct": 1,
    "explanation": "CDNはユーザーに近いエッジサーバーからコンテンツを配信し、遅延削減とオリジンサーバーの負荷分散を実現します。"
  },
  {
    "id": 216,
    "question": "CDNのエッジサーバーとは？",
    "options": [
      "A. オリジンサーバー",
      "B. ユーザーに近い場所に配置されたキャッシュサーバー",
      "C. データベースサーバー",
      "D. メールサーバー"
    ],
    "correct": 1,
    "explanation": "エッジサーバーはユーザーの近くに配置され、キャッシュされたコンテンツを高速配信するサーバーです。"
  },
  {
    "id": 217,
    "question": "CDNで「キャッシュミス」が発生した場合どうなる？",
    "options": [
      "A. エラーが返される",
      "B. オリジンサーバーからコンテンツを取得する",
      "C. 前回のキャッシュが使われる",
      "D. 接続が切断される"
    ],
    "correct": 1,
    "explanation": "キャッシュミス時はエッジサーバーがオリジンサーバーにリクエストし、コンテンツを取得してキャッシュします。"
  },
  {
    "id": 218,
    "question": "CDNの代表的なサービスはどれ？",
    "options": ["A. MySQL", "B. Cloudflare", "C. Docker", "D. Kubernetes"],
    "correct": 1,
    "explanation": "Cloudflare、Akamai、Amazon CloudFront、Fastlyなどが代表的なCDNサービスです。"
  },
  {
    "id": 219,
    "question": "IPv4アドレスの表記方法は？",
    "options": [
      "A. 8つの16進数グループ",
      "B. 4つの10進数をドットで区切る",
      "C. 6つの16進数をコロンで区切る",
      "D. 2つの10進数をハイフンで区切る"
    ],
    "correct": 1,
    "explanation": "IPv4は192.168.1.1のように、0〜255の4つの10進数をドットで区切って表記します。"
  },
  {
    "id": 220,
    "question": "IPv6アドレスは何ビットで構成されますか？",
    "options": ["A. 32ビット", "B. 64ビット", "C. 128ビット", "D. 256ビット"],
    "correct": 2,
    "explanation": "IPv6は128ビット（16バイト）で構成され、約3.4×10^38個のアドレスを表現できます。"
  },
  {
    "id": 221,
    "question": "IPv6アドレスの表記方法は？",
    "options": [
      "A. 4つの10進数をドットで区切る",
      "B. 8つの16進数グループをコロンで区切る",
      "C. 6つの8進数をドットで区切る",
      "D. 4つの16進数をハイフンで区切る"
    ],
    "correct": 1,
    "explanation": "IPv6は2001:0db8:85a3::8a2e:0370:7334のように、8つの4桁16進数をコロンで区切って表記します。"
  },
  {
    "id": 222,
    "question": "IPv4の枯渇問題を根本的に解決する技術は？",
    "options": ["A. NAT", "B. DHCP", "C. IPv6", "D. CIDR"],
    "correct": 2,
    "explanation": "IPv6は128ビットアドレス空間を持ち、事実上無限のアドレスを提供してIPv4の枯渇問題を解決します。"
  },
  {
    "id": 223,
    "question": "プライベートIPアドレスの範囲として正しいものは？",
    "options": [
      "A. 192.168.0.0 〜 192.168.255.255",
      "B. 200.0.0.0 〜 200.255.255.255",
      "C. 1.0.0.0 〜 1.255.255.255",
      "D. 100.0.0.0 〜 100.255.255.255"
    ],
    "correct": 0,
    "explanation": "プライベートIPは10.0.0.0/8、172.16.0.0/12、192.168.0.0/16の3つの範囲です。"
  },
  {
    "id": 224,
    "question": "ループバックアドレスとは？",
    "options": ["A. 192.168.1.1", "B. 127.0.0.1", "C. 10.0.0.1", "D. 0.0.0.0"],
    "correct": 1,
    "explanation": "127.0.0.1はループバックアドレスで、自分自身を指すIPアドレスです（localhostとも呼ばれます）。"
  },
  {
    "id": 225,
    "question": "クラスAのIPアドレスの先頭ビットは？",
    "options": ["A. 0", "B. 10", "C. 110", "D. 1110"],
    "correct": 0,
    "explanation": "クラスAは先頭ビットが0で始まり、1.0.0.0〜126.255.255.255の範囲です。"
  },
  {
    "id": 226,
    "question": "サブネットマスク /24 は10進数で何？",
    "options": [
      "A. 255.255.0.0",
      "B. 255.255.255.0",
      "C. 255.255.255.128",
      "D. 255.255.255.255"
    ],
    "correct": 1,
    "explanation": "/24は上位24ビットが1なので、255.255.255.0（11111111.11111111.11111111.00000000）です。"
  },
  {
    "id": 227,
    "question": "サブネットマスク /24 のネットワークに割り当てられるホスト数は？",
    "options": ["A. 254", "B. 255", "C. 256", "D. 128"],
    "correct": 0,
    "explanation": "ホスト部は8ビット→2^8=256個。ネットワークアドレスとブロードキャストを引いて254個です。"
  },
  {
    "id": 228,
    "question": "192.168.1.0/26 のネットワークで使用可能なホスト数は？",
    "options": ["A. 30", "B. 62", "C. 64", "D. 126"],
    "correct": 1,
    "explanation": "ホスト部は6ビット→2^6=64個。ネットワークとブロードキャストを引いて62個使用可能です。"
  },
  {
    "id": 229,
    "question": "CIDR（Classless Inter-Domain Routing）表記の目的は？",
    "options": [
      "A. クラスによる固定的なアドレス割り当て",
      "B. 任意のビット数でサブネットを柔軟に分割",
      "C. IPv6専用の表記",
      "D. MACアドレスの表記"
    ],
    "correct": 1,
    "explanation": "CIDRはクラスに縛られず、任意のプレフィックス長でネットワークを分割できる柔軟な方式です。"
  },
  {
    "id": 230,
    "question": "192.168.10.130/25 のネットワークアドレスは？",
    "options": [
      "A. 192.168.10.0",
      "B. 192.168.10.128",
      "C. 192.168.10.64",
      "D. 192.168.10.192"
    ],
    "correct": 1,
    "explanation": "/25ではホスト部が7ビット。130を2進数にすると10000010。上位25ビットのマスクでネットワーク部は10000000=128なので192.168.10.128です。"
  },
  {
    "id": 231,
    "question": "ブロードキャストアドレスの特徴は？",
    "options": [
      "A. 特定のホストのみに送信",
      "B. 同一ネットワーク内の全ホストに送信",
      "C. ルータにのみ送信",
      "D. DNSサーバーに送信"
    ],
    "correct": 1,
    "explanation": "ブロードキャストアドレスはホスト部の全ビットが1で、同一ネットワーク内の全デバイスにパケットを送信します。"
  },
  {
    "id": 232,
    "question": "VLSM（Variable Length Subnet Masking）の利点は？",
    "options": [
      "A. 全サブネットが同じサイズ",
      "B. サブネットごとに異なるサイズを割り当てられる",
      "C. IPv6専用",
      "D. ルーティングが不要になる"
    ],
    "correct": 1,
    "explanation": "VLSMは各サブネットに必要なホスト数に応じて異なるサブネットマスクを使い、IPアドレスの無駄を減らします。"
  },
  {
    "id": 233,
    "question": "10.0.0.0/8 のネットワークで使用可能なホスト数は約何個？",
    "options": ["A. 約6万5千", "B. 約1600万", "C. 約42億", "D. 約256"],
    "correct": 1,
    "explanation": "ホスト部は24ビット→2^24-2 = 16,777,214（約1600万）個です。"
  },
  {
    "id": 234,
    "question": "VPNの正式名称は？",
    "options": [
      "A. Virtual Private Network",
      "B. Very Protected Network",
      "C. Variable Public Network",
      "D. Visual Processing Node"
    ],
    "correct": 0,
    "explanation": "VPNはVirtual Private Networkの略で、公衆ネットワーク上に仮想的な専用回線を構築します。"
  },
  {
    "id": 235,
    "question": "VPNの主な目的は？",
    "options": [
      "A. 通信速度の向上",
      "B. インターネット上での安全なプライベート通信",
      "C. ドメイン名の解決",
      "D. ファイルの圧縮"
    ],
    "correct": 1,
    "explanation": "VPNは暗号化トンネルを作成し、インターネット上で安全にプライベートな通信を行います。"
  },
  {
    "id": 236,
    "question": "IPsec VPNが動作するOSI層は？",
    "options": ["A. 第2層", "B. 第3層", "C. 第4層", "D. 第7層"],
    "correct": 1,
    "explanation": "IPsecはOSI第3層（ネットワーク層）で動作し、IPパケット単位で暗号化・認証を行います。"
  },
  {
    "id": 237,
    "question": "SSL/TLS VPNの利点は？",
    "options": [
      "A. 専用ソフトが常に必要",
      "B. Webブラウザから利用でき導入が容易",
      "C. UDPのみ対応",
      "D. IPv6非対応"
    ],
    "correct": 1,
    "explanation": "SSL/TLS VPNはWebブラウザで利用でき、専用ソフトなしでリモートアクセスが可能です。"
  },
  {
    "id": 238,
    "question": "VPNトンネリングとは？",
    "options": [
      "A. VPN接続の速度テスト",
      "B. パケットを暗号化して別のプロトコルでカプセル化する技術",
      "C. VPNサーバーの冗長化",
      "D. IPアドレスの変換"
    ],
    "correct": 1,
    "explanation": "トンネリングは元のパケットを暗号化し、VPNプロトコルでカプセル化して安全に転送する技術です。"
  },
  {
    "id": 239,
    "question": "WireGuardの特徴は？",
    "options": [
      "A. 最も古いVPNプロトコル",
      "B. シンプルで高速な新しいVPNプロトコル",
      "C. SSL/TLSベース",
      "D. IPsecと同じ実装"
    ],
    "correct": 1,
    "explanation": "WireGuardはコードベースが小さく、高速で設定がシンプルな新世代のVPNプロトコルです。"
  },
  {
    "id": 240,
    "question": "プロキシサーバーの主な役割は？",
    "options": [
      "A. DNSの解決",
      "B. クライアントの代理としてサーバーにアクセス",
      "C. IPアドレスの自動割り当て",
      "D. メールの配送"
    ],
    "correct": 1,
    "explanation": "プロキシサーバーはクライアントの代わりにWebサーバーに接続し、キャッシュやフィルタリングを行います。"
  },
  {
    "id": 241,
    "question": "フォワードプロキシとリバースプロキシの違いは？",
    "options": [
      "A. 同じもの",
      "B. フォワードはクライアント側、リバースはサーバー側に配置",
      "C. リバースの方が遅い",
      "D. フォワードは暗号化専用"
    ],
    "correct": 1,
    "explanation": "フォワードプロキシはクライアント側で外部へのアクセスを代理、リバースプロキシはサーバー側で外部からのアクセスを受ける構成です。"
  },
  {
    "id": 242,
    "question": "リバースプロキシの用途として正しいものは？",
    "options": [
      "A. クライアントの匿名化",
      "B. 負荷分散、SSL終端、キャッシュ",
      "C. DHCPの代替",
      "D. ファイル共有"
    ],
    "correct": 1,
    "explanation": "リバースプロキシは負荷分散、SSLオフロード、キャッシュ、セキュリティなど多様な用途で使われます。"
  },
  {
    "id": 243,
    "question": "SOCKSプロキシとHTTPプロキシの違いは？",
    "options": [
      "A. 同じプロトコル",
      "B. SOCKSはプロトコルに依存せず汎用的に使える",
      "C. HTTPプロキシの方が汎用的",
      "D. SOCKSはHTTPのみ対応"
    ],
    "correct": 1,
    "explanation": "SOCKSプロキシはTCP/UDPレベルで動作し、HTTP以外のプロトコル（FTP、SMTPなど）にも対応できます。"
  },
  {
    "id": 244,
    "question": "透過プロキシ（Transparent Proxy）の特徴は？",
    "options": [
      "A. 暗号化通信専用",
      "B. クライアントがプロキシの存在を意識しない",
      "C. 認証が必要",
      "D. VPN接続が必要"
    ],
    "correct": 1,
    "explanation": "透過プロキシはクライアントの設定変更なしに動作し、ユーザーはプロキシの存在を意識しません。"
  },
  {
    "id": 245,
    "question": "負荷分散（ロードバランシング）の目的は？",
    "options": [
      "A. セキュリティの向上のみ",
      "B. 複数サーバーにリクエストを分散し可用性と性能を向上",
      "C. データベースの暗号化",
      "D. ネットワークの監視"
    ],
    "correct": 1,
    "explanation": "負荷分散は複数のサーバーにトラフィックを分散し、応答速度の向上と障害時の可用性を確保します。"
  },
  {
    "id": 246,
    "question": "ロードバランサの「ラウンドロビン」方式とは？",
    "options": [
      "A. 最も負荷が低いサーバーに振り分け",
      "B. 順番にサーバーへリクエストを振り分け",
      "C. ランダムにサーバーを選択",
      "D. IPアドレスに基づいて固定サーバーに振り分け"
    ],
    "correct": 1,
    "explanation": "ラウンドロビンは各サーバーに順番にリクエストを振り分ける最もシンプルな負荷分散方式です。"
  },
  {
    "id": 247,
    "question": "ロードバランサの「最小接続数」方式とは？",
    "options": [
      "A. 最もレスポンスが速いサーバーに振り分け",
      "B. 接続数が最も少ないサーバーに振り分け",
      "C. ランダムに選択",
      "D. 地理的に近いサーバーに振り分け"
    ],
    "correct": 1,
    "explanation": "最小接続数（Least Connections）方式は、現在のアクティブ接続数が最も少ないサーバーにリクエストを振り分けます。"
  },
  {
    "id": 248,
    "question": "L4ロードバランサとL7ロードバランサの違いは？",
    "options": [
      "A. L4はHTTPの内容で振り分け、L7はIPで振り分け",
      "B. L4はIPとポートで振り分け、L7はHTTPの内容で振り分け",
      "C. 同じ動作をする",
      "D. L7の方が低機能"
    ],
    "correct": 1,
    "explanation": "L4はOSI第4層（TCP/IP）でIPとポートに基づき振り分け、L7は第7層（HTTP）でURL、ヘッダ、Cookieなどで振り分けます。"
  },
  {
    "id": 249,
    "question": "ヘルスチェックとは（ロードバランサにおいて）？",
    "options": [
      "A. ユーザーの健康状態を確認",
      "B. サーバーの死活監視",
      "C. ネットワーク帯域の測定",
      "D. SSL証明書の検証"
    ],
    "correct": 1,
    "explanation": "ヘルスチェックはロードバランサがバックエンドサーバーの正常稼働を定期的に確認し、障害時は振り分けを停止します。"
  },
  {
    "id": 250,
    "question": "スティッキーセッション（Session Affinity）とは？",
    "options": [
      "A. ランダムにサーバーを選ぶ",
      "B. 同一ユーザーのリクエストを同じサーバーに振り分ける",
      "C. セッションを暗号化する",
      "D. セッションの有効期限を延ばす"
    ],
    "correct": 1,
    "explanation": "スティッキーセッションは同じユーザー（Cookie/IPベース）のリクエストを常に同じバックエンドサーバーに送る仕組みです。"
  },
  {
    "id": 251,
    "question": "2進数「10110」を10進数に変換すると？",
    "options": ["A. 20", "B. 22", "C. 26", "D. 30"],
    "correct": 1,
    "explanation": "10110(2) = 16+4+2 = 22 です。"
  },
  {
    "id": 252,
    "question": "1バイトは何ビット？",
    "options": ["A. 4ビット", "B. 8ビット", "C. 16ビット", "D. 32ビット"],
    "correct": 1,
    "explanation": "1バイト = 8ビットです。これはコンピュータの基本的な情報単位です。"
  },
  {
    "id": 253,
    "question": "ビッグエンディアンとリトルエンディアンの違いは？",
    "options": [
      "A. 文字コードの違い",
      "B. 数値の上位バイトと下位バイトの格納順序の違い",
      "C. 整数と浮動小数点の違い",
      "D. 符号付きと符号なしの違い"
    ],
    "correct": 1,
    "explanation": "ビッグエンディアンは上位バイトが先（低アドレス）、リトルエンディアンは下位バイトが先に格納されます。"
  },
  {
    "id": 254,
    "question": "1の補数と2の補数の関係は？",
    "options": [
      "A. 全く無関係",
      "B. 2の補数 = 1の補数 + 1",
      "C. 1の補数 = 2の補数 + 1",
      "D. 同じもの"
    ],
    "correct": 1,
    "explanation": "2の補数は1の補数（全ビット反転）に1を加えた値です。負の数の表現に広く使われます。"
  },
  {
    "id": 255,
    "question": "キャリーフラグ（Carry Flag）はいつセットされる？",
    "options": [
      "A. 結果が0のとき",
      "B. 加算で桁あふれが発生したとき",
      "C. 負の結果のとき",
      "D. 偶数の結果のとき"
    ],
    "correct": 1,
    "explanation": "キャリーフラグは符号なし演算で結果がビット幅を超えた（桁あふれ）ときにセットされます。"
  },
  {
    "id": 256,
    "question": "オーバーフローとは？",
    "options": [
      "A. メモリの容量不足",
      "B. 演算結果がデータ型の表現範囲を超えること",
      "C. ネットワークの過負荷",
      "D. ディスクの空き容量不足"
    ],
    "correct": 1,
    "explanation": "オーバーフローは演算結果がデータ型で表現できる範囲を超えてしまう現象です。"
  },
  {
    "id": 257,
    "question": "AND演算 (0b1100 AND 0b1010) の結果は？",
    "options": ["A. 1000", "B. 1110", "C. 1010", "D. 0110"],
    "correct": 0,
    "explanation": "各ビット位置でANDを取ると: 1&1=1, 1&0=0, 0&1=0, 0&0=0 で1000になります。"
  },
  {
    "id": 258,
    "question": "OR演算 (0b1100 OR 0b1010) の結果は？",
    "options": ["A. 1000", "B. 1110", "C. 1010", "D. 0110"],
    "correct": 1,
    "explanation": "各ビット位置でORを取ると: 1|1=1, 1|0=1, 0|1=1, 0|0=0 で1110になります。"
  },
  {
    "id": 259,
    "question": "アウトオブオーダー実行（Out-of-Order Execution）とは？",
    "options": [
      "A. 命令を順番通りに実行",
      "B. データ依存関係を考慮して命令を順序変更して実行",
      "C. 命令を逆順に実行",
      "D. 命令をスキップして実行"
    ],
    "correct": 1,
    "explanation": "アウトオブオーダー実行はCPUがデータ依存を考慮し、効率的な順序に命令を並べ替えて実行する技術です。"
  },
  {
    "id": 260,
    "question": "ハイパースレッディング (Hyper-Threading) とは？",
    "options": [
      "A. 物理コアを増やす技術",
      "B. 1つの物理コアを2つの論理コアとして扱う技術",
      "C. クロック周波数を2倍にする技術",
      "D. メモリ帯域を拡張する技術"
    ],
    "correct": 1,
    "explanation": "ハイパースレッディングは1つの物理コアで2つのスレッドを同時実行し、リソース利用効率を向上させるIntelの技術です。"
  },
  {
    "id": 261,
    "question": "SIMD命令とは何ですか？",
    "options": [
      "A. Single Instruction, Multiple Data",
      "B. Simple Input, Multiple Display",
      "C. Secure Internet, Multiple Domain",
      "D. Serial Input, Manual Decode"
    ],
    "correct": 0,
    "explanation": "SIMDは単一の命令で複数のデータを同時に処理する方式で、マルチメディア処理などで高速化を実現します。"
  },
  {
    "id": 262,
    "question": "TLB（Translation Lookaside Buffer）の役割は？",
    "options": [
      "A. ディスクのキャッシュ",
      "B. 仮想アドレスから物理アドレスへの変換を高速化",
      "C. CPUの命令キャッシュ",
      "D. ネットワークバッファ"
    ],
    "correct": 1,
    "explanation": "TLBはページテーブルのキャッシュで、仮想アドレスを物理アドレスに高速に変換します。"
  },
  {
    "id": 263,
    "question": "メモリのフラグメンテーションとは？",
    "options": [
      "A. メモリの暗号化",
      "B. 使用可能なメモリが断片化して大きな領域を確保できなくなること",
      "C. メモリの速度低下",
      "D. メモリの物理的な破損"
    ],
    "correct": 1,
    "explanation": "フラグメンテーションはメモリの割り当てと解放を繰り返すことで、空き領域が断片化する現象です。"
  },
  {
    "id": 264,
    "question": "セグメンテーション方式とページング方式の違いは？",
    "options": [
      "A. 同じもの",
      "B. セグメンテーションは意味のある可変長単位、ページングは固定長単位",
      "C. ページングの方が可変長",
      "D. セグメンテーションはIPv6用"
    ],
    "correct": 1,
    "explanation": "セグメンテーションは論理的に意味のある可変長単位で分割、ページングは固定長で物理的に分割する方式です。"
  },
  {
    "id": 265,
    "question": "キャッシュのフルアソシアティブ方式の特徴は？",
    "options": [
      "A. データが特定の1箇所にのみ格納される",
      "B. データがキャッシュのどの位置にも格納できる",
      "C. データが2箇所のどちらかに格納される",
      "D. キャッシュが無効化される"
    ],
    "correct": 1,
    "explanation": "フルアソシアティブ方式はデータをキャッシュの任意の場所に格納でき、キャッシュミスの確率は最低ですが、回路が複雑です。"
  },
  {
    "id": 266,
    "question": "ダイレクトマップ方式のキャッシュの特徴は？",
    "options": [
      "A. データがどこにでも格納できる",
      "B. メモリアドレスによって格納場所が一意に決まる",
      "C. 2箇所のどちらかに格納",
      "D. ランダムに格納"
    ],
    "correct": 1,
    "explanation": "ダイレクトマップ方式はメモリアドレスから格納場所が一意に決まり、回路は単純ですが衝突が起きやすいです。"
  },
  {
    "id": 267,
    "question": "CISCアーキテクチャで、1命令で「メモリの読み出し→演算→メモリ書き込み」が可能な理由は？",
    "options": [
      "A. クロック周波数が高いから",
      "B. 命令セットに複雑な命令が含まれているから",
      "C. レジスタ数が多いから",
      "D. パイプラインが深いから"
    ],
    "correct": 1,
    "explanation": "CISCは複雑な命令を持ち、メモリアクセスと演算を1つの命令で実行できるマイクロコードを使用します。"
  },
  {
    "id": 268,
    "question": "RISCのロードストアアーキテクチャとは？",
    "options": [
      "A. 全命令がメモリアクセス可能",
      "B. メモリアクセスはLOADとSTORE命令のみ、演算はレジスタ間のみ",
      "C. ストアは不要でロードのみ使用",
      "D. キャッシュの管理方式"
    ],
    "correct": 1,
    "explanation": "RISCのロードストアアーキテクチャでは、メモリとレジスタ間はLOAD/STOREのみ、演算はレジスタ間で行います。"
  },
  {
    "id": 269,
    "question": "アセンブリ言語の「CMP」命令の機能は？",
    "options": [
      "A. 値のコピー",
      "B. 2つの値の比較（減算してフラグを設定）",
      "C. ジャンプ",
      "D. スタック操作"
    ],
    "correct": 1,
    "explanation": "CMP（Compare）は2つの値の差を計算し、結果は保存せずフラグレジスタのみを設定して条件分岐に使います。"
  },
  {
    "id": 270,
    "question": "アセンブリ言語の「CALL」命令の機能は？",
    "options": [
      "A. 値の比較",
      "B. サブルーチンの呼び出し（戻りアドレスをスタックに保存）",
      "C. ループの開始",
      "D. レジスタのクリア"
    ],
    "correct": 1,
    "explanation": "CALL命令は戻りアドレスをスタックにプッシュし、指定されたサブルーチンにジャンプします。"
  },
  {
    "id": 271,
    "question": "グラフでDFS（深さ優先探索）が使われる典型的な用途は？",
    "options": [
      "A. 最短経路の探索",
      "B. 迷路の解探索やトポロジカルソート",
      "C. データの暗号化",
      "D. 負荷分散"
    ],
    "correct": 1,
    "explanation": "DFSは迷路探索、トポロジカルソート、連結成分の検出などに使われます。"
  },
  {
    "id": 272,
    "question": "再帰関数が引き起こしやすい問題は？",
    "options": [
      "A. メモリリーク",
      "B. スタックオーバーフロー",
      "C. デッドロック",
      "D. バッファオーバーラン"
    ],
    "correct": 1,
    "explanation": "再帰が深くなりすぎると、関数呼び出しのたびにスタックが消費され、スタックオーバーフローが発生します。"
  },
  {
    "id": 273,
    "question": "安定ソートとは何ですか？",
    "options": [
      "A. 常に最速のソート",
      "B. 同じ値の要素の相対的な順序が保たれるソート",
      "C. メモリを使わないソート",
      "D. 並列実行可能なソート"
    ],
    "correct": 1,
    "explanation": "安定ソートは、キーが同じ値の要素について、入力時の相対的な順序が出力でも維持されるソートです。"
  },
  {
    "id": 274,
    "question": "ハッシュ関数の「一方向性」とは？",
    "options": [
      "A. 入力から出力は計算できるが、出力から入力を復元できない",
      "B. 1方向にしか通信できない",
      "C. データが1回しか使えない",
      "D. 暗号化が1重であること"
    ],
    "correct": 0,
    "explanation": "一方向性ハッシュ関数は入力→ハッシュ値は容易ですが、ハッシュ値→元の入力の復元は計算上困難です。"
  },
  {
    "id": 275,
    "question": "チェイン法（連鎖法）とは、ハッシュテーブルの何を解決する？",
    "options": ["A. メモリ不足", "B. ハッシュ衝突", "C. 検索速度", "D. ソート"],
    "correct": 1,
    "explanation": "チェイン法は同じハッシュ値を持つ要素をリンクリストで連結して格納し、衝突を解決する方法です。"
  },
  {
    "id": 276,
    "question": "OSI第7層（アプリケーション層）のプロトコルでないものは？",
    "options": ["A. HTTP", "B. FTP", "C. SMTP", "D. TCP"],
    "correct": 3,
    "explanation": "TCPは第4層（トランスポート層）のプロトコルです。HTTP、FTP、SMTPは第7層です。"
  },
  {
    "id": 277,
    "question": "スイッチ（L2スイッチ）が動作するOSI層は？",
    "options": ["A. 第1層", "B. 第2層", "C. 第3層", "D. 第4層"],
    "correct": 1,
    "explanation": "L2スイッチは第2層（データリンク層）で動作し、MACアドレスを元にフレームを転送します。"
  },
  {
    "id": 278,
    "question": "ルータが動作するOSI層は？",
    "options": ["A. 第1層", "B. 第2層", "C. 第3層", "D. 第4層"],
    "correct": 2,
    "explanation": "ルータは第3層（ネットワーク層）で動作し、IPアドレスを元にパケットをルーティングします。"
  },
  {
    "id": 279,
    "question": "TCPのFINフラグの役割は？",
    "options": [
      "A. 接続の開始",
      "B. データの確認応答",
      "C. 接続の終了を要求",
      "D. データの再送"
    ],
    "correct": 2,
    "explanation": "FINフラグはTCP接続の正常な終了を要求するために使用されます。"
  },
  {
    "id": 280,
    "question": "TCPのRSTフラグの役割は？",
    "options": [
      "A. 接続の開始",
      "B. 接続のリセット（強制切断）",
      "C. データの確認",
      "D. ウィンドウサイズの変更"
    ],
    "correct": 1,
    "explanation": "RSTフラグはTCP接続を強制的にリセット（切断）する際に使用されます。"
  },
  {
    "id": 281,
    "question": "Telnetが使用するデフォルトポートは？",
    "options": ["A. 21", "B. 22", "C. 23", "D. 25"],
    "correct": 2,
    "explanation": "Telnetはポート23をデフォルトで使用します。暗号化されないため、現在はSSH（ポート22）が推奨されます。"
  },
  {
    "id": 282,
    "question": "PostgreSQLのデフォルトポート番号は？",
    "options": ["A. 3306", "B. 5432", "C. 27017", "D. 6379"],
    "correct": 1,
    "explanation": "PostgreSQLはデフォルトでポート5432を使用します。"
  },
  {
    "id": 283,
    "question": "Redisのデフォルトポート番号は？",
    "options": ["A. 3306", "B. 5432", "C. 6379", "D. 27017"],
    "correct": 2,
    "explanation": "Redisはデフォルトでポート6379を使用します。"
  },
  {
    "id": 284,
    "question": "DNSの逆引き（リバースDNS）とは？",
    "options": [
      "A. ドメイン名からIPアドレスを求める",
      "B. IPアドレスからドメイン名を求める",
      "C. DNSキャッシュを削除する",
      "D. DNSサーバーを変更する"
    ],
    "correct": 1,
    "explanation": "逆引きDNSはIPアドレスからドメイン名を求める名前解決で、PTRレコードが使われます。"
  },
  {
    "id": 285,
    "question": "DNSのNSレコードの役割は？",
    "options": [
      "A. メールサーバーの指定",
      "B. ドメインの権威DNSサーバーの指定",
      "C. IPアドレスの指定",
      "D. テキスト情報の格納"
    ],
    "correct": 1,
    "explanation": "NSレコード（Name Server）はそのドメインを管理する権威DNSサーバーを指定します。"
  },
  {
    "id": 286,
    "question": "DNSSECの目的は？",
    "options": [
      "A. DNS応答の暗号化",
      "B. DNS応答の真正性と完全性の検証",
      "C. DNSの高速化",
      "D. DNSキャッシュの拡大"
    ],
    "correct": 1,
    "explanation": "DNSSECはデジタル署名によりDNS応答が改ざんされていないことを検証するセキュリティ拡張です。"
  },
  {
    "id": 287,
    "question": "DHCPリレーエージェントの役割は？",
    "options": [
      "A. DHCPサーバーの代替",
      "B. 異なるサブネットのDHCPリクエストを中継",
      "C. IPアドレスの暗号化",
      "D. DNSの代替"
    ],
    "correct": 1,
    "explanation": "DHCPリレーエージェントは別のサブネットにあるDHCPサーバーにブロードキャストリクエストを中継します。"
  },
  {
    "id": 288,
    "question": "APIPA（Automatic Private IP Addressing）でアドレスが割り当てられる範囲は？",
    "options": [
      "A. 10.0.0.0/8",
      "B. 169.254.0.0/16",
      "C. 172.16.0.0/12",
      "D. 192.168.0.0/16"
    ],
    "correct": 1,
    "explanation": "APIAPAはDHCPサーバーに接続できない場合に169.254.0.0/16の範囲から自動的にIPを割り当てます。"
  },
  {
    "id": 289,
    "question": "ポートフォワーディングの用途は？",
    "options": [
      "A. NATの無効化",
      "B. 外部からNAT内部のサーバーにアクセスさせる",
      "C. ポート番号の暗号化",
      "D. ポート番号の削除"
    ],
    "correct": 1,
    "explanation": "ポートフォワーディングはNATの特定ポートへの外部からの接続を内部の指定IPに転送する設定です。"
  },
  {
    "id": 290,
    "question": "EIGRPルーティングプロトコルの特徴は？",
    "options": [
      "A. オープン標準プロトコル",
      "B. Cisco独自のハイブリッド型ルーティングプロトコル",
      "C. リンクステート型のみ",
      "D. BGPの一種"
    ],
    "correct": 1,
    "explanation": "EIGRPはCiscoが開発したハイブリッド型（ディスタンスベクタとリンクステートの両方の特徴）プロトコルです。"
  },
  {
    "id": 291,
    "question": "RIPの最大ホップ数は？",
    "options": ["A. 8", "B. 15", "C. 32", "D. 255"],
    "correct": 1,
    "explanation": "RIPの最大ホップ数は15で、ホップ数16は到達不能を意味します。大規模ネットワークには不向きです。"
  },
  {
    "id": 292,
    "question": "BGPのAS_PATHアトリビュートの用途は？",
    "options": [
      "A. 帯域幅を示す",
      "B. 経由するAS番号のリストでルーティングループを防止",
      "C. 暗号化キーの配布",
      "D. IPアドレスの割り当て"
    ],
    "correct": 1,
    "explanation": "AS_PATHは宛先に到達するまでに経由するAS番号のリストで、ループ防止と経路選択に使われます。"
  },
  {
    "id": 293,
    "question": "BGPがTCP のポート何番で動作する？",
    "options": ["A. 80", "B. 161", "C. 179", "D. 443"],
    "correct": 2,
    "explanation": "BGPはTCPポート179を使用してピア間の接続を確立し、経路情報を交換します。"
  },
  {
    "id": 294,
    "question": "HTTPのべき等性（Idempotent）があるメソッドは？",
    "options": ["A. POST", "B. GET", "C. CONNECT", "D. なし"],
    "correct": 1,
    "explanation": "GETは何度実行しても同じ結果を返すべき等なメソッドです。PUT、DELETEもべき等です。POSTは非べき等。"
  },
  {
    "id": 295,
    "question": "HTTPの「Cookie」の主な用途は？",
    "options": [
      "A. 帯域幅の制御",
      "B. セッション管理やユーザー情報の保持",
      "C. DNS解決の高速化",
      "D. SSL証明書の格納"
    ],
    "correct": 1,
    "explanation": "CookieはWebサーバーがクライアントに保存させる小さなデータで、セッション管理や認証情報の保持に使われます。"
  },
  {
    "id": 296,
    "question": "CDNのパージ（Purge）とは？",
    "options": [
      "A. コンテンツの追加",
      "B. キャッシュされたコンテンツの強制削除",
      "C. エッジサーバーの追加",
      "D. SSL証明書の更新"
    ],
    "correct": 1,
    "explanation": "パージはCDNのエッジサーバーにキャッシュされたコンテンツを強制的に削除し、最新版に更新する操作です。"
  },
  {
    "id": 297,
    "question": "Anycastの特徴は？",
    "options": [
      "A. 全ノードに同報",
      "B. 最も近い1つのノードにルーティング",
      "C. 特定のグループに送信",
      "D. ランダムなノードに送信"
    ],
    "correct": 1,
    "explanation": "Anycastは同じIPアドレスを複数のサーバーに割り当て、最もネットワーク的に近いサーバーにルーティングします。CDNでよく使われます。"
  },
  {
    "id": 298,
    "question": "IPv6のリンクローカルアドレスのプレフィックスは？",
    "options": ["A. 2001::", "B. fe80::", "C. ff00::", "D. ::1"],
    "correct": 1,
    "explanation": "IPv6のリンクローカルアドレスはfe80::/10プレフィックスを持ち、同一リンク内のみで使用されます。"
  },
  {
    "id": 299,
    "question": "サブネットマスク /28 のネットワークで使用可能なホスト数は？",
    "options": ["A. 14", "B. 16", "C. 30", "D. 32"],
    "correct": 0,
    "explanation": "ホスト部は4ビット→2^4=16個。ネットワークとブロードキャストを引いて14個使用可能です。"
  },
  {
    "id": 300,
    "question": "OpenVPNの特徴は？",
    "options": [
      "A. 非暗号化VPN",
      "B. オープンソースでSSL/TLSベースのVPN",
      "C. Cisco専用",
      "D. IPv4のみ対応"
    ],
    "correct": 1,
    "explanation": "OpenVPNはオープンソースのVPNソリューションで、SSL/TLSを使用した安全な通信を提供します。"
  },
  {
    "id": 301,
    "question": "プロキシのキャッシュ機能の利点は？",
    "options": [
      "A. セキュリティの低下",
      "B. 同じリクエストへの応答を高速化し帯域幅を節約",
      "C. IPアドレスの自動割り当て",
      "D. ルーティングの最適化"
    ],
    "correct": 1,
    "explanation": "プロキシはよくアクセスされるコンテンツをキャッシュし、同じリクエストに高速に応答して帯域幅を節約します。"
  },
  {
    "id": 302,
    "question": "DNS over HTTPS (DoH) の目的は？",
    "options": [
      "A. DNSの高速化",
      "B. DNS通信の暗号化によるプライバシー保護",
      "C. DNSキャッシュの削除",
      "D. DNSサーバーの負荷分散"
    ],
    "correct": 1,
    "explanation": "DoHはDNSクエリをHTTPS上で暗号化して送信し、第三者による盗聴や改ざんを防ぎます。"
  },
  {
    "id": 303,
    "question": "GSLB（Global Server Load Balancing）とは？",
    "options": [
      "A. 単一データセンター内の負荷分散",
      "B. 地理的に分散したデータセンター間の負荷分散",
      "C. CPUの負荷分散",
      "D. メモリの負荷分散"
    ],
    "correct": 1,
    "explanation": "GSLBはDNSベースで地理的に分散した複数のデータセンター間でトラフィックを最適に分散します。"
  },
  {
    "id": 304,
    "question": "HAProxy とは何ですか？",
    "options": [
      "A. DNSサーバー",
      "B. 高性能なオープンソースのロードバランサ/リバースプロキシ",
      "C. データベースソフトウェア",
      "D. VPNクライアント"
    ],
    "correct": 1,
    "explanation": "HAProxyはTCP/HTTPの負荷分散に使われる高性能なオープンソースのロードバランサ/リバースプロキシです。"
  },
  {
    "id": 305,
    "question": "ヒープソートの時間計算量は？",
    "options": [
      "A. 常にO(n)",
      "B. 常にO(n log n)",
      "C. 平均O(n^2)",
      "D. 常にO(n^2)"
    ],
    "correct": 1,
    "explanation": "ヒープソートは最悪・平均ともにO(n log n)で動作し、追加メモリもO(1)のインプレースソートです。"
  },
  {
    "id": 306,
    "question": "計数ソート（Counting Sort）の特徴は？",
    "options": [
      "A. 比較ベースのソート",
      "B. 非比較ソートで特定条件下でO(n)が可能",
      "C. 常にO(n log n)",
      "D. メモリを使わない"
    ],
    "correct": 1,
    "explanation": "計数ソートは比較を行わず、値の出現回数をカウントしてソートするためO(n+k)で動作します。"
  },
  {
    "id": 307,
    "question": "IPv6のマルチキャストアドレスのプレフィックスは？",
    "options": ["A. fe80::", "B. ff00::", "C. 2001::", "D. fc00::"],
    "correct": 1,
    "explanation": "IPv6のマルチキャストアドレスはff00::/8プレフィックスで始まります。"
  },
  {
    "id": 308,
    "question": "TCPの「Nagleアルゴリズム」の目的は？",
    "options": [
      "A. 暗号化の高速化",
      "B. 小さなパケットをまとめて送信効率を上げる",
      "C. パケットの暗号化",
      "D. ルーティングの最適化"
    ],
    "correct": 1,
    "explanation": "Nagleアルゴリズムは小さなTCPセグメントをまとめて送信し、ネットワークの効率を向上させます。"
  },
  {
    "id": 309,
    "question": "HTTPのKeep-Aliveの目的は？",
    "options": [
      "A. セキュリティ強化",
      "B. 1つのTCP接続で複数のリクエストを処理",
      "C. 暗号化",
      "D. IPアドレスの固定"
    ],
    "correct": 1,
    "explanation": "Keep-Aliveは1つのTCP接続を再利用して複数のHTTPリクエスト/レスポンスを処理し、接続確立のオーバーヘッドを削減します。"
  },
  {
    "id": 310,
    "question": "VLAN（Virtual LAN）の目的は？",
    "options": [
      "A. 物理的にケーブルを分離する",
      "B. 物理ネットワークを論理的に複数に分割する",
      "C. IPアドレスを暗号化する",
      "D. 無線LANの範囲を拡大する"
    ],
    "correct": 1,
    "explanation": "VLANはスイッチ上で物理ネットワークを論理的に複数のブロードキャストドメインに分割する技術です。"
  },
  {
    "id": 311,
    "question": "アムダールの法則が示すものは？",
    "options": [
      "A. メモリの容量限界",
      "B. 並列化による高速化の上限",
      "C. ネットワークの帯域限界",
      "D. CPUの消費電力限界"
    ],
    "correct": 1,
    "explanation": "アムダールの法則は、プログラムの並列化できない部分が、全体の高速化の上限を決めることを示します。"
  },
  {
    "id": 312,
    "question": "AVL木とは何ですか？",
    "options": [
      "A. 非平衡の二分探索木",
      "B. 高さが均衡した自己平衡二分探索木",
      "C. B木の一種",
      "D. ヒープの一種"
    ],
    "correct": 1,
    "explanation": "AVL木は各ノードの左右部分木の高さの差が1以下に維持される自己平衡二分探索木です。"
  },
  {
    "id": 313,
    "question": "グラフの「重み付きエッジ」とは？",
    "options": [
      "A. エッジに方向がある",
      "B. エッジにコスト・距離などの数値が付与されている",
      "C. エッジの色がある",
      "D. エッジが2本ある"
    ],
    "correct": 1,
    "explanation": "重み付きエッジは辺にコスト、距離、時間などの数値が割り当てられ、最短経路問題などで使われます。"
  },
  {
    "id": 314,
    "question": "STPプロトコル（Spanning Tree Protocol）の目的は？",
    "options": [
      "A. IPルーティングの最適化",
      "B. L2ネットワークのループ防止",
      "C. DNSの冗長化",
      "D. VPNの確立"
    ],
    "correct": 1,
    "explanation": "STPはスイッチネットワークで冗長経路によるブロードキャストストームなどのループを防止します。"
  },
  {
    "id": 315,
    "question": "QoS（Quality of Service）の目的は？",
    "options": [
      "A. ネットワーク帯域を減らす",
      "B. 特定のトラフィックに優先度を付けて品質を保証",
      "C. すべてのトラフィックを均等にする",
      "D. ネットワークを暗号化する"
    ],
    "correct": 1,
    "explanation": "QoSはネットワーク上のトラフィックに優先順位を設定し、音声やビデオなどの品質を保証する技術です。"
  },
  {
    "id": 316,
    "question": "SNMPの用途は？",
    "options": [
      "A. ファイル転送",
      "B. ネットワーク機器の監視と管理",
      "C. メール送信",
      "D. Webページの表示"
    ],
    "correct": 1,
    "explanation": "SNMP（Simple Network Management Protocol）はルータやスイッチなどのネットワーク機器を監視・管理するプロトコルです。"
  },
  {
    "id": 317,
    "question": "フレームリレーとATMの共通点は？",
    "options": [
      "A. 両方ともIP専用",
      "B. 両方ともパケットスイッチング技術",
      "C. 両方とも無線技術",
      "D. 両方とも最新技術"
    ],
    "correct": 1,
    "explanation": "フレームリレーもATMもパケット（セル）スイッチング技術で、WANでの通信に使われました。"
  },
  {
    "id": 318,
    "question": "mTLS（Mutual TLS）とは？",
    "options": [
      "A. サーバーのみが証明書を提示",
      "B. クライアントとサーバーの両方が証明書で相互認証",
      "C. TLSの旧バージョン",
      "D. 暗号化なしのTLS"
    ],
    "correct": 1,
    "explanation": "mTLSはクライアントとサーバーの両方がTLS証明書を提示して互いに認証し合う仕組みです。"
  },
  {
    "id": 319,
    "question": "SDN（Software-Defined Networking）の特徴は？",
    "options": [
      "A. すべてハードウェアで制御",
      "B. ネットワークの制御をソフトウェアで一元管理",
      "C. 各機器が独立して動作",
      "D. 物理ケーブルが不要"
    ],
    "correct": 1,
    "explanation": "SDNはネットワークの制御プレーン（制御機能）をデータプレーン（転送機能）から分離し、ソフトウェアで集中管理します。"
  },
  {
    "id": 320,
    "question": "A*アルゴリズムの特徴は？",
    "options": [
      "A. 無条件に最短経路を見つけるが遅い",
      "B. ヒューリスティック関数を使い効率的に最短経路を探索",
      "C. ランダムに経路を選ぶ",
      "D. 全通りを探索する"
    ],
    "correct": 1,
    "explanation": "A*はダイクストラ法にヒューリスティック（推定コスト）を加えて、探索範囲を絞りつつ最短経路を効率的に求めます。"
  },
  {
    "id": 321,
    "question": "クラスタリング（高可用性クラスタ）の目的は？",
    "options": [
      "A. ネットワーク帯域の拡張",
      "B. サーバー障害時のサービス継続",
      "C. IPアドレスの節約",
      "D. データの暗号化"
    ],
    "correct": 1,
    "explanation": "高可用性クラスタは複数のサーバーを連携させ、障害時に自動で予備サーバーに切り替えてサービスを継続します。"
  },
  {
    "id": 322,
    "question": "IPフラグメンテーションとは？",
    "options": [
      "A. IPアドレスの分割",
      "B. MTUを超えるパケットを複数の断片に分割",
      "C. IPアドレスの暗号化",
      "D. IPアドレスの変換"
    ],
    "correct": 1,
    "explanation": "IPフラグメンテーションはパケットが経路上のMTUより大きい場合に、複数のフラグメントに分割して送信する仕組みです。"
  },
  {
    "id": 323,
    "question": "GRE（Generic Routing Encapsulation）の用途は？",
    "options": [
      "A. DNSの高速化",
      "B. パケットをカプセル化してトンネルを作成",
      "C. メール配送",
      "D. ファイル転送"
    ],
    "correct": 1,
    "explanation": "GREはIPパケットを別のIPパケットにカプセル化してトンネルを作成するプロトコルです。"
  },
  {
    "id": 324,
    "question": "ネットワークのMTU Path Discoveryの目的は？",
    "options": [
      "A. 最大帯域を測定する",
      "B. 経路上の最小MTUを発見してフラグメンテーションを回避",
      "C. DNSサーバーを発見する",
      "D. ルータの台数を数える"
    ],
    "correct": 1,
    "explanation": "MTU Path Discoveryは通信経路上の最小MTUを特定し、送信元でパケットサイズを調整してフラグメンテーションを避けます。"
  },
  {
    "id": 325,
    "question": "ネットワークの「レイテンシ」と「スループット」の違いは？",
    "options": [
      "A. 同じ意味",
      "B. レイテンシは遅延時間、スループットは単位時間あたりのデータ転送量",
      "C. スループットは遅延時間、レイテンシはデータ転送量",
      "D. 両方ともデータ転送量を表す"
    ],
    "correct": 1,
    "explanation": "レイテンシはデータが到着するまでの遅延時間、スループットは単位時間あたりに転送できるデータ量です。"
  },
  {
    "id": 326,
    "question": "クヌース・モリス・プラット（KMP）アルゴリズムの用途は？",
    "options": [
      "A. ソート",
      "B. 文字列のパターンマッチング",
      "C. グラフ探索",
      "D. 暗号化"
    ],
    "correct": 1,
    "explanation": "KMPアルゴリズムはテキスト内でパターン文字列を効率的に検索するO(n+m)のアルゴリズムです。"
  },
  {
    "id": 327,
    "question": "分割統治法（Divide and Conquer）の基本戦略は？",
    "options": [
      "A. 問題をランダムに分ける",
      "B. 問題を小さな部分に分割し、個別に解いてマージする",
      "C. 全ての組み合わせを試す",
      "D. 最も簡単な部分だけ解く"
    ],
    "correct": 1,
    "explanation": "分割統治法は問題を小さな部分問題に分割し、再帰的に解き、結果をマージして全体の解を得ます。"
  },
  {
    "id": 328,
    "question": "ブルームフィルタの特徴は？",
    "options": [
      "A. 偽陽性がないが偽陰性がある",
      "B. 偽陽性はあるが偽陰性がない確率的データ構造",
      "C. 完全に正確なデータ構造",
      "D. データのソートに使う"
    ],
    "correct": 1,
    "explanation": "ブルームフィルタは「含まれていない」は確実ですが、「含まれている」は誤検出の可能性がある空間効率の良いデータ構造です。"
  },
  {
    "id": 329,
    "question": "マルチキャストとブロードキャストの違いは？",
    "options": [
      "A. 同じもの",
      "B. マルチキャストは特定のグループ、ブロードキャストは全体に送信",
      "C. ブロードキャストは特定のグループに送信",
      "D. マルチキャストは1対1の通信"
    ],
    "correct": 1,
    "explanation": "マルチキャストは特定のグループのメンバーにのみ送信、ブロードキャストは同一ネットワーク内の全ホストに送信します。"
  },
  {
    "id": 330,
    "question": "SSL/TLS handshakeの最初のステップは？",
    "options": [
      "A. 証明書の検証",
      "B. Client Hello",
      "C. Key Exchange",
      "D. Server Hello"
    ],
    "correct": 1,
    "explanation": "SSL/TLSハンドシェイクはクライアントがサポートする暗号スイートなどを含むClient Helloメッセージから始まります。"
  },

  {
    "id": 331,
    "question": "Linuxでカレントディレクトリのファイル一覧を表示するコマンドは？",
    "options": ["A. dir", "B. ls", "C. list", "D. show"],
    "correct": 1,
    "explanation": "lsコマンドはカレントディレクトリのファイルやディレクトリの一覧を表示します。"
  },
  {
    "id": 332,
    "question": "Linuxでファイルの内容を表示するコマンドは？",
    "options": ["A. cat", "B. echo", "C. print", "D. type"],
    "correct": 0,
    "explanation": "catコマンドはファイルの内容を標準出力に表示します。concatenate（連結）の略です。"
  },
  {
    "id": 333,
    "question": "Linuxでディレクトリを再帰的にコピーするコマンドは？",
    "options": ["A. cp -a", "B. cp -r", "C. copy -r", "D. mv -r"],
    "correct": 1,
    "explanation": "cp -rはディレクトリとその中身を再帰的にコピーします。-rはrecursiveの略です。"
  },
  {
    "id": 334,
    "question": "Linuxで現在のディレクトリパスを表示するコマンドは？",
    "options": ["A. cd", "B. pwd", "C. path", "D. where"],
    "correct": 1,
    "explanation": "pwd（Print Working Directory）は現在の作業ディレクトリのフルパスを表示します。"
  },
  {
    "id": 335,
    "question": "Linuxでファイルを検索するコマンドは？",
    "options": ["A. search", "B. locate", "C. find", "D. lookup"],
    "correct": 2,
    "explanation": "findコマンドはディレクトリツリーを再帰的に探索してファイルを検索します。条件指定も豊富です。"
  },
  {
    "id": 336,
    "question": "grepコマンドの主な用途は？",
    "options": [
      "A. ファイルの圧縮",
      "B. テキストのパターン検索",
      "C. ファイルの移動",
      "D. ディスクの管理"
    ],
    "correct": 1,
    "explanation": "grepはファイルやパイプの中からパターン（正規表現）にマッチする行を検索・表示します。"
  },
  {
    "id": 337,
    "question": "Linuxでファイルの先頭10行を表示するコマンドは？",
    "options": ["A. tail", "B. head", "C. top", "D. first"],
    "correct": 1,
    "explanation": "headコマンドはファイルの先頭部分（デフォルト10行）を表示します。"
  },
  {
    "id": 338,
    "question": "Linuxでファイルの末尾をリアルタイムに監視するコマンドは？",
    "options": ["A. head -f", "B. tail -f", "C. watch", "D. monitor"],
    "correct": 1,
    "explanation": "tail -fはファイルの末尾を監視し、追記されたデータをリアルタイムに表示します。ログ監視に便利です。"
  },
  {
    "id": 339,
    "question": "Linuxでテキストを置換するコマンドは？",
    "options": ["A. replace", "B. sed", "C. swap", "D. change"],
    "correct": 1,
    "explanation": "sed（Stream Editor）はテキストストリームに対して置換・削除などの編集を行うコマンドです。"
  },
  {
    "id": 340,
    "question": "awkコマンドの主な用途は？",
    "options": [
      "A. ファイルの圧縮",
      "B. テキストのフィールド処理・レポート生成",
      "C. ネットワーク設定",
      "D. ユーザー管理"
    ],
    "correct": 1,
    "explanation": "awkはテキストをフィールドごとに分割して処理するパターンスキャニング・プロセッシング言語です。"
  },
  {
    "id": 341,
    "question": "Linuxでファイルやディレクトリの所有者を変更するコマンドは？",
    "options": ["A. chmod", "B. chown", "C. chgrp", "D. chuser"],
    "correct": 1,
    "explanation": "chown（Change Owner）はファイルやディレクトリの所有者とグループを変更します。"
  },
  {
    "id": 342,
    "question": "Linuxでディスクの使用量を確認するコマンドは？",
    "options": ["A. du", "B. df", "C. disk", "D. usage"],
    "correct": 1,
    "explanation": "df（Disk Free）はファイルシステムのディスク使用状況とマウント情報を表示します。duはディレクトリごとの使用量です。"
  },
  {
    "id": 343,
    "question": "tarコマンドでgzip圧縮アーカイブを作成するオプションは？",
    "options": ["A. tar -xvf", "B. tar -czvf", "C. tar -tvf", "D. tar -dvf"],
    "correct": 1,
    "explanation": "tar -czvfはcreate（作成）、gzip（圧縮）、verbose（詳細表示）、file（ファイル指定）の組み合わせです。"
  },
  {
    "id": 344,
    "question": "Linuxでプロセスの一覧を表示するコマンドは？",
    "options": ["A. ls -p", "B. ps", "C. proc", "D. task"],
    "correct": 1,
    "explanation": "ps（Process Status）は現在実行中のプロセスの情報を表示します。ps auxで全プロセスを表示。"
  },
  {
    "id": 345,
    "question": "リダイレクト「>」と「>>」の違いは？",
    "options": [
      "A. 同じ動作",
      "B. >は上書き、>>は追記",
      "C. >>は上書き、>は追記",
      "D. >は標準エラー、>>は標準出力"
    ],
    "correct": 1,
    "explanation": ">はファイルを上書きして出力を書き込み、>>は既存ファイルの末尾に追記します。"
  },
  {
    "id": 346,
    "question": "パイプ「|」の役割は？",
    "options": [
      "A. ファイルに書き込む",
      "B. 前のコマンドの出力を次のコマンドの入力に渡す",
      "C. コマンドを並列実行",
      "D. エラーを無視する"
    ],
    "correct": 1,
    "explanation": "パイプ|は左のコマンドの標準出力を右のコマンドの標準入力に接続します。"
  },
  {
    "id": 347,
    "question": "xargsコマンドの用途は？",
    "options": [
      "A. ファイルの圧縮",
      "B. 標準入力からコマンドライン引数を構築して実行",
      "C. 環境変数の設定",
      "D. ネットワーク通信"
    ],
    "correct": 1,
    "explanation": "xargsは標準入力から読み取ったデータを引数として、指定したコマンドを実行します。"
  },
  {
    "id": 348,
    "question": "wc コマンドで行数を表示するオプションは？",
    "options": ["A. wc -w", "B. wc -l", "C. wc -c", "D. wc -m"],
    "correct": 1,
    "explanation": "wc -lはファイルの行数を表示します。-wは単語数、-cはバイト数です。"
  },
  {
    "id": 349,
    "question": "sortコマンドで数値順にソートするオプションは？",
    "options": ["A. sort -a", "B. sort -n", "C. sort -r", "D. sort -d"],
    "correct": 1,
    "explanation": "sort -nは数値順（numerical）にソートします。-rは逆順、デフォルトは辞書順です。"
  },
  {
    "id": 350,
    "question": "uniqコマンドの前提条件は？",
    "options": [
      "A. ファイルがバイナリであること",
      "B. 入力がソート済みであること",
      "C. root権限があること",
      "D. ファイルが小さいこと"
    ],
    "correct": 1,
    "explanation": "uniqは隣接する重複行を除去するため、事前にsortで並べ替えておく必要があります。"
  },
  {
    "id": 351,
    "question": "systemctlでサービスを起動するコマンドは？",
    "options": [
      "A. systemctl begin nginx",
      "B. systemctl start nginx",
      "C. systemctl run nginx",
      "D. systemctl launch nginx"
    ],
    "correct": 1,
    "explanation": "systemctl start <サービス名>でsystemdが管理するサービスを起動します。"
  },
  {
    "id": 352,
    "question": "systemctlでOS起動時にサービスを自動起動させるには？",
    "options": [
      "A. systemctl auto nginx",
      "B. systemctl enable nginx",
      "C. systemctl boot nginx",
      "D. systemctl startup nginx"
    ],
    "correct": 1,
    "explanation": "systemctl enableはOS起動時にサービスが自動的に開始されるよう設定します。"
  },
  {
    "id": 353,
    "question": "systemctlでサービスの状態を確認するコマンドは？",
    "options": [
      "A. systemctl info nginx",
      "B. systemctl status nginx",
      "C. systemctl check nginx",
      "D. systemctl show nginx"
    ],
    "correct": 1,
    "explanation": "systemctl statusはサービスの稼働状態、PID、最近のログなどの詳細情報を表示します。"
  },
  {
    "id": 354,
    "question": "systemdのユニットファイルのデフォルトの配置場所は？",
    "options": [
      "A. /etc/init.d/",
      "B. /etc/systemd/system/",
      "C. /var/systemd/",
      "D. /opt/systemd/"
    ],
    "correct": 1,
    "explanation": "/etc/systemd/system/は管理者がカスタマイズしたユニットファイルを配置する場所です。"
  },
  {
    "id": 355,
    "question": "systemdでサービスを再起動するコマンドは？",
    "options": [
      "A. systemctl reboot nginx",
      "B. systemctl restart nginx",
      "C. systemctl reset nginx",
      "D. systemctl refresh nginx"
    ],
    "correct": 1,
    "explanation": "systemctl restartはサービスを停止してから再度起動します。reloadは設定再読み込みのみ。"
  },
  {
    "id": 356,
    "question": "systemctlでサービスの自動起動を無効化するには？",
    "options": [
      "A. systemctl stop nginx",
      "B. systemctl disable nginx",
      "C. systemctl remove nginx",
      "D. systemctl delete nginx"
    ],
    "correct": 1,
    "explanation": "systemctl disableはOS起動時のサービス自動起動を無効化します。stopは今すぐ停止。"
  },
  {
    "id": 357,
    "question": "journalctlの役割は？",
    "options": [
      "A. ネットワーク設定",
      "B. systemdのジャーナル（ログ）を閲覧",
      "C. ユーザー管理",
      "D. ディスク管理"
    ],
    "correct": 1,
    "explanation": "journalctlはsystemdが管理するジャーナル（ログ）を閲覧・検索するコマンドです。"
  },
  {
    "id": 358,
    "question": "cronで毎日午前3時にタスクを実行する設定は？",
    "options": ["A. 3 * * * *", "B. 0 3 * * *", "C. * 3 * * *", "D. 0 0 3 * *"],
    "correct": 1,
    "explanation": "cron形式は「分 時 日 月 曜日」の順。0 3 * * *は毎日3時0分に実行です。"
  },
  {
    "id": 359,
    "question": "cronで毎週月曜日の午前9時に実行する設定は？",
    "options": ["A. 0 9 * * 1", "B. 9 0 * * 1", "C. 0 9 1 * *", "D. 0 9 * * 7"],
    "correct": 0,
    "explanation": "0 9 * * 1は毎週月曜（曜日1）の9時0分に実行。曜日は0=日、1=月...6=土。"
  },
  {
    "id": 360,
    "question": "crontab -e の役割は？",
    "options": [
      "A. cronジョブの一覧表示",
      "B. cronジョブの編集",
      "C. cronジョブの削除",
      "D. cronサービスの再起動"
    ],
    "correct": 1,
    "explanation": "crontab -eは現在のユーザーのcronテーブルをエディタで編集するコマンドです。-lは一覧表示。"
  },
  {
    "id": 361,
    "question": "cronで5分ごとにタスクを実行する設定は？",
    "options": [
      "A. 5 * * * *",
      "B. */5 * * * *",
      "C. 0 */5 * * *",
      "D. * 5 * * *"
    ],
    "correct": 1,
    "explanation": "*/5 * * * *は5分ごと（0,5,10,15...分）に実行されます。*/nはn間隔の意味。"
  },
  {
    "id": 362,
    "question": "cron以外のタスクスケジューラで、1回限りのジョブ実行に使うコマンドは？",
    "options": ["A. once", "B. at", "C. schedule", "D. timer"],
    "correct": 1,
    "explanation": "atコマンドは指定した日時に1回だけコマンドを実行するジョブスケジューラです。"
  },
  {
    "id": 363,
    "question": "systemdのタイマーユニット（.timer）はcronの代替として何ができる？",
    "options": [
      "A. ネットワーク監視のみ",
      "B. 定期的なタスク実行とより柔軟なスケジューリング",
      "C. ファイルの暗号化",
      "D. ユーザーの認証"
    ],
    "correct": 1,
    "explanation": "systemdタイマーはcronと同様の定期実行に加え、ブート後の経過時間指定やログ管理の統合が可能です。"
  },
  {
    "id": 364,
    "question": "Linuxのパーミッション「rwxr-xr--」を数値で表すと？",
    "options": ["A. 755", "B. 754", "C. 644", "D. 744"],
    "correct": 1,
    "explanation": "rwx=7, r-x=5, r--=4なので754です。r=4, w=2, x=1で計算します。"
  },
  {
    "id": 365,
    "question": "chmod 755 の意味は？",
    "options": [
      "A. 所有者：読み書き、グループ：読み、その他：なし",
      "B. 所有者：全権限、グループ：読み実行、その他：読み実行",
      "C. 全員に全権限",
      "D. 所有者のみ読み書き"
    ],
    "correct": 1,
    "explanation": "755はオーナーにrwx(7)、グループにr-x(5)、その他にr-x(5)を付与します。"
  },
  {
    "id": 366,
    "question": "SUIDビットが設定されたファイルを実行するとどうなる？",
    "options": [
      "A. 実行が拒否される",
      "B. ファイル所有者の権限で実行される",
      "C. root権限で実行される",
      "D. グループの権限で実行される"
    ],
    "correct": 1,
    "explanation": "SUID（Set User ID）が設定されたファイルは、実行者に関わらずファイル所有者の権限で実行されます。"
  },
  {
    "id": 367,
    "question": "スティッキービットの主な用途は？",
    "options": [
      "A. ファイルの暗号化",
      "B. 共有ディレクトリで自分のファイルのみ削除可能にする",
      "C. 実行速度の向上",
      "D. ファイルの圧縮"
    ],
    "correct": 1,
    "explanation": "スティッキービットが設定されたディレクトリでは、ファイルの所有者のみがそのファイルを削除できます。/tmpが代表例です。"
  },
  {
    "id": 368,
    "question": "umask 022 の場合、新規ファイルのデフォルトパーミッションは？",
    "options": ["A. 777", "B. 644", "C. 755", "D. 600"],
    "correct": 1,
    "explanation": "ファイルのデフォルト666からumask 022を引くと644（rw-r--r--）になります。"
  },
  {
    "id": 369,
    "question": "umask 022 の場合、新規ディレクトリのデフォルトパーミッションは？",
    "options": ["A. 644", "B. 755", "C. 777", "D. 700"],
    "correct": 1,
    "explanation": "ディレクトリのデフォルト777からumask 022を引くと755（rwxr-xr-x）になります。"
  },
  {
    "id": 370,
    "question": "chmodで再帰的にパーミッションを変更するオプションは？",
    "options": ["A. chmod -a", "B. chmod -R", "C. chmod -f", "D. chmod -v"],
    "correct": 1,
    "explanation": "chmod -Rはディレクトリとその中身全てに再帰的にパーミッションを変更します。"
  },
  {
    "id": 371,
    "question": "Linux ACL（Access Control List）を設定するコマンドは？",
    "options": ["A. chmod", "B. setfacl", "C. chacl", "D. acl"],
    "correct": 1,
    "explanation": "setfaclはファイルやディレクトリにACL（より詳細なアクセス権限）を設定するコマンドです。"
  },
  {
    "id": 372,
    "question": "Linuxのデフォルトのシェルとして最も一般的なのは？",
    "options": ["A. csh", "B. bash", "C. zsh", "D. fish"],
    "correct": 1,
    "explanation": "bash（Bourne Again Shell）は多くのLinuxディストリビューションでデフォルトシェルとして採用されています。"
  },
  {
    "id": 373,
    "question": "シェルスクリプトの先頭に書く「#!/bin/bash」は何と呼ばれる？",
    "options": [
      "A. ヘッダ",
      "B. シバン（shebang）",
      "C. コメント",
      "D. マクロ"
    ],
    "correct": 1,
    "explanation": "シバン（#!）はスクリプトを実行するインタプリタを指定する記法です。"
  },
  {
    "id": 374,
    "question": "bashで環境変数を設定して子プロセスにも引き継ぐコマンドは？",
    "options": ["A. set", "B. export", "C. env", "D. local"],
    "correct": 1,
    "explanation": "exportは環境変数をエクスポートし、子プロセスにも値を引き継ぎます。"
  },
  {
    "id": 375,
    "question": "bashの$?は何を表す？",
    "options": [
      "A. 現在のPID",
      "B. 直前のコマンドの終了ステータス",
      "C. 引数の数",
      "D. 現在のシェル名"
    ],
    "correct": 1,
    "explanation": "$?は直前に実行したコマンドの終了ステータス（0=成功、それ以外=エラー）を表します。"
  },
  {
    "id": 376,
    "question": "bashで条件分岐に使うキーワードは？",
    "options": [
      "A. switch...case",
      "B. if...then...fi",
      "C. when...do...done",
      "D. check...end"
    ],
    "correct": 1,
    "explanation": "bashではif 条件; then コマンド; fiの構文で条件分岐を行います。"
  },
  {
    "id": 377,
    "question": "bashのforループの構文は？",
    "options": [
      "A. for i in list; do ... done",
      "B. for (i=0; i<n; i++) { }",
      "C. foreach i list end",
      "D. loop i in list end"
    ],
    "correct": 0,
    "explanation": "bashのforループは「for 変数 in リスト; do コマンド; done」の構文です。"
  },
  {
    "id": 378,
    "question": "bashで「&&」演算子の意味は？",
    "options": [
      "A. バックグラウンド実行",
      "B. 前のコマンドが成功したら次を実行",
      "C. 前のコマンドが失敗したら次を実行",
      "D. 両方同時に実行"
    ],
    "correct": 1,
    "explanation": "&&は論理AND。左のコマンドが終了ステータス0（成功）の場合のみ右のコマンドを実行します。"
  },
  {
    "id": 379,
    "question": "bashで「||」演算子の意味は？",
    "options": [
      "A. パイプ",
      "B. 前のコマンドが成功したら次を実行",
      "C. 前のコマンドが失敗したら次を実行",
      "D. ファイルに追記"
    ],
    "correct": 2,
    "explanation": "||は論理OR。左のコマンドが失敗（非0）の場合のみ右のコマンドを実行します。"
  },
  {
    "id": 380,
    "question": "bashのソースコマンド（source / .）の用途は？",
    "options": [
      "A. ファイルをコピーする",
      "B. 現在のシェル環境でスクリプトを実行する",
      "C. ファイルをダウンロードする",
      "D. ファイルを削除する"
    ],
    "correct": 1,
    "explanation": "sourceはサブシェルを作らず、現在のシェル環境でスクリプトを実行するため、変数の変更が現在のシェルに反映されます。"
  },
  {
    "id": 381,
    "question": "bashのヒアドキュメント（<<EOF）の用途は？",
    "options": [
      "A. ファイルの暗号化",
      "B. 複数行のテキストをコマンドの標準入力に渡す",
      "C. ファイルの圧縮",
      "D. バックアップの作成"
    ],
    "correct": 1,
    "explanation": "ヒアドキュメントは<<区切り文字で始まり、複数行のテキストをコマンドの標準入力として渡します。"
  },
  {
    "id": 382,
    "question": "Linuxでプロセスを強制終了するコマンドは？",
    "options": ["A. stop", "B. kill -9", "C. end", "D. close"],
    "correct": 1,
    "explanation": "kill -9（SIGKILL）はプロセスを強制的に終了させます。プロセスはこのシグナルを無視できません。"
  },
  {
    "id": 383,
    "question": "フォアグラウンドプロセスをバックグラウンドに移すには？",
    "options": [
      "A. Ctrl+Z で停止してから bg",
      "B. Ctrl+C で停止してから bg",
      "C. Ctrl+D で停止してから bg",
      "D. &を後ろに付ける"
    ],
    "correct": 0,
    "explanation": "Ctrl+Zでプロセスを一時停止（SIGTSTP）し、bgコマンドでバックグラウンドで再開します。"
  },
  {
    "id": 384,
    "question": "コマンドの末尾に「&」を付けるとどうなる？",
    "options": [
      "A. root権限で実行",
      "B. バックグラウンドで実行",
      "C. エラーを無視",
      "D. 前のコマンドと同時実行"
    ],
    "correct": 1,
    "explanation": "&をコマンドの末尾に付けると、そのコマンドはバックグラウンドプロセスとして実行されます。"
  },
  {
    "id": 385,
    "question": "nohupコマンドの用途は？",
    "options": [
      "A. プロセスの優先度変更",
      "B. ログアウト後もプロセスを継続実行",
      "C. プロセスの一時停止",
      "D. プロセスの監視"
    ],
    "correct": 1,
    "explanation": "nohupはHUPシグナル（ログアウト時に送信）を無視してプロセスを実行し、端末切断後も処理を継続します。"
  },
  {
    "id": 386,
    "question": "topコマンドで表示される情報は？",
    "options": [
      "A. ファイル一覧",
      "B. リアルタイムのプロセスとシステムリソース状況",
      "C. ネットワーク接続一覧",
      "D. ユーザー一覧"
    ],
    "correct": 1,
    "explanation": "topはCPU使用率、メモリ使用量、実行中プロセスなどをリアルタイムに表示するシステムモニターです。"
  },
  {
    "id": 387,
    "question": "htopとtopの違いは？",
    "options": [
      "A. 機能は同じ",
      "B. htopはカラー表示・マウス操作・スクロール対応のtop改良版",
      "C. htopはネットワーク専用",
      "D. topの方が多機能"
    ],
    "correct": 1,
    "explanation": "htopはtopの高機能版で、カラー表示、マウス操作、プロセスツリー表示などの機能が追加されています。"
  },
  {
    "id": 388,
    "question": "psコマンドで全プロセスを詳細表示するオプションは？",
    "options": ["A. ps -a", "B. ps aux", "C. ps -p", "D. ps -e"],
    "correct": 1,
    "explanation": "ps auxは全ユーザーの全プロセスをBSD形式で詳細（CPU%、メモリ%、コマンド等）表示します。"
  },
  {
    "id": 389,
    "question": "Linuxのデーモンプロセスの特徴は？",
    "options": [
      "A. ユーザーと対話する",
      "B. バックグラウンドで常駐し、サービスを提供する",
      "C. 短時間で終了する",
      "D. GUI専用プロセス"
    ],
    "correct": 1,
    "explanation": "デーモンは端末を持たずバックグラウンドで常駐し、Webサーバーやログ収集などのサービスを提供するプロセスです。"
  },
  {
    "id": 390,
    "question": "ゾンビプロセスとは？",
    "options": [
      "A. CPU使用率が高いプロセス",
      "B. 終了したが親が終了状態を回収していないプロセス",
      "C. メモリリークのあるプロセス",
      "D. ネットワーク通信中のプロセス"
    ],
    "correct": 1,
    "explanation": "ゾンビプロセスは実行終了後も親プロセスがwait()で終了ステータスを回収するまでプロセステーブルに残り続けます。"
  },
  {
    "id": 391,
    "question": "orphanプロセス（孤児プロセス）とは？",
    "options": [
      "A. メモリを大量消費するプロセス",
      "B. 親プロセスが先に終了し、initに引き取られたプロセス",
      "C. root権限で動くプロセス",
      "D. 一時停止中のプロセス"
    ],
    "correct": 1,
    "explanation": "孤児プロセスは親が終了した後、init（PID 1）またはsystemdに引き取られて管理されます。"
  },
  {
    "id": 392,
    "question": "niceコマンドの用途は？",
    "options": [
      "A. プロセスの終了",
      "B. プロセスの優先度（nice値）を指定して実行",
      "C. プロセスの一覧表示",
      "D. プロセスのメモリ制限"
    ],
    "correct": 1,
    "explanation": "niceはプロセスの優先度（nice値：-20〜19、低いほど高優先度）を指定して起動するコマンドです。"
  },
  {
    "id": 393,
    "question": "SIGTERMとSIGKILLの違いは？",
    "options": [
      "A. 同じシグナル",
      "B. SIGTERMは正常終了要求で補足可能、SIGKILLは強制終了で補足不可",
      "C. SIGKILLは正常終了",
      "D. SIGTERMは補足不可"
    ],
    "correct": 1,
    "explanation": "SIGTERM（15）はプロセスに正常終了を要求し後処理が可能。SIGKILL（9）は強制終了でプロセスは処理できません。"
  },
  {
    "id": 394,
    "question": "SIGHUP（シグナル1）の典型的な使われ方は？",
    "options": [
      "A. プロセスの強制終了",
      "B. デーモンに設定ファイルの再読み込みを要求",
      "C. プロセスの一時停止",
      "D. メモリの解放"
    ],
    "correct": 1,
    "explanation": "SIGHUPは元々「端末切断」を意味しますが、デーモンプロセスでは設定ファイルの再読み込みに慣例的に使われます。"
  },
  {
    "id": 395,
    "question": "SIGINT（シグナル2）はどのキー操作で送信される？",
    "options": ["A. Ctrl+Z", "B. Ctrl+C", "C. Ctrl+D", "D. Ctrl+S"],
    "correct": 1,
    "explanation": "Ctrl+CはSIGINT（Interrupt）を送信し、フォアグラウンドプロセスに割り込んで終了を要求します。"
  },
  {
    "id": 396,
    "question": "SIGTSTP（シグナル20）はどのキー操作で送信される？",
    "options": ["A. Ctrl+C", "B. Ctrl+Z", "C. Ctrl+D", "D. Ctrl+S"],
    "correct": 1,
    "explanation": "Ctrl+ZはSIGTSTP（Terminal Stop）を送信し、プロセスを一時停止します。bgやfgで再開できます。"
  },
  {
    "id": 397,
    "question": "trapコマンド（bash）の用途は？",
    "options": [
      "A. ファイルの圧縮",
      "B. シグナルを受信した時の処理を定義",
      "C. ネットワークの監視",
      "D. ユーザーの認証"
    ],
    "correct": 1,
    "explanation": "trapはシェルスクリプト内でシグナル受信時のハンドラ（実行する処理）を定義するコマンドです。"
  },
  {
    "id": 398,
    "question": "SIGSEGVシグナルはいつ発生する？",
    "options": [
      "A. ファイルが見つからない時",
      "B. 不正なメモリアクセス（セグメンテーション違反）時",
      "C. ディスク容量不足時",
      "D. ネットワーク切断時"
    ],
    "correct": 1,
    "explanation": "SIGSEGV（Segmentation Fault）はプロセスがアクセス権のないメモリ領域にアクセスした時に発生します。"
  },
  {
    "id": 399,
    "question": "Linuxの基本的なファイルシステム構造で「/etc」の用途は？",
    "options": [
      "A. ユーザーのホームディレクトリ",
      "B. システムの設定ファイル",
      "C. 一時ファイル",
      "D. デバイスファイル"
    ],
    "correct": 1,
    "explanation": "/etcはシステム全体の設定ファイルやスクリプトが格納されるディレクトリです。"
  },
  {
    "id": 400,
    "question": "Linuxの「/var」ディレクトリの用途は？",
    "options": [
      "A. 実行可能ファイル",
      "B. 可変データ（ログ、スプール、キャッシュ等）",
      "C. カーネルソース",
      "D. ユーザー設定"
    ],
    "correct": 1,
    "explanation": "/varはログファイル、メールスプール、キャッシュなど、サイズが変動するデータを格納します。"
  },
  {
    "id": 401,
    "question": "Linuxの「/tmp」ディレクトリの特徴は？",
    "options": [
      "A. 永続的なデータ保存",
      "B. 再起動時に削除される一時ファイル用ディレクトリ",
      "C. カーネルモジュール",
      "D. システム設定"
    ],
    "correct": 1,
    "explanation": "/tmpは一時ファイル用で、多くのシステムでは再起動時に内容がクリアされます。"
  },
  {
    "id": 402,
    "question": "inodeが保持する情報に含まれないものは？",
    "options": [
      "A. ファイルサイズ",
      "B. パーミッション",
      "C. ファイル名",
      "D. 所有者"
    ],
    "correct": 2,
    "explanation": "inodeはファイルのメタデータ（サイズ、権限、所有者、タイムスタンプ等）を保持しますが、ファイル名はディレクトリエントリに格納されます。"
  },
  {
    "id": 403,
    "question": "ハードリンクとシンボリックリンクの違いは？",
    "options": [
      "A. 同じもの",
      "B. ハードリンクは同じinodeを共有、シンボリックリンクはパスへの参照",
      "C. シンボリックリンクの方が高速",
      "D. ハードリンクはディレクトリに使える"
    ],
    "correct": 1,
    "explanation": "ハードリンクは同じinodeを指す別の名前です。シンボリックリンクは別ファイルのパスを保持する参照です。"
  },
  {
    "id": 404,
    "question": "Linuxでファイルシステムをマウントするコマンドは？",
    "options": ["A. attach", "B. mount", "C. connect", "D. link"],
    "correct": 1,
    "explanation": "mountコマンドはファイルシステムをディレクトリツリーの特定のマウントポイントに接続します。"
  },
  {
    "id": 405,
    "question": "/etc/fstabの役割は？",
    "options": [
      "A. ユーザー一覧",
      "B. 起動時に自動マウントするファイルシステムの設定",
      "C. ネットワーク設定",
      "D. パッケージ管理"
    ],
    "correct": 1,
    "explanation": "fstabはシステム起動時に自動マウントするファイルシステム、マウントポイント、オプションを定義するファイルです。"
  },
  {
    "id": 406,
    "question": "ext4ファイルシステムの特徴は？",
    "options": [
      "A. Windowsのデフォルト",
      "B. ジャーナリング機能を持つLinuxの標準ファイルシステム",
      "C. ネットワーク専用ファイルシステム",
      "D. 読み取り専用ファイルシステム"
    ],
    "correct": 1,
    "explanation": "ext4はext3の後継で、ジャーナリング、大容量ファイル対応、エクステントなどの機能を持つLinux標準ファイルシステムです。"
  },
  {
    "id": 407,
    "question": "ジャーナリングファイルシステムの利点は？",
    "options": [
      "A. ファイルの暗号化",
      "B. 突然のシャットダウン後のデータ整合性の回復",
      "C. ファイルの圧縮",
      "D. ネットワーク共有"
    ],
    "correct": 1,
    "explanation": "ジャーナリングは書き込み操作をログに記録し、障害時にファイルシステムの一貫性を素早く回復できます。"
  },
  {
    "id": 408,
    "question": "XFSファイルシステムの特徴は？",
    "options": [
      "A. 小容量ディスク専用",
      "B. 高パフォーマンスで大容量ファイルに強い",
      "C. Windows専用",
      "D. 読み取り専用"
    ],
    "correct": 1,
    "explanation": "XFSはSGIが開発した高性能ファイルシステムで、大容量ファイルの入出力やスケーラビリティに優れます。RHEL系のデフォルト。"
  },
  {
    "id": 409,
    "question": "Btrfsの特徴として正しいものは？",
    "options": [
      "A. ジャーナリング非対応",
      "B. スナップショット、チェックサム、RAID対応のCoW型ファイルシステム",
      "C. Windowsのデフォルト",
      "D. 暗号化のみ対応"
    ],
    "correct": 1,
    "explanation": "BtrfsはCopy-on-Write方式で、スナップショット、サブボリューム、データチェックサム、内蔵RAIDなどの先進機能を持ちます。"
  },
  {
    "id": 410,
    "question": "mkfsコマンドの用途は？",
    "options": [
      "A. ファイルの作成",
      "B. ファイルシステムの作成（フォーマット）",
      "C. ディレクトリの作成",
      "D. マウントポイントの作成"
    ],
    "correct": 1,
    "explanation": "mkfs（Make FileSystem）はパーティションにファイルシステムを作成（フォーマット）するコマンドです。"
  },
  {
    "id": 411,
    "question": "fsckコマンドの用途は？",
    "options": [
      "A. ファイルの検索",
      "B. ファイルシステムの整合性チェックと修復",
      "C. ファイルの暗号化",
      "D. ファイルの圧縮"
    ],
    "correct": 1,
    "explanation": "fsck（File System Check）はアンマウントされたファイルシステムの整合性をチェックし、エラーを修復します。"
  },
  {
    "id": 412,
    "question": "Linuxのswap領域の主な用途は？",
    "options": [
      "A. ファイルの一時保存",
      "B. 物理メモリ不足時にディスクをメモリ代わりに使用",
      "C. ネットワークのバッファ",
      "D. ログの保存"
    ],
    "correct": 1,
    "explanation": "swap領域は物理メモリ（RAM）が不足した際に、ディスク上の領域を仮想メモリとして使用します。"
  },
  {
    "id": 413,
    "question": "swapon / swapoffコマンドの用途は？",
    "options": [
      "A. swap領域の作成",
      "B. swap領域の有効化/無効化",
      "C. swap領域の容量変更",
      "D. swap領域のフォーマット"
    ],
    "correct": 1,
    "explanation": "swaponはswap領域を有効化、swapoffはswap領域を無効化するコマンドです。"
  },
  {
    "id": 414,
    "question": "swappinessパラメータの意味は？",
    "options": [
      "A. swap領域のサイズ",
      "B. カーネルがswapを使う積極度（0-100）",
      "C. swap領域の暗号化強度",
      "D. swap領域の速度"
    ],
    "correct": 1,
    "explanation": "swappiness（0-100）はカーネルがRAMからswapにページを移す積極度を制御します。0に近いほどswapを避けます。"
  },
  {
    "id": 415,
    "question": "swap領域の推奨サイズの一般的な目安は？",
    "options": [
      "A. RAMの10倍",
      "B. RAMと同量〜2倍程度",
      "C. 常に1GB固定",
      "D. ディスク全体の半分"
    ],
    "correct": 1,
    "explanation": "一般的にはRAMと同量〜2倍が目安ですが、大容量RAMの場合はより少なく設定することもあります。"
  },
  {
    "id": 416,
    "question": "Linuxカーネルの主な役割は？",
    "options": [
      "A. GUIの表示",
      "B. ハードウェアとソフトウェアの仲介・リソース管理",
      "C. Webブラウジング",
      "D. テキスト編集"
    ],
    "correct": 1,
    "explanation": "カーネルはOSの中核で、プロセス管理、メモリ管理、デバイスドライバ、ファイルシステムなどを管理します。"
  },
  {
    "id": 417,
    "question": "Linuxカーネルモジュールの特徴は？",
    "options": [
      "A. カーネル再コンパイルが必要",
      "B. 実行中のカーネルに動的にロード/アンロードできる",
      "C. ユーザー空間で動作する",
      "D. Windowsのみ対応"
    ],
    "correct": 1,
    "explanation": "カーネルモジュールはカーネルを再コンパイルせずに、動的にロード（insmod/modprobe）/アンロード（rmmod）できます。"
  },
  {
    "id": 418,
    "question": "lsmodコマンドの用途は？",
    "options": [
      "A. ファイル一覧",
      "B. ロードされているカーネルモジュールの一覧表示",
      "C. ユーザー一覧",
      "D. ネットワーク一覧"
    ],
    "correct": 1,
    "explanation": "lsmodは現在Linuxカーネルにロードされているモジュールの名前、サイズ、依存関係を表示します。"
  },
  {
    "id": 419,
    "question": "dmesgコマンドの用途は？",
    "options": [
      "A. ディスク管理",
      "B. カーネルのリングバッファ（起動メッセージ等）の表示",
      "C. メール送信",
      "D. ネットワーク設定"
    ],
    "correct": 1,
    "explanation": "dmesgはカーネルのリングバッファを表示し、起動プロセスやハードウェア検出のメッセージを確認できます。"
  },
  {
    "id": 420,
    "question": "ユーザー空間とカーネル空間の違いは？",
    "options": [
      "A. 同じ空間",
      "B. カーネル空間はOS中核が動作する特権モード、ユーザー空間はアプリが動作する制限モード",
      "C. ユーザー空間の方が特権が高い",
      "D. ネットワークとローカルの違い"
    ],
    "correct": 1,
    "explanation": "カーネル空間はハードウェアに直接アクセスできる特権モード、ユーザー空間はアプリケーションが制限付きで動作するモードです。"
  },
  {
    "id": 421,
    "question": "syscall（システムコール）とは？",
    "options": [
      "A. シェルコマンド",
      "B. ユーザー空間からカーネル機能を呼び出すインターフェース",
      "C. ネットワーク通信",
      "D. ファイルの暗号化"
    ],
    "correct": 1,
    "explanation": "システムコールはユーザー空間のプログラムがカーネルの機能（ファイルI/O、プロセス制御等）を利用するためのインターフェースです。"
  },
  {
    "id": 422,
    "question": "Windowsのコマンドプロンプトでディレクトリ一覧を表示するコマンドは？",
    "options": ["A. ls", "B. dir", "C. list", "D. show"],
    "correct": 1,
    "explanation": "dirはWindowsコマンドプロンプトでディレクトリの内容を一覧表示するコマンドです。"
  },
  {
    "id": 423,
    "question": "Windowsでファイルをコピーするコマンドは？",
    "options": ["A. cp", "B. copy", "C. mv", "D. duplicate"],
    "correct": 1,
    "explanation": "copyはWindowsコマンドプロンプトでファイルをコピーするコマンドです。xcopyやrobocopyもあります。"
  },
  {
    "id": 424,
    "question": "WindowsのipconfigコマンドとLinuxの対応コマンドは？",
    "options": [
      "A. ipconfig / netstat",
      "B. ipconfig / ip addr (ifconfig)",
      "C. ipconfig / ping",
      "D. ipconfig / route"
    ],
    "correct": 1,
    "explanation": "WindowsのipconfigはLinuxのip addr（旧ifconfig）に対応し、ネットワーク設定の表示に使います。"
  },
  {
    "id": 425,
    "question": "PowerShellの特徴として正しいものは？",
    "options": [
      "A. テキストベースのパイプライン",
      "B. オブジェクトベースのパイプラインを使用",
      "C. Linux専用",
      "D. GUIのみ"
    ],
    "correct": 1,
    "explanation": "PowerShellはテキストではなくオブジェクトをパイプラインで渡すため、構造化データの操作に優れます。"
  },
  {
    "id": 426,
    "question": "PowerShellでファイル一覧を取得するコマンドレットは？",
    "options": [
      "A. dir",
      "B. Get-ChildItem",
      "C. List-Files",
      "D. Show-Directory"
    ],
    "correct": 1,
    "explanation": "Get-ChildItemはディレクトリの内容を取得するコマンドレットです。エイリアスとしてdir、lsも使えます。"
  },
  {
    "id": 427,
    "question": "PowerShellでプロセス一覧を取得するコマンドは？",
    "options": [
      "A. ps aux",
      "B. Get-Process",
      "C. List-Process",
      "D. Show-Process"
    ],
    "correct": 1,
    "explanation": "Get-Processは実行中のプロセスの情報をオブジェクトとして取得するPowerShellコマンドレットです。"
  },
  {
    "id": 428,
    "question": "PowerShellのパイプラインで出力をフィルタリングするコマンドは？",
    "options": [
      "A. grep",
      "B. Where-Object",
      "C. Filter-Object",
      "D. Select-String"
    ],
    "correct": 1,
    "explanation": "Where-Object（エイリアス: Where, ?）はパイプラインのオブジェクトを条件でフィルタリングします。"
  },
  {
    "id": 429,
    "question": "PowerShellの実行ポリシー（Execution Policy）の目的は？",
    "options": [
      "A. CPU使用率の制限",
      "B. スクリプトの実行を制御しセキュリティを確保",
      "C. ネットワーク帯域の制限",
      "D. メモリ使用量の制限"
    ],
    "correct": 1,
    "explanation": "実行ポリシーは未署名スクリプトの実行を制限し、悪意のあるスクリプトの不用意な実行を防ぎます。"
  },
  {
    "id": 430,
    "question": "PowerShellでリモートコンピュータにコマンドを実行する方法は？",
    "options": [
      "A. ssh",
      "B. Invoke-Command -ComputerName",
      "C. Remote-Execute",
      "D. Run-Remote"
    ],
    "correct": 1,
    "explanation": "Invoke-CommandはWinRM（Windows Remote Management）を使ってリモートコンピュータでコマンドを実行します。"
  }
]
