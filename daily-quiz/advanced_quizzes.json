[
  {
    "id": 1431,
    "question": "バイナリ解析で使われる「逆アセンブル」と「逆コンパイル」の違いは？",
    "options": ["A. 同じ処理", "B. 逆アセンブルは機械語→アセンブリ、逆コンパイルは機械語→高級言語に変換", "C. 逆コンパイルが先", "D. 逆アセンブルは不可能"],
    "correct": 1,
    "explanation": "逆アセンブル:バイナリをアセンブリ命令に変換(ほぼ正確)。逆コンパイル:高級言語(C等)に復元(近似的)。IDA Pro, Ghidra, Binary Ninja等のツールを使用。"
  },
  {
    "id": 1432,
    "question": "バイナリ解析ツール「Ghidra」の特徴は？",
    "options": ["A. 有料ツール", "B. NSAが開発・公開した無料のリバースエンジニアリングフレームワーク", "C. Googleが開発", "D. LinuxのみのGUIツール"],
    "correct": 1,
    "explanation": "GhidraはNSA(米国家安全保障局)が開発し2019年にOSS公開。逆アセンブラ、逆コンパイラ、スクリプティング等を備えた高機能な解析ツール。IDA Proの代替として人気。"
  },
  {
    "id": 1433,
    "question": "バイナリのファイルフォーマット「ELF」とは？",
    "options": ["A. Windows用の形式", "B. Executable and Linkable Format — Linux/Unix系の実行ファイル・共有ライブラリの標準形式", "C. macOS用の形式", "D. テキスト形式"],
    "correct": 1,
    "explanation": "ELFはヘッダ(マジックナンバー 7f 45 4c 46)、プログラムヘッダ、セクション(.text, .data, .bss, .rodata等)で構成。readelf, objdumpで解析。"
  },
  {
    "id": 1434,
    "question": "Windows実行ファイルの形式「PE（Portable Executable）」のマジックナンバーは？",
    "options": ["A. 7F 45 4C 46", "B. MZ（0x4D 0x5A）— DOS ヘッダの先頭バイト", "C. CA FE BA BE", "D. 89 50 4E 47"],
    "correct": 1,
    "explanation": "PEファイルは先頭が「MZ」(0x4D5A)のDOSヘッダから始まり、PEシグネチャ(PE\\0\\0)、COFFヘッダ、オプショナルヘッダ、セクションテーブルが続きます。"
  },
  {
    "id": 1435,
    "question": "バイナリ解析で「エンディアン」が重要な理由は？",
    "options": ["A. 見た目の問題", "B. リトルエンディアン(x86)とビッグエンディアン(ネットワーク)でバイト順序が逆になる", "C. パフォーマンスの問題", "D. コンパイラの違い"],
    "correct": 1,
    "explanation": "0x12345678をリトルエンディアン(LE)は78 56 34 12、ビッグエンディアン(BE)は12 34 56 78と格納。x86はLE、ネットワーク通信はBEが標準。"
  },
  {
    "id": 1436,
    "question": "バイナリ解析で「strings」コマンドの用途は？",
    "options": ["A. 文字列の暗号化", "B. バイナリファイルからASCII/Unicode文字列を抽出して手がかりを得る", "C. 文字列の圧縮", "D. 文字列のソート"],
    "correct": 1,
    "explanation": "strings コマンドはバイナリから可読文字列(URL、パスワード、エラーメッセージ、関数名等)を抽出。マルウェア解析の初期調査で重要な手がかりを得られます。"
  },
  {
    "id": 1437,
    "question": "バイナリ解析における「シンボル情報」とは？",
    "options": ["A. 暗号鍵", "B. 関数名・変数名・型情報等のデバッグ情報（strip前のバイナリに存在）", "C. ファイルサイズ", "D. 実行権限"],
    "correct": 1,
    "explanation": "シンボル情報(関数名,変数名等)はデバッグビルドで含まれますが、リリース時にstripで除去されることが多い。シンボルがないと解析難度が大幅に上昇。"
  },
  {
    "id": 1438,
    "question": "バイナリの「.text」「.data」「.bss」セクションの役割は？",
    "options": ["A. テキストファイルの保存", "B. .text=機械語命令、.data=初期化済みグローバル変数、.bss=未初期化グローバル変数", "C. 暗号化領域", "D. ログ領域"],
    "correct": 1,
    "explanation": ".textは実行コード(読取+実行)、.dataは初期値ありのグローバル/static変数(読取+書込)、.bssは初期値なしの変数(実行時0初期化)。"
  },
  {
    "id": 1439,
    "question": "バイナリ解析で「hexdump」や「xxd」コマンドの用途は？",
    "options": ["A. 暗号化", "B. バイナリデータを16進数とASCII表示で表示しバイトレベルで内容を確認", "C. 圧縮", "D. 変換"],
    "correct": 1,
    "explanation": "hexdump/xxdはバイナリをオフセット+16進ダンプ+ASCII表示。マジックナンバーの確認、データ構造の解析、パケット内容の確認等に使用。"
  },
  {
    "id": 1440,
    "question": "バイナリ解析における「PLT/GOT」の役割は？",
    "options": ["A. パケットフィルタ", "B. 動的リンクで外部関数のアドレスを解決する仕組み（遅延バインディング）", "C. メモリ管理", "D. ファイルシステム"],
    "correct": 1,
    "explanation": "PLT(Procedure Linkage Table)はスタブコード、GOT(Global Offset Table)は実際のアドレスを保持。初回呼出時にリゾルバが実アドレスをGOTに書込み(遅延バインディング)。GOT overwriteはExploit手法の一つ。"
  },
  {
    "id": 1441,
    "question": "リバースエンジニアリングの「動的解析」と「静的解析」の違いは？",
    "options": ["A. 同じ手法", "B. 静的=実行せずバイナリを分析、動的=実際に実行して動作を観察", "C. 静的のほうが高速", "D. 動的は不可能"],
    "correct": 1,
    "explanation": "静的解析:IDA/Ghidraで逆アセンブルしコードフローを読む。動的解析:GDB/x64dbg等のデバッガで実行しながらレジスタ/メモリを監視。両方を組合せるのが効果的。"
  },
  {
    "id": 1442,
    "question": "リバースエンジニアリングで使うデバッガ「GDB」の主な機能は？",
    "options": ["A. コンパイラ", "B. ブレークポイント設定、ステップ実行、レジスタ/メモリ表示、バックトレース", "C. テキストエディタ", "D. パケットキャプチャ"],
    "correct": 1,
    "explanation": "GDB(GNU Debugger)はLinuxの標準デバッガ。break(BP設定)、stepi(命令単位実行)、info registers、x/で メモリ表示。GEF/pwndbgで操作性向上。"
  },
  {
    "id": 1443,
    "question": "リバースエンジニアリングにおける「パッキング/アンパッキング」とは？",
    "options": ["A. ファイルの圧縮", "B. 実行ファイルを暗号化/圧縮して解析を困難にする保護と、その解除", "C. インストール", "D. アップデート"],
    "correct": 1,
    "explanation": "パッカー(UPX等)はバイナリを圧縮/暗号化し、実行時にメモリ上で展開。マルウェアは解析回避に使用。アンパッキングはOEP(元エントリポイント)を特定して復元。"
  },
  {
    "id": 1444,
    "question": "リバースエンジニアリングの「Anti-Debugging」テクニックの例は？",
    "options": ["A. 暗号化のみ", "B. IsDebuggerPresent、INT 3検出、タイミングチェック、環境検出等", "C. ファイル削除", "D. ネットワーク遮断"],
    "correct": 1,
    "explanation": "Anti-Debugはデバッガの存在を検出して動作を変更する技術。WindowsのIsDebuggerPresent API、RDTSC命令でのタイミング差異検出、VM検出等。"
  },
  {
    "id": 1445,
    "question": "リバースエンジニアリングで「フッキング」とは？",
    "options": ["A. 釣りの技術", "B. 関数の呼出しを横取りして別のコードを実行させる技術", "C. パスワード取得", "D. ネットワーク盗聴"],
    "correct": 1,
    "explanation": "APIフッキングは対象関数のアドレスや命令を書き換えて自分のコードにリダイレクト。IAT(Import Address Table)フッキング、インラインフッキング等の手法があります。"
  },
  {
    "id": 1446,
    "question": "リバースエンジニアリングツール「Frida」の特徴は？",
    "options": ["A. 静的解析ツール", "B. 動的計装(Dynamic Instrumentation)フレームワークでJavaScriptからアプリの関数をフック可能", "C. コンパイラ", "D. エディタ"],
    "correct": 1,
    "explanation": "FridaはプロセスにJavaScriptエンジンを注入し、関数の引数/戻り値の監視・改変が可能。Android/iOS/Windows/macOS/Linux対応のDBI(Dynamic Binary Instrumentation)ツール。"
  },
  {
    "id": 1447,
    "question": "リバースエンジニアリングにおける「コード難読化（Obfuscation）」の手法は？",
    "options": ["A. コメントの追加", "B. 制御フロー平坦化、不透明述語、文字列暗号化、ジャンクコード挿入等", "C. インデントの変更", "D. 変数名の変更のみ"],
    "correct": 1,
    "explanation": "制御フロー平坦化:分岐をswitch/dispatcher化。不透明述語:常にtrue/falseの条件分岐で偽パスを追加。LLVM-Obfuscator等のツールで自動化。"
  },
  {
    "id": 1448,
    "question": "リバースエンジニアリングにおける「CTF（Capture The Flag）」とは？",
    "options": ["A. サバイバルゲーム", "B. セキュリティ技術を競うハッキングコンテスト（リバース、Pwn、Web等のジャンル）", "C. プログラミングコンテスト", "D. ゲーム大会"],
    "correct": 1,
    "explanation": "CTFはrev(リバース)、pwn(バイナリExploit)、web、crypto、forensics等のジャンルで隠されたフラグ(flag{xxx})を見つける競技。DEF CON CTFが最高峰。"
  },
  {
    "id": 1449,
    "question": "リバースエンジニアリングで「IDA Pro」が業界標準とされる理由は？",
    "options": ["A. 無料だから", "B. 高精度の逆アセンブラ＋FLIRT等のシグネチャ認識＋プラグインエコシステム", "C. GUIがないから", "D. OSS だから"],
    "correct": 1,
    "explanation": "IDA ProはHex-Rays社のプロプライエタリツールで、FLIRT(ライブラリ関数の自動認識)、Hex-Rays逆コンパイラ、IDAPython等が業界最高水準。数千ドルの商用ツール。"
  },
  {
    "id": 1450,
    "question": "リバースエンジニアリングで「動的計装（DBI: Dynamic Binary Instrumentation）」とは？",
    "options": ["A. 静的解析の一種", "B. 実行中のバイナリに計測コードを動的に挿入して実行の振る舞いを分析する技術", "C. コンパイル時の最適化", "D. ソースコード解析"],
    "correct": 1,
    "explanation": "DBIはIntel PIN、DynamoRIO、Frida等のフレームワークで実行中のバイナリに分析コードを挿入。コードカバレッジ測定、テイント解析、ファジング等に活用。"
  },
  {
    "id": 1451,
    "question": "Linuxカーネルの「モノリシックカーネル」と「マイクロカーネル」の違いは？",
    "options": ["A. サイズの違いだけ", "B. モノリシックはOS機能をカーネル空間で一体実行、マイクロカーネルは最小限の機能のみ", "C. マイクロの方が大きい", "D. Linuxはマイクロカーネル"],
    "correct": 1,
    "explanation": "Linux(モノリシック)はデバイスドライバ、ファイルシステム、ネットワーク等をカーネル空間で実行し高速。Mach(macOS基盤)等のマイクロカーネルは最小機能のみでドライバをユーザ空間に。"
  },
  {
    "id": 1452,
    "question": "Linuxカーネルモジュール（LKM）とは？",
    "options": ["A. ユーザ空間のプログラム", "B. カーネルを再起動せず動的に機能を追加/削除できるカーネルコードの単位", "C. シェルスクリプト", "D. Pythonモジュール"],
    "correct": 1,
    "explanation": "LKMはinsmod/modprobeでロード、rmmodでアンロード。デバイスドライバやファイルシステムを動的追加可能。lsmodで一覧表示。.koファイル。"
  },
  {
    "id": 1453,
    "question": "Linuxカーネルの「システムコール」とは？",
    "options": ["A. 電話機能", "B. ユーザ空間からカーネル空間の機能（ファイルI/O、プロセス管理等）を呼び出すインターフェース", "C. 関数呼出し", "D. API"],
    "correct": 1,
    "explanation": "syscall(open, read, write, fork, execve等)はユーザ空間→カーネル空間への唯一の正規インターフェース。x86-64ではsyscall命令でRAXにシステムコール番号を設定して呼出し。"
  },
  {
    "id": 1454,
    "question": "Linuxカーネルの「スケジューラ」の役割は？",
    "options": ["A. メモリ管理", "B. CPUの実行時間を複数のプロセス/スレッドに公平に割り当てる", "C. ファイル管理", "D. ネットワーク管理"],
    "correct": 1,
    "explanation": "CFS(Completely Fair Scheduler)は赤黒木でプロセスのvruntime(仮想実行時間)を管理し、最も実行時間が少ないプロセスを次に実行。nice値で優先度調整。"
  },
  {
    "id": 1455,
    "question": "Linuxカーネルの「仮想メモリ」の仕組みは？",
    "options": ["A. RAMの拡張", "B. 各プロセスに独立した仮想アドレス空間を提供し、ページテーブルで物理メモリにマッピング", "C. ディスクキャッシュ", "D. 仮想マシン"],
    "correct": 1,
    "explanation": "仮想メモリはMMU(Memory Management Unit)とページテーブルで仮想アドレス→物理アドレスを変換。ページフォルト時にディスクからロード。4KB/2MB/1GBページ。"
  },
  {
    "id": 1456,
    "question": "Linuxカーネルの「cgroup（Control Groups）」の用途は？",
    "options": ["A. ユーザー管理", "B. プロセスグループのCPU、メモリ、I/O等のリソース使用量を制限・管理する仕組み", "C. ファイル権限", "D. ネットワーク設定"],
    "correct": 1,
    "explanation": "cgroupはプロセスをグループ化してリソースを制限/監視。Dockerコンテナのリソース分離の基盤技術。cgroup v2では統一的な階層構造で管理。"
  },
  {
    "id": 1457,
    "question": "Linuxカーネルの「namespace」の役割は？",
    "options": ["A. 名前空間の命名規則", "B. プロセスにPID、ネットワーク、ファイルシステム等の独立した空間を提供（コンテナの基盤）", "C. DNS管理", "D. ディレクトリ管理"],
    "correct": 1,
    "explanation": "namespaceはPID, Network, Mount, UTS, IPC, User等をプロセスごとに分離。cgroupと合わせてDockerコンテナの隔離を実現する基盤技術。"
  },
  {
    "id": 1458,
    "question": "Linuxカーネルの「eBPF（extended Berkeley Packet Filter）」の用途は？",
    "options": ["A. パケットフィルタのみ", "B. カーネル内で安全にサンドボックス化されたプログラムを実行する汎用フレームワーク", "C. ファイアウォールのみ", "D. ファイルシステムのみ"],
    "correct": 1,
    "explanation": "eBPFはカーネル内で安全に小さなプログラムを動かす技術。ネットワーク監視、セキュリティ、パフォーマンス分析(bpftrace等)に革命的。Cilium、Falco等が活用。"
  },
  {
    "id": 1459,
    "question": "Linuxカーネル開発で使われるバージョン管理とソースコードの規模は？",
    "options": ["A. SVN, 数千行", "B. Git（Linusが開発）、約3000万行以上のCコード", "C. Mercurial, 100万行", "D. CVS, 10万行"],
    "correct": 1,
    "explanation": "Linuxカーネルは6.x系で約3000万行超のCコード。GitはLinusがBitKeeper問題後に2005年に開発。毎リリースで約1万件のコミットが入ります。"
  },
  {
    "id": 1460,
    "question": "Linuxカーネルの「/proc」ファイルシステムの目的は？",
    "options": ["A. ファイルの保存", "B. カーネルやプロセスの情報を仮想ファイルとして公開するインターフェース", "C. プロセスのログ", "D. バックアップ"],
    "correct": 1,
    "explanation": "/procは仮想ファイルシステムで、/proc/PID/（プロセス情報）、/proc/cpuinfo（CPU情報）、/proc/meminfo（メモリ情報）等をファイルとして提供。"
  },
  {
    "id": 1461,
    "question": "「ブートローダ」の役割は？",
    "options": ["A. OSの一部", "B. 電源投入後にハードウェアを初期化し、OSカーネルをメモリにロードして実行を開始するプログラム", "C. アプリケーションの起動", "D. ファイルの読込み"],
    "correct": 1,
    "explanation": "ブートローダはBIOS/UEFI→MBR/ESP→ブートローダ(GRUB等)→カーネルの流れでOSを起動。カーネルをメモリにロードして制御を移す重要なプログラムです。"
  },
  {
    "id": 1462,
    "question": "Linuxの標準ブートローダ「GRUB（GRand Unified Bootloader）」の機能は？",
    "options": ["A. カーネルのコンパイル", "B. 複数OS選択、カーネルパラメータ指定、レスキューシェル等のブート管理", "C. ファイルシステム管理", "D. パッケージ管理"],
    "correct": 1,
    "explanation": "GRUB2はマルチブート対応のブートローダ。/boot/grub/grub.cfgでカーネル選択メニューを設定。GRUBシェルでの手動ブートやレスキューも可能。"
  },
  {
    "id": 1463,
    "question": "「UEFI（Unified Extensible Firmware Interface）」とBIOSの違いは？",
    "options": ["A. 名前が違うだけ", "B. UEFIはGUIサポート、GPTディスク対応、セキュアブート、高速起動対応の最新ファームウェア", "C. BIOSの方が新しい", "D. UEFIは32bitのみ"],
    "correct": 1,
    "explanation": "UEFIはBIOSの後継で、GPTパーティション(2TB超対応)、セキュアブート(署名検証)、ネットワーク起動、GUIセットアップ画面等の機能を提供。"
  },
  {
    "id": 1464,
    "question": "「セキュアブート」の仕組みは？",
    "options": ["A. パスワード認証", "B. UEFI がブートローダ/カーネルのデジタル署名を検証し、改ざんされた場合は起動を拒否", "C. ディスク暗号化", "D. ネットワーク認証"],
    "correct": 1,
    "explanation": "セキュアブートはUEFIファームウェアがブートチェーンの各段階（ブートローダ→カーネル→ドライバ）の電子署名を検証し、改竄を防止するセキュリティ機能。"
  },
  {
    "id": 1465,
    "question": "コンピュータの起動シーケンス（UEFI環境）の順序は？",
    "options": ["A. OS→BIOS→ブートローダ", "B. 電源ON→UEFI(POST)→ESP内のブートローダ→カーネル→init/systemd", "C. カーネル→UEFI→ブートローダ", "D. ROM→RAM→UEFI"],
    "correct": 1,
    "explanation": "電源ON→CPUリセット→UEFIファームウェア(POST自己診断)→ESPからブートローダ(GRUB等)→Linuxカーネルロード→initramfs→systemd(PID 1)→ユーザー空間。"
  },
  {
    "id": 1466,
    "question": "「initramfs（初期RAMファイルシステム）」の役割は？",
    "options": ["A. 永続的なファイルシステム", "B. カーネル起動初期にルートファイルシステムをマウントするために必要なドライバ等を提供する一時的なFS", "C. スワップ領域", "D. バックアップ領域"],
    "correct": 1,
    "explanation": "initramfsはカーネルが本物のルートFSをマウントする前にメモリ上に展開される一時的なFS。必要なドライバ(ストレージ、暗号化等)やマウントスクリプトを含みます。"
  },
  {
    "id": 1467,
    "question": "「MBR（Master Boot Record）」の構造は？",
    "options": ["A. 1MB", "B. ディスク先頭512バイトにブートストラップコード(446B)+パーティションテーブル(64B)+シグネチャ(2B)", "C. 4KB", "D. 任意のサイズ"],
    "correct": 1,
    "explanation": "MBRは512バイト: ブートストラップコード(446B) + 4エントリのパーティションテーブル(各16B×4=64B) + マジックナンバー0xAA55(2B)。最大4プライマリパーティション、2TB制限。"
  },
  {
    "id": 1468,
    "question": "「GPT（GUIDパーティションテーブル）」のMBRに対する利点は？",
    "options": ["A. MBRと同じ", "B. 2TB超のディスク対応、128パーティション、CRC32チェックサム、バックアップヘッダ", "C. 速度が速い", "D. 古いOSと互換"],
    "correct": 1,
    "explanation": "GPTは最大8ZBのディスク、128パーティション対応。CRC32で破損検出し、ディスク末尾にバックアップ。UEFIと組合せて使用。先頭にProtective MBRも持つ。"
  },
  {
    "id": 1469,
    "question": "「PXEブート（Preboot Execution Environment）」の用途は？",
    "options": ["A. USBブート", "B. ネットワーク経由でOSイメージを取得し起動する技術（大量デプロイに利用）", "C. CD起動", "D. SSD起動"],
    "correct": 1,
    "explanation": "PXEはDHCP+TFTPでネットワーク上のサーバーからブートイメージをダウンロードして起動。データセンターでの大量サーバーのOS自動インストールに活用。"
  },
  {
    "id": 1470,
    "question": "「U-Boot」とは？",
    "options": ["A. 潜水艦ゲーム", "B. 組み込みLinux向けのオープンソースブートローダ（ARM、MIPS等のSoC対応）", "C. Windowsのブートローダ", "D. UEFIの別名"],
    "correct": 1,
    "explanation": "U-Boot(Das U-Boot)はARM、RISC-V等の組み込みSoC向けOSSブートローダ。Raspberry Pi、組み込みLinuxボードで広く使用。シリアルコンソールで操作。"
  },
  {
    "id": 1471,
    "question": "「メモリフォレンジック」の目的は？",
    "options": ["A. メモリの修理", "B. 揮発性メモリ(RAM)のダンプを解析してマルウェアや攻撃の痕跡を発見する調査手法", "C. メモリの増設", "D. メモリリークの修正"],
    "correct": 1,
    "explanation": "メモリフォレンジックはRAMの内容をダンプして、実行中のプロセス、ネットワーク接続、暗号鍵、インジェクトされたコード、rootkit等の痕跡を分析します。"
  },
  {
    "id": 1472,
    "question": "メモリフォレンジックツール「Volatility」の機能は？",
    "options": ["A. メモリの最適化", "B. メモリダンプからプロセス一覧、ネットワーク接続、レジストリ、DLLインジェクション等を抽出", "C. メモリのクリーンアップ", "D. RAM のテスト"],
    "correct": 1,
    "explanation": "Volatility(Python製)はメモリダンプの定番分析ツール。pslist(プロセス)、netscan(接続)、dlllist(DLL)、malfind(不審コード)等のプラグインで解析。"
  },
  {
    "id": 1473,
    "question": "メモリフォレンジックで「プロセスホロウイング」を検出する方法は？",
    "options": ["A. タスクマネージャ", "B. VAD(仮想アドレス記述子)とディスク上のイメージを比較し、置き換えられたコードを検出", "C. ファイルスキャン", "D. レジストリ確認"],
    "correct": 1,
    "explanation": "プロセスホロウイングは正規プロセスのメモリを悪意あるコードに置換する手法。Volatilityのmalfindプラグインで実行可能だが実行ファイルと一致しないメモリ領域を検出。"
  },
  {
    "id": 1474,
    "question": "メモリフォレンジックで重要な「メモリダンプの取得方法」は？",
    "options": ["A. スクリーンショット", "B. WinPmem、LiME（Linux）、クラッシュダンプ、仮想マシンのスナップショット等", "C. コピー＆ペースト", "D. ログファイル収集"],
    "correct": 1,
    "explanation": "WindowsはWinPmem/FTK Imager、LinuxはLiME(Loadable Kernel Module)でRAMを取得。VMのスナップショット(.vmem)やhiberfil.sys(休止ファイル)も分析対象。"
  },
  {
    "id": 1475,
    "question": "メモリフォレンジックで「YARA ルール」の用途は？",
    "options": ["A. メモリ管理", "B. パターンマッチングでメモリダンプ内のマルウェアを文字列やバイト列で検出するルール", "C. ファイル分類", "D. ログ分析"],
    "correct": 1,
    "explanation": "YARAルールは文字列、バイトパターン、正規表現等でマルウェアの特徴をルール化。メモリダンプやファイルに対してパターンマッチし、既知のマルウェアを検出。"
  },
  {
    "id": 1476,
    "question": "メモリフォレンジックで「カーネルオブジェクト」の解析が重要な理由は？",
    "options": ["A. GUI表示のため", "B. プロセス(EPROCESS)、スレッド、ハンドル等のカーネル構造体からOSの状態を正確に復元", "C. ディスク管理", "D. ネットワーク設定"],
    "correct": 1,
    "explanation": "WindowsのEPROCESS構造体はPID、親PID、作成時刻、トークン等を保持。隠蔽されたプロセスもカーネルオブジェクトのリンクリスト走査で発見可能。"
  },
  {
    "id": 1477,
    "question": "メモリフォレンジックで「DLLインジェクション」の検出方法は？",
    "options": ["A. タスクバー確認", "B. プロセスのロードDLL一覧を確認し、不審なパスや未署名のDLLを特定", "C. ウイルススキャン", "D. ファイル検索"],
    "correct": 1,
    "explanation": "DLLインジェクションは正規プロセスに悪意のDLLを注入する攻撃。Volatilityのdlllistやldrmodules で不審なDLL(System32以外のパス、未署名等)を検出。"
  },
  {
    "id": 1478,
    "question": "メモリフォレンジックで「暗号鍵の抽出」が可能な理由は？",
    "options": ["A. 鍵は暗号化されている", "B. 暗号処理中にRAM上に鍵が平文で存在するため、メモリダンプから復元可能", "C. OSが鍵を公開", "D. 鍵はディスクに保存"],
    "correct": 1,
    "explanation": "BitLockerやTrueCryptの暗号鍵はRAM上に平文で存在。コールドブート攻撃(メモリを冷却して電源断後も読出し)や、メモリダンプから鍵を回収可能。"
  },
  {
    "id": 1479,
    "question": "メモリフォレンジックにおける「タイムライン分析」とは？",
    "options": ["A. 時間の計測", "B. メモリ内のプロセス作成日時、ネットワーク接続時刻等を時系列に並べて攻撃の流れを再構成", "C. カレンダー分析", "D. ログ閲覧"],
    "correct": 1,
    "explanation": "プロセス作成/終了時刻、ネットワーク接続開始時刻、ファイルアクセス時刻等を時系列に整理し、攻撃者の行動(初期侵入→横展開→データ窃取)を再現します。"
  },
  {
    "id": 1480,
    "question": "メモリフォレンジックで「スタック」と「ヒープ」の分析が重要な理由は？",
    "options": ["A. パフォーマンス最適化", "B. スタックから関数の呼出し履歴、ヒープから動的に確保されたデータ（シェルコード等）を発見", "C. メモリ使用量の確認", "D. CPU利用率の確認"],
    "correct": 1,
    "explanation": "スタック解析で関数呼出しチェーン(バックトレース)からExploit経路を特定。ヒープ解析でマルウェアが動的確保した不審なデータやシェルコードを発見。"
  },
  {
    "id": 1481,
    "question": "マルウェア解析の「サンドボックス分析」とは？",
    "options": ["A. 本番環境での実行", "B. 隔離された仮想環境でマルウェアを実行し、ファイル/レジストリ/ネットワーク活動を安全に観察", "C. ソースコード分析", "D. ログ分析"],
    "correct": 1,
    "explanation": "サンドボックス(Cuckoo Sandbox, Any.Run, VirusTotal等)はVMやコンテナでマルウェアを安全に実行し、API呼出し、ファイル操作、通信先等を自動記録。"
  },
  {
    "id": 1482,
    "question": "マルウェアの分類で「トロイの木馬」の特徴は？",
    "options": ["A. 自己増殖する", "B. 有用なプログラムに偽装して侵入し、バックドア設置やデータ窃取を行う（自己増殖しない）", "C. ファイルを暗号化", "D. メールを送信"],
    "correct": 1,
    "explanation": "トロイの木馬はユーザーが自ら実行する正規ソフトに偽装。ワームと異なり自己増殖せず、ユーザーの操作やソーシャルエンジニアリングで拡散。RAT(遠隔操作)型が多い。"
  },
  {
    "id": 1483,
    "question": "マルウェアの「C2（Command and Control）サーバ」の役割は？",
    "options": ["A. Webサーバ", "B. 感染端末に指令を送り、窃取データを受け取る攻撃者の制御サーバ", "C. DNSサーバ", "D. メールサーバ"],
    "correct": 1,
    "explanation": "C2(C&C)サーバは攻撃者がマルウェアに遠隔指示(コマンド実行、データ窃取、追加モジュールDL等)を送る中枢。HTTP/HTTPS/DNS/SNS等を通信経路に利用。"
  },
  {
    "id": 1484,
    "question": "マルウェア解析で「VirusTotal」の用途は？",
    "options": ["A. ウイルスの作成", "B. ファイルやURLを60以上のアンチウイルスエンジンで同時スキャンする無料オンラインサービス", "C. ウイルスの配布", "D. パッチの適用"],
    "correct": 1,
    "explanation": "VirusTotal(Google)はファイルハッシュ/ファイル/URLを投稿すると60+のAVエンジンの検出結果、行動分析、YARA一致等を一括表示。初期トリアージに必須。"
  },
  {
    "id": 1485,
    "question": "マルウェアの「ファイルレスマルウェア」の特徴は？",
    "options": ["A. ファイルとして存在する", "B. ディスクにファイルを残さずメモリやレジストリ上で活動し、アンチウイルスの検出を回避", "C. 小さいファイル", "D. 暗号化されたファイル"],
    "correct": 1,
    "explanation": "ファイルレスマルウェアはPowerShell、WMI、レジストリ等のOS正規機能を悪用してメモリ上で動作。ディスクにファイルが残らないため従来のAVで検出困難。"
  },
  {
    "id": 1486,
    "question": "マルウェアの「ポリモーフィック(多態型)」と「メタモーフィック(変態型)」の違いは？",
    "options": ["A. 同じ手法", "B. ポリモーフィックは暗号化+復号ルーチン変形、メタモーフィックはコード自体を完全に書換え", "C. ポリモーフィックの方が高度", "D. メタモーフィックは暗号化のみ"],
    "correct": 1,
    "explanation": "ポリモーフィック:ペイロードを暗号化し毎回異なる復号ルーチンで検出回避。メタモーフィック:コード自体を命令置換/レジスタ変更等で完全に変形。メタモーフィックの方が高度。"
  },
  {
    "id": 1487,
    "question": "マルウェア解析における「IoC（Indicator of Compromise）」とは？",
    "options": ["A. インターネット設定", "B. マルウェア感染の痕跡を示す指標（ハッシュ値、C2ドメイン、IPアドレス、レジストリキー等）", "C. パフォーマンス指標", "D. 品質指標"],
    "correct": 1,
    "explanation": "IoCはファイルハッシュ(MD5/SHA256)、不審なドメイン/IP、作成されるファイルパス、レジストリ変更等。STIX/TAXIIフォーマットで脅威インテリジェンスを共有。"
  },
  {
    "id": 1488,
    "question": "マルウェア解析で「MITRE ATT&CK」フレームワークの用途は？",
    "options": ["A. コーディング規約", "B. 攻撃者の戦術（Tactics）・技術（Techniques）を体系化した知識ベースで攻撃の分類・対策に使用", "C. 開発フレームワーク", "D. テストツール"],
    "correct": 1,
    "explanation": "ATT&CKは初期アクセス、実行、永続化、権限昇格、防御回避、横展開、窃取等の戦術と具体的技術をマトリクスで整理。脅威ハンティングや検知ルール作成に活用。"
  },
  {
    "id": 1489,
    "question": "マルウェアの「ランサムウェア」が暗号化に使う一般的な方式は？",
    "options": ["A. ROT13のみ", "B. RSAで共通鍵を暗号化、AES-256でファイルを暗号化するハイブリッド暗号方式", "C. Base64エンコード", "D. ZIP圧縮のみ"],
    "correct": 1,
    "explanation": "典型的なランサムウェアはAES-256(高速)でファイルを暗号化し、そのAES鍵をRSA公開鍵で暗号化。攻撃者のRSA秘密鍵がなければ復号不可能。"
  },
  {
    "id": 1490,
    "question": "マルウェアの「APT（Advanced Persistent Threat）」とは？",
    "options": ["A. 一般的なウイルス", "B. 国家支援等の高度な攻撃者が長期間持続的に標的組織に侵入する標的型攻撃", "C. 自動生成マルウェア", "D. アドウェア"],
    "correct": 1,
    "explanation": "APTはAPT28(ロシア), APT41(中国), Lazarus(北朝鮮)等の国家支援グループが数ヶ月〜数年かけて特定組織に潜伏する高度な攻撃。ゼロデイやカスタムマルウェアを使用。"
  },
  {
    "id": 1491,
    "question": "「サイドチャネル攻撃」とは？",
    "options": ["A. ネットワーク攻撃", "B. 暗号処理の実行時間、消費電力、電磁放射等の物理的な情報漏洩から秘密情報を推定する攻撃", "C. ソーシャルエンジニアリング", "D. ブルートフォース攻撃"],
    "correct": 1,
    "explanation": "サイドチャネル攻撃は暗号アルゴリズムの数学的な弱点ではなく、物理的な実装の漏洩情報（時間差、電力波形、電磁波、音等）を利用して秘密鍵等を推定します。"
  },
  {
    "id": 1492,
    "question": "「タイミング攻撃」の仕組みは？",
    "options": ["A. 時間制限攻撃", "B. 暗号処理の実行時間の微小な差異から秘密情報を推定する攻撃", "C. タイムアウト攻撃", "D. DoS攻撃"],
    "correct": 1,
    "explanation": "文字列比較が一致文字数に応じて処理時間が変わる場合、応答時間を統計的に分析してパスワードを1文字ずつ推定。定数時間比較(constant-time comparison)で対策。"
  },
  {
    "id": 1493,
    "question": "「電力解析攻撃（Power Analysis Attack）」の種類は？",
    "options": ["A. 電力供給攻撃", "B. SPA（単純電力解析）とDPA（差分電力解析）", "C. 停電攻撃", "D. 過電流攻撃"],
    "correct": 1,
    "explanation": "SPA:電力波形の目視で暗号操作を特定。DPA:大量の電力トレースの統計分析で鍵ビットを推定。ICカード(クレジットカード等)への攻撃で特に脅威。"
  },
  {
    "id": 1494,
    "question": "「キャッシュタイミング攻撃」の代表例は？",
    "options": ["A. ブラウザキャッシュ攻撃", "B. Spectre/Meltdown — CPU投機的実行のキャッシュ状態から秘密データを推定", "C. CDNキャッシュ攻撃", "D. DNSキャッシュ攻撃"],
    "correct": 1,
    "explanation": "Spectre(2018)はCPUの投機的実行を悪用し、本来アクセス不可のメモリ内容をキャッシュのロード時間差で推定。ほぼ全ての現代CPUに影響した深刻な脆弱性。"
  },
  {
    "id": 1495,
    "question": "「Spectre」脆弱性の影響範囲は？",
    "options": ["A. 特定のCPUのみ", "B. Intel, AMD, ARM等のほぼ全ての投機的実行対応CPUに影響", "C. GPUのみ", "D. ソフトウェアのみ"],
    "correct": 1,
    "explanation": "Spectreは分岐予測の投機実行を悪用するためCPU設計レベルの問題でハードウェア修正が困難。Retpoline等のソフトウェア緩和策で対処。パフォーマンス低下を伴う。"
  },
  {
    "id": 1496,
    "question": "「Meltdown」と「Spectre」の違いは？",
    "options": ["A. 同じ脆弱性", "B. Meltdownはカーネルメモリの読取り(Intel中心)、Spectreは投機的実行で他プロセスの情報取得", "C. Meltdownの方が軽微", "D. Spectreは修正済み"],
    "correct": 1,
    "explanation": "Meltdown(CVE-2017-5754)はユーザ空間からカーネルメモリを読取り可能(KPTI で対策)。Spectre(CVE-2017-5753/5715)は分岐予測悪用でより広範囲に影響。"
  },
  {
    "id": 1497,
    "question": "「電磁波攻撃（Electromagnetic Attack）」とは？",
    "options": ["A. EMPパルス攻撃", "B. 電子機器から放射される電磁波を受信して処理内容や暗号鍵を推定するサイドチャネル攻撃", "C. ジャミング", "D. 雷対策"],
    "correct": 1,
    "explanation": "TEMPESTとも呼ばれ、ディスプレイの電磁放射からの画面復元や暗号デバイスの電磁波からの鍵推定が可能。電磁シールドやノイズ発生で対策。"
  },
  {
    "id": 1498,
    "question": "「グリッチ攻撃（Fault Injection / Glitching）」とは？",
    "options": ["A. ソフトウェアバグ", "B. 電圧/クロック/レーザー等で意図的にハードウェアに誤動作を起こし認証を回避する攻撃", "C. UIの不具合", "D. ネットワーク障害"],
    "correct": 1,
    "explanation": "電圧グリッチ:瞬間的に電圧を変動させCPU命令をスキップ。クロックグリッチ:クロック周波数を操作。セキュリティチェック命令のスキップやデバッグロック解除に悪用。"
  },
  {
    "id": 1499,
    "question": "サイドチャネル攻撃の対策手法「マスキング」とは？",
    "options": ["A. データの非表示", "B. 暗号処理の中間値をランダム値で隠蔽し、電力/電磁波解析で秘密を推定不能にする手法", "C. 暗号化", "D. ファイアウォール"],
    "correct": 1,
    "explanation": "マスキングは秘密値sに乱数rを加えて(s⊕r)として処理。DPA等は中間値と電力波形の相関から鍵を推定するが、マスキングにより相関が消失します。"
  },
  {
    "id": 1500,
    "question": "サイドチャネル攻撃の対策手法「定数時間実装」とは？",
    "options": ["A. 処理速度の制限", "B. 秘密データに関わらず実行時間が一定になるようプログラムを実装し、タイミング攻撃を防止", "C. タイムアウトの設定", "D. キャッシュの無効化"],
    "correct": 1,
    "explanation": "定数時間実装は条件分岐やメモリアクセスパターンが秘密値に依存しないコード。crypto_memcmp()のようなビット演算ベースの比較で実行時間を一定に。"
  },
  {
    "id": 1501,
    "question": "「バッファオーバーフロー攻撃」の仕組みは？",
    "options": ["A. バッファの拡大", "B. バッファサイズ以上のデータを書込みリターンアドレスを上書きして任意コードを実行", "C. バッファの圧縮", "D. バッファの暗号化"],
    "correct": 1,
    "explanation": "スタック上のローカルバッファに境界チェックなしで書込み、リターンアドレスをシェルコードのアドレスに上書き。ASLR、Canary、NXビット等で対策。"
  },
  {
    "id": 1502,
    "question": "バッファオーバーフロー対策の「ASLR」とは？",
    "options": ["A. 暗号化方式", "B. Address Space Layout Randomization — メモリ配置をランダム化して攻撃先アドレスの推測を困難に", "C. 認証方式", "D. ログ管理"],
    "correct": 1,
    "explanation": "ASLRはスタック、ヒープ、ライブラリのロードアドレスを起動毎にランダム化。攻撃者がジャンプ先アドレスを事前に特定できなくなります。"
  },
  {
    "id": 1503,
    "question": "バッファオーバーフロー対策の「スタックカナリア」とは？",
    "options": ["A. カナリア鳥のアイコン", "B. リターンアドレスの前にランダム値を配置し、上書きされたら異常終了して攻撃を阻止", "C. パスワード", "D. 暗号鍵"],
    "correct": 1,
    "explanation": "スタックカナリア（Stack Guard）はリターンアドレスの前にランダムな値(canary)を配置。関数リターン時にcanaryが変更されていればスタック破壊として検出・中断。"
  },
  {
    "id": 1504,
    "question": "「ROP（Return-Oriented Programming）」攻撃とは？",
    "options": ["A. 新しいコードの注入", "B. NXビット環境下で既存のコード断片（ROP gadget）を連結して任意処理を組立てる攻撃", "C. スクリプト攻撃", "D. 暗号攻撃"],
    "correct": 1,
    "explanation": "NXビットでコード注入不可の環境で、既存のライブラリ中のret命令で終わる命令列(gadget)をチェーンしてスタックから連続実行する高度なExploit手法。"
  },
  {
    "id": 1505,
    "question": "「Use-After-Free」脆弱性とは？",
    "options": ["A. メモリリーク", "B. 解放済みメモリを参照してしまい、攻撃者が同じアドレスに悪意データを配置して制御を奪取", "C. ダブルフリー", "D. バッファオーバーフロー"],
    "correct": 1,
    "explanation": "free()後のポインタ(ダングリングポインタ)を使用すると、攻撃者がヒープ操作で同じ領域に任意データを配置し仮想関数テーブル等を改ざんして制御を奪取。ブラウザのDOM処理で多発。"
  },
  {
    "id": 1506,
    "question": "「ヒープスプレー」攻撃の仕組みは？",
    "options": ["A. メモリの解放", "B. ヒープに大量の同一パターン（NOP+シェルコード）を配置してジャンプ先の成功率を高める手法", "C. スタック操作", "D. レジスタ操作"],
    "correct": 1,
    "explanation": "ヒープスプレーはアドレスが不確実な環境で、大量のNOPスレッド+シェルコードをヒープに配置。ジャンプ先がどこでもNOPスレッドを滑ってシェルコードに到達。"
  },
  {
    "id": 1507,
    "question": "「Format String攻撃」の原理は？",
    "options": ["A. 文字列フォーマットの変更", "B. printf等のフォーマット文字列にユーザ入力を使うと%x, %n等でスタック読取り/書込みが可能", "C. 文字コード攻撃", "D. 正規表現攻撃"],
    "correct": 1,
    "explanation": "printf(user_input)とするとユーザーが%xでスタックを読取り、%nでメモリに書込み可能。printf(\"%s\", user_input)と書くことで防止。"
  },
  {
    "id": 1508,
    "question": "「ファジング（Fuzzing）」の目的は？",
    "options": ["A. パフォーマンステスト", "B. 大量のランダム/半ランダムな入力をプログラムに与えてクラッシュや脆弱性を自動発見", "C. 単体テスト", "D. 結合テスト"],
    "correct": 1,
    "explanation": "AFL, libFuzzer, Honggfuzz等のファザーがプログラムに変異入力を大量に与え、クラッシュ(SEGV等)やメモリエラーを自動検出。コードカバレッジで変異を誘導。"
  },
  {
    "id": 1509,
    "question": "Linuxの「seccomp」の用途は？",
    "options": ["A. コンパイラ", "B. プロセスが使用できるシステムコールを制限してサンドボックス化するカーネル機能", "C. ネットワーク制限", "D. ファイル制限"],
    "correct": 1,
    "explanation": "seccomp(Secure Computing Mode)はBPFフィルタでプロセスが呼べるシステムコールを制限。Docker、Chrome、Firefoxのサンドボックスで活用されています。"
  },
  {
    "id": 1510,
    "question": "「シェルコード」とは？",
    "options": ["A. シェルスクリプト", "B. Exploit成功後に実行される機械語のペイロード（シェル起動等の目的のバイト列）", "C. HTMLコード", "D. SQLコード"],
    "correct": 1,
    "explanation": "シェルコードはバッファオーバーフロー等で注入される機械語バイト列。/bin/shの起動(シェル奪取)が名前の由来。NULLバイト回避等の制約がある。"
  },
  {
    "id": 1511,
    "question": "「整数オーバーフロー」がセキュリティ脆弱性になる仕組みは？",
    "options": ["A. 計算ミスのみ", "B. 整数の桁あふれでバッファサイズの計算が0や小さい値になり、バッファオーバーフローに繋がる", "C. 処理速度の低下", "D. メモリリーク"],
    "correct": 1,
    "explanation": "例: uint16_t size = len + header; でオーバーフローすると小さいバッファを確保→大きなデータを書込み→ヒープオーバーフロー。符号付き/なしの混在も危険。"
  },
  {
    "id": 1512,
    "question": "「TOCTOU（Time of Check Time of Use）」脆弱性とは？",
    "options": ["A. タイムアウト", "B. チェック時と使用時の間にリソースの状態が変化する競合条件(Race Condition)の脆弱性", "C. キャッシュ問題", "D. ロック問題"],
    "correct": 1,
    "explanation": "ファイルのアクセス権チェック(check)後、実際のオープン(use)までの間に攻撃者がシンボリックリンクを差替える等でセキュリティチェックを回避。"
  },
  {
    "id": 1513,
    "question": "「カーネルエクスプロイト」の特徴と危険性は？",
    "options": ["A. ユーザ権限での実行", "B. カーネルの脆弱性を突いてring0（最高権限）でコード実行し完全なシステム制御を獲得", "C. アプリの脆弱性", "D. ネットワーク攻撃"],
    "correct": 1,
    "explanation": "カーネルExploitはドライバやsyscallの脆弱性を突いてring0で任意コード実行→ルート権限奪取。コンテナ脱出やVM脱出にも繋がる最も危険な攻撃。"
  },
  {
    "id": 1514,
    "question": "「コンパイラセキュリティ」の取り組みとは？",
    "options": ["A. コンパイル速度の向上", "B. -fstack-protector, -D_FORTIFY_SOURCE, -PIE等のセキュリティ強化コンパイルオプション", "C. コードの最適化", "D. デバッグ情報の追加"],
    "correct": 1,
    "explanation": "GCC/Clangの-fstack-protector(カナリア)、-D_FORTIFY_SOURCE(バッファサイズチェック)、-fPIE -pie(ASLR対応)、-Wformat-security等で脆弱性を軽減。"
  },
  {
    "id": 1515,
    "question": "「eBPF」がセキュリティ監視に使われる理由は？",
    "options": ["A. ファイアウォールのみ", "B. カーネル内で安全にプログラムを実行し、syscall/ネットワーク/ファイルアクセスをリアルタイム監視", "C. ログ保存のみ", "D. 暗号化のみ"],
    "correct": 1,
    "explanation": "eBPFはFalco(ランタイムセキュリティ)、Cilium(ネットワークポリシー)、Tracee等でsyscall監視、コンテナのセキュリティ監視をオーバーヘッド低くリアルタイムに実現。"
  },
  {
    "id": 1516,
    "question": "「Rowhammer攻撃」の仕組みは？",
    "options": ["A. ネットワーク攻撃", "B. DRAMの同一行を高速に繰返しアクセスし、隣接行のビットを反転させるハードウェア脆弱性", "C. ストレージ攻撃", "D. CPU攻撃"],
    "correct": 1,
    "explanation": "DRAMセルの物理的特性を悪用。高速なメモリアクセスで隣接行で電荷漏れが発生しビット反転(bit flip)。ページテーブル改ざんによる権限昇格に悪用。"
  },
  {
    "id": 1517,
    "question": "「音響サイドチャネル攻撃」とは？",
    "options": ["A. 音声認識攻撃", "B. CPUやキーボードの動作音を分析して暗号鍵やタイプ内容を推定する攻撃", "C. スピーカー攻撃", "D. マイク攻撃"],
    "correct": 1,
    "explanation": "RSA暗号処理中のCPUの高周波音から鍵を抽出したり、キーボードのタイプ音の微妙な差異からパスワードを推定する研究が報告されています。"
  },
  {
    "id": 1518,
    "question": "「リンカ」と「ローダ」の役割の違いは？",
    "options": ["A. 同じプログラム", "B. リンカはオブジェクトファイルを結合して実行ファイルを生成、ローダは実行ファイルをメモリにロード", "C. ローダがコンパイル", "D. リンカが実行"],
    "correct": 1,
    "explanation": "リンカ(ld)はコンパイル後の.oファイルとライブラリを結合してELF/PE実行ファイルを作成。ローダ(ld-linux.so)は実行時にファイルをメモリに配置しDLL/soを動的リンク。"
  },
  {
    "id": 1519,
    "question": "「コンパイラ」の主要な処理段階は？",
    "options": ["A. 翻訳のみ", "B. 字句解析→構文解析→意味解析→中間コード生成→最適化→コード生成", "C. 実行→出力", "D. 圧縮→展開"],
    "correct": 1,
    "explanation": "フロントエンド:字句解析(トークン化)→構文解析(AST構築)→意味解析(型チェック)。ミドルエンド:中間表現(IR)で最適化。バックエンド:ターゲットの機械語生成。"
  },
  {
    "id": 1520,
    "question": "「JIT（Just-In-Time）コンパイル」の仕組みは？",
    "options": ["A. 事前コンパイル", "B. プログラム実行時にホットスポットのバイトコードを機械語に動的変換して高速化", "C. インタプリタと同じ", "D. 圧縮技術"],
    "correct": 1,
    "explanation": "JITは実行中に頻繁に呼ばれるコード(ホットスポット)をネイティブ機械語にコンパイル。Java HotSpot VM、V8(JavaScript)、LuaJIT等が代表的。AOT(事前)コンパイルと対比。"
  },
  {
    "id": 1521,
    "question": "x86-64アーキテクチャの汎用レジスタ数は？",
    "options": ["A. 8個", "B. 16個（RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15）", "C. 32個", "D. 4個"],
    "correct": 1,
    "explanation": "x86-64はx86の8個から倍増し、RAX-RDX, RSI, RDI, RBP, RSP + R8-R15の16個の64bit汎用レジスタ。System V ABIでは引数をRDI,RSI,RDX,RCX,R8,R9で渡す。"
  },
  {
    "id": 1522,
    "question": "「ABI（Application Binary Interface）」とは？",
    "options": ["A. APIと同じ", "B. バイナリレベルでの関数呼出し規約（引数渡し、レジスタ使用、スタックフレーム等のルール）", "C. アプリケーションの設計", "D. ネットワークインターフェース"],
    "correct": 1,
    "explanation": "ABIは関数の引数をどのレジスタ/スタックで渡すか、戻り値の格納先、callee/caller-savedレジスタ、構造体の配置等を規定。異なるコンパイラ間の互換性を保証。"
  },
  {
    "id": 1523,
    "question": "「RISC-V」アーキテクチャの特徴は？",
    "options": ["A. x86の後継", "B. オープンソースの命令セットアーキテクチャ(ISA)でロイヤリティフリー", "C. Intelが開発", "D. GPUアーキテクチャ"],
    "correct": 1,
    "explanation": "RISC-Vは2010年にUC Berkeleyで開発されたオープンISA。ライセンスフリーで誰でもプロセッサを設計可能。IoT、組み込み、サーバまで幅広い採用が進展中。"
  },
  {
    "id": 1524,
    "question": "「WASM（WebAssembly）」のセキュリティ上の特徴は？",
    "options": ["A. セキュリティ機能なし", "B. サンドボックス内で実行され、メモリ分離と制限されたシステムアクセスで安全性を確保", "C. OSの全機能にアクセス可能", "D. ネイティブコードと同等"],
    "correct": 1,
    "explanation": "WASMはブラウザのサンドボックス内で線形メモリ(分離された連続メモリ)上で動作し、直接的なシステムコールやファイルアクセスが制限される安全な実行環境。"
  },
  {
    "id": 1525,
    "question": "「TEE (Trusted Execution Environment)」の代表的な実装は？",
    "options": ["A. ファイアウォール", "B. Intel SGX、ARM TrustZone — CPU内の隔離された安全な実行環境", "C. VPN", "D. コンテナ"],
    "correct": 1,
    "explanation": "TEEはCPU内にハードウェアレベルで保護されたenclave(隔離領域)を作り、OSやハイパーバイザからも保護されたコード/データ実行を可能にする技術。"
  },
  {
    "id": 1526,
    "question": "「形式手法（Formal Methods）」によるソフトウェア検証とは？",
    "options": ["A. テストの自動化", "B. 数学的な証明によってプログラムの正しさを保証する手法（定理証明、モデル検査等）", "C. コードレビュー", "D. 負荷テスト"],
    "correct": 1,
    "explanation": "形式手法はCoq, Isabelle等の定理証明器やSpin, CBMC等のモデル検査器でプログラムの特性を数学的に証明。seL4マイクロカーネルやCompCertCompilerは形式的に検証済み。"
  },
  {
    "id": 1527,
    "question": "「メモリセーフティ」をシステムプログラミングで実現する言語は？",
    "options": ["A. C言語", "B. Rust（所有権システムとライフタイムにより、コンパイル時にメモリ安全性を保証）", "C. C++", "D. アセンブリ"],
    "correct": 1,
    "explanation": "Rustの所有権(ownership)、借用(borrowing)、ライフタイムシステムがコンパイル時にuse-after-free、データ競合、ダングリングポインタを防止。GCなしでメモリ安全。"
  },
  {
    "id": 1528,
    "question": "「ハードウェアセキュリティモジュール（HSM）」の用途は？",
    "options": ["A. ファイアウォール", "B. 暗号鍵を安全に生成・保管し、暗号処理を行う専用ハードウェア（耐タンパー性）", "C. ネットワーク機器", "D. ストレージ"],
    "correct": 1,
    "explanation": "HSMは暗号鍵を内部に保管し外部に出さず暗号演算を実行。物理的な解析防止(耐タンパー)機能を持つ。銀行のATMネットワーク、PKI、クラウドKMSの基盤。"
  },
  {
    "id": 1529,
    "question": "「Return-to-libc」攻撃とは？",
    "options": ["A. ライブラリのインストール", "B. NXビット環境でlibc内のsystem()等の既存関数にリターンアドレスを向けて任意コマンドを実行", "C. ライブラリの削除", "D. ライブラリの更新"],
    "correct": 1,
    "explanation": "NX(No-Execute)でスタック上のシェルコード実行が不可能な場合、libcのsystem(\"/bin/sh\")にリターンアドレスを書き換えてシェルを起動するExploit手法。ROPの前身。"
  },
  {
    "id": 1530,
    "question": "「ゼロトラストセキュリティ」の基本原則は？",
    "options": ["A. 内部は信頼", "B. 「何も信頼せず、常に検証する」— ネットワークの内外に関わらずすべてのアクセスを認証・認可", "C. ファイアウォールのみ", "D. VPNのみ"],
    "correct": 1,
    "explanation": "ゼロトラストは「ネットワーク境界の内側は安全」という前提を廃止。すべてのユーザー、デバイス、通信を検証。最小権限、マイクロセグメンテーション、継続的検証が原則。"
  }
]
