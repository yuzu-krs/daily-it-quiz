[
  {
    "id": 831,
    "question": "Javaの特徴として正しいものは？",
    "options": [
      "A. インタプリタ言語",
      "B. 「Write Once, Run Anywhere」をスローガンにJVM上で動作するコンパイル言語",
      "C. 動的型付け言語",
      "D. ポインタを直接操作できる"
    ],
    "correct": 1,
    "explanation": "JavaはソースコードをバイトコードにコンパイルしJVM上で実行するため、OSに依存せず同じコードが動作します。"
  },
  {
    "id": 832,
    "question": "Javaのガベージコレクション（GC）の役割は？",
    "options": [
      "A. コードの最適化",
      "B. 不要になったオブジェクトのメモリを自動的に解放",
      "C. 例外処理",
      "D. スレッド管理"
    ],
    "correct": 1,
    "explanation": "GCは参照されなくなったオブジェクトを検出し、ヒープメモリを自動回収します。手動のfree()が不要です。"
  },
  {
    "id": 833,
    "question": "Javaの「interface」と「abstract class」の違いは？",
    "options": [
      "A. 同じもの",
      "B. interfaceは多重実装可能で状態を持たない、abstract classは単一継承で状態を持てる",
      "C. abstract classは多重継承可能",
      "D. interfaceは実装を持てない（Java 8以前）"
    ],
    "correct": 1,
    "explanation": "interfaceはimplementsで複数実装でき、abstract classはextendsで単一継承のみ。Java 8以降interfaceもdefaultメソッドを持てます。"
  },
  {
    "id": 834,
    "question": "Javaの「final」キーワードの効果は？",
    "options": [
      "A. 変数を可変にする",
      "B. 変数は再代入不可、メソッドはオーバーライド不可、クラスは継承不可",
      "C. アクセス修飾子",
      "D. 例外処理"
    ],
    "correct": 1,
    "explanation": "finalは変数に付けると定数化、メソッドに付けるとオーバーライド禁止、クラスに付けると継承禁止になります。"
  },
  {
    "id": 835,
    "question": "Javaのジェネリクス（Generics）の目的は？",
    "options": [
      "A. 実行速度の向上",
      "B. 型安全性をコンパイル時に保証しキャストを不要にする",
      "C. メモリ削減",
      "D. 例外処理"
    ],
    "correct": 1,
    "explanation": "ジェネリクスはList<String>のように型パラメータを指定し、コンパイル時に型チェックを行いClassCastExceptionを防ぎます。"
  },
  {
    "id": 836,
    "question": "Pythonの特徴として正しいものは？",
    "options": [
      "A. コンパイル言語",
      "B. インデントでブロックを定義する動的型付けインタプリタ言語",
      "C. 静的型付け",
      "D. 中括弧でブロック定義"
    ],
    "correct": 1,
    "explanation": "Pythonはインデントでコードブロックを表現し、変数の型を宣言不要な動的型付け言語です。可読性を重視しています。"
  },
  {
    "id": 837,
    "question": "Pythonのリスト内包表記の正しい形は？",
    "options": [
      "A. [for x in range(10) x*2]",
      "B. [x*2 for x in range(10)]",
      "C. {x*2 for x in range(10)}",
      "D. (x*2 for x in range(10))"
    ],
    "correct": 1,
    "explanation": "[式 for 変数 in イテラブル] がリスト内包表記です。Cは集合、Dはジェネレータ式になります。"
  },
  {
    "id": 838,
    "question": "Pythonの「GIL（Global Interpreter Lock）」とは？",
    "options": [
      "A. メモリ管理機構",
      "B. CPythonでは一度に1つのスレッドしかバイトコードを実行できないロック",
      "C. ファイルロック",
      "D. ネットワークロック"
    ],
    "correct": 1,
    "explanation": "GILはCPythonの制限で、マルチスレッドでもCPUバウンドな処理は並列実行されません。multiprocessingで回避できます。"
  },
  {
    "id": 839,
    "question": "Pythonのデコレータ（@decorator）の役割は？",
    "options": [
      "A. クラスの継承",
      "B. 関数やクラスの振る舞いを変更・拡張するラッパー関数",
      "C. 例外処理",
      "D. 型チェック"
    ],
    "correct": 1,
    "explanation": "デコレータは関数を引数に取り、追加機能（ログ、認証、キャッシュ等）を付与した新しい関数を返す高階関数です。"
  },
  {
    "id": 840,
    "question": "Pythonのvenvの用途は？",
    "options": [
      "A. 仮想マシンの作成",
      "B. プロジェクトごとに独立したPython仮想環境を作成",
      "C. Dockerコンテナの作成",
      "D. OSの仮想化"
    ],
    "correct": 1,
    "explanation": "venvはプロジェクト固有のPython環境を作成し、パッケージの依存関係をシステムから分離します。"
  },
  {
    "id": 841,
    "question": "JavaScriptの「var」「let」「const」の違いは？",
    "options": [
      "A. すべて同じ",
      "B. varは関数スコープ、let/constはブロックスコープ。constは再代入不可",
      "C. letは再代入不可",
      "D. constはブロックスコープではない"
    ],
    "correct": 1,
    "explanation": "varは関数スコープで巻き上げ（hoisting）あり。letはブロックスコープで再代入可能、constはブロックスコープで再代入不可です。"
  },
  {
    "id": 842,
    "question": "JavaScriptのクロージャ（Closure）とは？",
    "options": [
      "A. ループ構造",
      "B. 外側の関数のスコープの変数を内側の関数が参照し続ける仕組み",
      "C. ファイルの読み込み",
      "D. DOM操作"
    ],
    "correct": 1,
    "explanation": "クロージャは関数が定義時のスコープチェーンを記憶し、外側の関数が終了しても変数にアクセスできるJSの重要な概念です。"
  },
  {
    "id": 843,
    "question": "JavaScriptの「===」と「==」の違いは？",
    "options": [
      "A. 同じ動作",
      "B. ===は型変換なしの厳密等価、==は型変換ありの抽象等価",
      "C. ===は代入",
      "D. ==の方が厳密"
    ],
    "correct": 1,
    "explanation": "===は型と値の両方が一致するかチェック。==は型が異なる場合に暗黙の型変換を行うため、予期しない結果になることがあります。"
  },
  {
    "id": 844,
    "question": "JavaScriptのPromiseの3つの状態は？",
    "options": [
      "A. start, running, done",
      "B. pending, fulfilled, rejected",
      "C. open, closed, error",
      "D. init, process, complete"
    ],
    "correct": 1,
    "explanation": "Promiseはpending（待機）→fulfilled（成功）またはrejected（失敗）の3状態を持つ非同期処理の結果を表すオブジェクトです。"
  },
  {
    "id": 845,
    "question": "JavaScriptのasync/awaitの役割は？",
    "options": [
      "A. 同期処理の強制",
      "B. Promiseベースの非同期処理を同期的に見えるコードで書ける構文糖",
      "C. マルチスレッド化",
      "D. DOM操作"
    ],
    "correct": 1,
    "explanation": "async関数はPromiseを返し、awaitでPromiseの解決を待ちます。.then()チェーンより可読性の高い非同期コードが書けます。"
  },
  {
    "id": 846,
    "question": "JavaScriptのイベントループの役割は？",
    "options": [
      "A. DOM描画",
      "B. コールスタック、タスクキュー、マイクロタスクキューを管理してシングルスレッドで非同期処理を実現",
      "C. メモリ管理",
      "D. HTTPリクエスト"
    ],
    "correct": 1,
    "explanation": "イベントループはコールスタックが空になるとタスクキューから次のタスクを取り出して実行し、非同期処理を可能にする仕組みです。"
  },
  {
    "id": 847,
    "question": "TypeScriptの最大の特徴は？",
    "options": [
      "A. 新しい言語",
      "B. JavaScriptに静的型付けを追加したスーパーセット",
      "C. Javaの派生",
      "D. サーバー専用言語"
    ],
    "correct": 1,
    "explanation": "TypeScriptはJSに型アノテーション、インターフェース、ジェネリクス等を追加し、コンパイル時に型エラーを検出します。"
  },
  {
    "id": 848,
    "question": "TypeScriptの「type」と「interface」の違いは？",
    "options": [
      "A. 同じもの",
      "B. typeはユニオン型等が定義可能、interfaceはmerge可能でクラス実装向き",
      "C. typeの方が高機能",
      "D. interfaceの方が制限的"
    ],
    "correct": 1,
    "explanation": "typeはユニオン型(|)やタプルが定義可能。interfaceは同名で自動マージされ、extendsやimplementsとの相性が良いです。"
  },
  {
    "id": 849,
    "question": "TypeScriptの「unknown」型と「any」型の違いは？",
    "options": [
      "A. 同じ",
      "B. anyは型チェック無効化、unknownは型チェックを維持し安全にnarrowingが必要",
      "C. unknownの方が危険",
      "D. anyの方が安全"
    ],
    "correct": 1,
    "explanation": "anyは全ての型チェックをバイパスし危険。unknownはどの型も代入可能ですが、使用前に型ガード等でnarrowingが必須です。"
  },
  {
    "id": 850,
    "question": "TypeScriptのジェネリクス（Generics）の利点は？",
    "options": [
      "A. コードの短縮",
      "B. 関数やクラスに型パラメータを渡して型安全なまま汎用的なコードを書ける",
      "C. 実行速度向上",
      "D. ファイルサイズ削減"
    ],
    "correct": 1,
    "explanation": "function identity<T>(arg: T): Tのように型パラメータTを使い、コード再利用性と型安全性を両立できます。"
  },
  {
    "id": 851,
    "question": "C言語のポインタとは？",
    "options": [
      "A. 変数の値",
      "B. メモリ上のアドレスを格納する変数",
      "C. 配列の別名",
      "D. 関数の戻り値"
    ],
    "correct": 1,
    "explanation": "ポインタはint *p = &x; のようにメモリアドレスを格納する変数で、間接参照（*p）で値にアクセスします。"
  },
  {
    "id": 852,
    "question": "C言語のmalloc()とfree()の関係は？",
    "options": [
      "A. 無関係",
      "B. mallocで動的にメモリ確保し、不要になったらfreeで解放する（手動メモリ管理）",
      "C. mallocは自動解放",
      "D. freeは確保用"
    ],
    "correct": 1,
    "explanation": "mallocはヒープからメモリを確保しポインタを返します。使用後はfreeで解放しないとメモリリークが発生します。"
  },
  {
    "id": 853,
    "question": "C言語のセグメンテーション違反（Segmentation Fault）の原因は？",
    "options": [
      "A. 文法エラー",
      "B. 無効なメモリアドレスへのアクセス（NULL参照、解放済みメモリ等）",
      "C. コンパイルエラー",
      "D. ファイルが見つからない"
    ],
    "correct": 1,
    "explanation": "セグフォはNULLポインタの参照、配列の範囲外アクセス、解放済みメモリの使用等でOSがプログラムを強制終了する実行時エラーです。"
  },
  {
    "id": 854,
    "question": "C言語のスタックとヒープの違いは？",
    "options": [
      "A. 同じメモリ領域",
      "B. スタックは自動管理の高速メモリ、ヒープはmalloc等で手動管理する動的メモリ",
      "C. ヒープの方が高速",
      "D. スタックは手動管理"
    ],
    "correct": 1,
    "explanation": "スタックは関数呼び出し時に自動確保・解放される局所変数用。ヒープはmalloc/freeで手動管理し、サイズや寿命を自由に制御できます。"
  },
  {
    "id": 855,
    "question": "C言語のバッファオーバーフローとは？",
    "options": [
      "A. メモリ不足",
      "B. 確保したバッファサイズを超えてデータを書き込み隣接メモリを破壊",
      "C. ファイルの読み過ぎ",
      "D. CPU過負荷"
    ],
    "correct": 1,
    "explanation": "バッファオーバーフローはgets()等で境界チェックなしにデータを書き込み、スタックやヒープを破壊する脆弱性です。"
  },
  {
    "id": 856,
    "question": "C++のRustにない特徴「多重継承」のリスクは？",
    "options": [
      "A. リスクなし",
      "B. ダイヤモンド問題（同名メンバの曖昧性）が発生する可能性",
      "C. コンパイルが速くなる",
      "D. メモリ効率が向上"
    ],
    "correct": 1,
    "explanation": "多重継承でクラスAを継承したB,CをDが継承するとAのメンバが二重に存在する菱形問題が起こり、仮想継承で解決が必要です。"
  },
  {
    "id": 857,
    "question": "C++のスマートポインタ「unique_ptr」の特徴は？",
    "options": [
      "A. 共有所有権",
      "B. 排他的所有権を持ち、コピー不可・ムーブ可能で自動でメモリ解放",
      "C. 参照カウント方式",
      "D. 手動解放が必要"
    ],
    "correct": 1,
    "explanation": "unique_ptrは1つのポインタだけがオブジェクトを所有し、スコープを抜けると自動でdeleteするRAII型スマートポインタです。"
  },
  {
    "id": 858,
    "question": "C++のスマートポインタ「shared_ptr」の特徴は？",
    "options": [
      "A. 排他的所有権",
      "B. 参照カウントで複数のポインタがオブジェクトを共有、カウント0で解放",
      "C. コピー不可",
      "D. 手動解放が必要"
    ],
    "correct": 1,
    "explanation": "shared_ptrは参照カウント方式で複数のポインタが同じオブジェクトを共有し、最後のshared_ptrが破棄されると自動解放します。"
  },
  {
    "id": 859,
    "question": "C++のRAII（Resource Acquisition Is Initialization）とは？",
    "options": [
      "A. 設計パターン",
      "B. コンストラクタでリソース獲得、デストラクタで解放する管理手法",
      "C. ガベージコレクション",
      "D. 例外処理"
    ],
    "correct": 1,
    "explanation": "RAIIはオブジェクトの生存期間とリソース管理を紐付け、デストラクタで確実にリソースを解放するC++の核心的イディオムです。"
  },
  {
    "id": 860,
    "question": "C++のムーブセマンティクスの目的は？",
    "options": [
      "A. オブジェクトのコピー",
      "B. 大きなオブジェクトの所有権を移動し不要なコピーを回避して性能向上",
      "C. メモリリークの防止",
      "D. スレッド管理"
    ],
    "correct": 1,
    "explanation": "ムーブセマンティクスはstd::moveでオブジェクトの内部リソースの所有権を移し替え、深いコピーのコストを避けます。"
  },
  {
    "id": 861,
    "question": "Go言語（Golang）の特徴は？",
    "options": [
      "A. オブジェクト指向言語",
      "B. シンプルな構文、静的型付け、ゴルーチンによる並行処理、高速コンパイル",
      "C. インタプリタ言語",
      "D. 動的型付け"
    ],
    "correct": 1,
    "explanation": "GoはGoogleが開発した静的型付けコンパイル言語で、シンプルな文法とゴルーチン/チャネルによる軽量な並行処理が特徴です。"
  },
  {
    "id": 862,
    "question": "Goのゴルーチン（goroutine）とは？",
    "options": [
      "A. OSスレッドと同じ",
      "B. Go言語のランタイムが管理する軽量な並行実行単位",
      "C. プロセス",
      "D. コルーチンと同じ"
    ],
    "correct": 1,
    "explanation": "ゴルーチンはgoキーワードで起動する軽量スレッドで、数KBのスタックで数百万個を同時実行でき、OSスレッドより遥かに軽量です。"
  },
  {
    "id": 863,
    "question": "Goのチャネル（channel）の役割は？",
    "options": [
      "A. ファイルI/O",
      "B. ゴルーチン間でデータを安全に送受信する通信機構",
      "C. ネットワーク接続",
      "D. メモリ管理"
    ],
    "correct": 1,
    "explanation": "チャネルはゴルーチン間のデータ通信手段で、ch <- valueで送信、value := <-chで受信し、同期やデータ共有を安全に行います。"
  },
  {
    "id": 864,
    "question": "Goのインターフェースの特徴は？",
    "options": [
      "A. explicitに宣言が必要",
      "B. メソッドシグネチャを満たせば暗黙的に実装される（構造的型付け）",
      "C. 継承が必要",
      "D. ジェネリクスのみ"
    ],
    "correct": 1,
    "explanation": "Goのインターフェースは暗黙的実装（Duck Typing風）で、構造体がインターフェースの全メソッドを実装していれば自動的に適合します。"
  },
  {
    "id": 865,
    "question": "Goのエラーハンドリングの特徴は？",
    "options": [
      "A. try-catch構文",
      "B. 関数が(結果, error)を返し、if err != nil で明示的にチェック",
      "C. 例外のスロー",
      "D. パニックが標準"
    ],
    "correct": 1,
    "explanation": "Goは例外機構の代わりに関数の戻り値としてerrorインターフェースを返し、呼び出し側が明示的にチェックする慣習です。"
  },
  {
    "id": 866,
    "question": "Rust言語の最大の特徴は？",
    "options": [
      "A. ガベージコレクション",
      "B. 所有権システムでメモリ安全性をコンパイル時に保証（GCなし）",
      "C. 動的型付け",
      "D. インタプリタ実行"
    ],
    "correct": 1,
    "explanation": "Rustは所有権（ownership）、借用（borrowing）、ライフタイムによりGCなしでメモリ安全性をコンパイル時に保証する言語です。"
  },
  {
    "id": 867,
    "question": "Rustの「所有権（Ownership）」の3つのルールは？",
    "options": [
      "A. 参照カウント方式",
      "B. 1つの値に1つの所有者、所有者がスコープを抜けると値はdrop、所有権は移動可能",
      "C. GCで自動管理",
      "D. 手動メモリ管理"
    ],
    "correct": 1,
    "explanation": "Rustでは①各値に所有者は1つ②所有者がスコープ外になると値はdrop③所有権はmoveで移動（コピーはCopy trait必要）。"
  },
  {
    "id": 868,
    "question": "Rustの「借用（Borrowing）」のルールは？",
    "options": [
      "A. 制限なし",
      "B. 不変参照(&T)は複数同時OK、可変参照(&mut T)は1つだけ。両方同時は不可",
      "C. 可変参照は複数OK",
      "D. 不変参照は1つだけ"
    ],
    "correct": 1,
    "explanation": "Rustでは不変参照は複数共存可能ですが、可変参照は排他的に1つのみ。データ競合をコンパイル時に防止します。"
  },
  {
    "id": 869,
    "question": "Rustの「Option<T>」型の目的は？",
    "options": [
      "A. エラー処理",
      "B. 値がある(Some(T))かない(None)かをnull参照なしで型安全に表現",
      "C. 型変換",
      "D. 並行処理"
    ],
    "correct": 1,
    "explanation": "Option<T>はnullの代わりにSome(値)またはNoneで値の有無を表現し、match式でパターン化することでnull参照エラーを防ぎます。"
  },
  {
    "id": 870,
    "question": "Rustの「Result<T, E>」型の用途は？",
    "options": [
      "A. 並行処理",
      "B. 成功(Ok(T))または失敗(Err(E))を型安全に表現するエラーハンドリング",
      "C. メモリ管理",
      "D. Option型と同じ"
    ],
    "correct": 1,
    "explanation": "Result<T, E>は関数の成功/失敗を型で表現し、?演算子でエラーを簡潔に伝播できます。例外なしで安全なエラー処理が可能。"
  },
  {
    "id": 871,
    "question": "静的型付け言語と動的型付け言語の違いは？",
    "options": [
      "A. 実行速度の違いのみ",
      "B. 静的はコンパイル時に型チェック、動的は実行時に型が決まる",
      "C. 動的の方が安全",
      "D. 静的の方が柔軟"
    ],
    "correct": 1,
    "explanation": "静的型付け（Java, C, Rust等）はコンパイル時に型エラーを検出。動的型付け（Python, JS, Ruby等）は実行時に型が決まり柔軟です。"
  },
  {
    "id": 872,
    "question": "強い型付け（Strong Typing）と弱い型付け（Weak Typing）の違いは？",
    "options": [
      "A. 同じ概念",
      "B. 強い型付けは暗黙の型変換を制限、弱い型付けは暗黙変換を許容",
      "C. 弱い型付けの方が安全",
      "D. 静的/動的と同じ"
    ],
    "correct": 1,
    "explanation": "Pythonは強い動的型付け（\"1\"+1はエラー）、JSは弱い動的型付け（\"1\"+1は\"11\"に暗黙変換）。型変換の暗黙性の度合いの違いです。"
  },
  {
    "id": 873,
    "question": "型推論（Type Inference）とは？",
    "options": [
      "A. 動的型付けと同じ",
      "B. コンパイラが文脈から変数の型を自動推定し、明示的な型宣言を省略可能",
      "C. 実行時に型を決定",
      "D. 型なしと同じ"
    ],
    "correct": 1,
    "explanation": "型推論はTypeScript, Rust, Go等で使われ、let x = 42 でコンパイラがxをint型と推定します。静的型付けの利点を保ちながらコード量を減らします。"
  },
  {
    "id": 874,
    "question": "コンパイル言語とインタプリタ言語の違いは？",
    "options": [
      "A. 実行結果が異なる",
      "B. コンパイルは事前に機械語に変換して実行、インタプリタはソースを逐次解釈実行",
      "C. インタプリタの方が高速",
      "D. コンパイルの方が柔軟"
    ],
    "correct": 1,
    "explanation": "コンパイル言語（C, Rust, Go等）は事前にネイティブコードに変換して高速実行。インタプリタ（Python, Ruby等）は逐次解釈で開発効率が高い。"
  },
  {
    "id": 875,
    "question": "JIT（Just-In-Time）コンパイルとは？",
    "options": [
      "A. 事前コンパイル",
      "B. 実行時にホットスポットを検出し動的にネイティブコードにコンパイルして高速化",
      "C. インタプリタと同じ",
      "D. ソースコードの最適化"
    ],
    "correct": 1,
    "explanation": "JITは実行中に頻繁に使われるコードを検出してネイティブコードに変換します。JVM、V8（JS）、.NET等で使われます。"
  },
  {
    "id": 876,
    "question": "AOT（Ahead-Of-Time）コンパイルとは？",
    "options": [
      "A. JITと同じ",
      "B. 実行前にソースコード全体をネイティブコードにコンパイルする方式",
      "C. インタプリタ方式",
      "D. 動的コンパイル"
    ],
    "correct": 1,
    "explanation": "AOTは実行前に完全にコンパイルするため、起動が高速でJITのウォームアップ不要。C, C++, Rust, GraalVM等が該当します。"
  },
  {
    "id": 877,
    "question": "参照カウント方式のメモリ管理の仕組みは？",
    "options": [
      "A. マーク&スイープ",
      "B. 各オブジェクトへの参照数をカウントし0になったら解放",
      "C. 手動管理",
      "D. 所有権方式"
    ],
    "correct": 1,
    "explanation": "参照カウントは各オブジェクトの参照数を追跡し、0になると即座に解放します。Python, Swift, Objective-Cで使用。循環参照が弱点。"
  },
  {
    "id": 878,
    "question": "マーク&スイープGCの仕組みは？",
    "options": [
      "A. 参照カウント",
      "B. ルートから到達可能なオブジェクトをマークし、未マークのオブジェクトを解放",
      "C. 手動管理",
      "D. 所有権方式"
    ],
    "correct": 1,
    "explanation": "マーク&スイープはGCルート（スタック変数等）から辿れるオブジェクトをマークし、マークされなかったゴミを解放するGCアルゴリズムです。"
  },
  {
    "id": 879,
    "question": "メモリリークとは？",
    "options": [
      "A. メモリの物理的破損",
      "B. 不要になったメモリが解放されず使用メモリが増加し続ける問題",
      "C. メモリの高速アクセス",
      "D. メモリの暗号化"
    ],
    "correct": 1,
    "explanation": "メモリリークは解放されるべきメモリが解放されず蓄積する問題で、長時間実行でメモリ枯渇やパフォーマンス低下を引き起こします。"
  },
  {
    "id": 880,
    "question": "ダングリングポインタとは？",
    "options": [
      "A. NULLポインタ",
      "B. 既に解放されたメモリ領域を指し続けるポインタ",
      "C. 未初期化ポインタ",
      "D. ワイルドポインタ"
    ],
    "correct": 1,
    "explanation": "ダングリングポインタはfree後もアドレスを保持するポインタで、参照するとUndefined Behavior（未定義動作）になります。"
  },
  {
    "id": 881,
    "question": "値渡しと参照渡しの違いは？",
    "options": [
      "A. 同じ動作",
      "B. 値渡しは値のコピーを渡す、参照渡しは元の変数への参照を渡して変更が反映",
      "C. 参照渡しはコピー",
      "D. 値渡しは変更が反映"
    ],
    "correct": 1,
    "explanation": "値渡しは関数に値のコピーを渡すため元の変数は変化しません。参照渡しは元の変数を直接操作するため変更が呼び出し元に反映されます。"
  },
  {
    "id": 882,
    "question": "JavaScriptのコールバック地獄（Callback Hell）とは？",
    "options": [
      "A. 高速な実行",
      "B. 非同期コールバックが深くネストして可読性が低下する状態",
      "C. メモリリーク",
      "D. 型エラー"
    ],
    "correct": 1,
    "explanation": "コールバック地獄は非同期処理のネストが深くなりピラミッド状のインデントになる問題で、Promiseやasync/awaitで解決します。"
  },
  {
    "id": 883,
    "question": "並行処理（Concurrency）と並列処理（Parallelism）の違いは？",
    "options": [
      "A. 同じ意味",
      "B. 並行は複数タスクを切替え実行、並列は複数コアで同時に実行",
      "C. 並列は切替え方式",
      "D. 並行はマルチコア必須"
    ],
    "correct": 1,
    "explanation": "並行処理はシングルコアでもタスクを切り替えて進める概念。並列処理は物理的に複数コアで同時実行する概念です。"
  },
  {
    "id": 884,
    "question": "マルチスレッドの「レースコンディション」とは？",
    "options": [
      "A. スレッドの競争",
      "B. 複数スレッドが共有データに同時アクセスし結果がタイミングに依存する問題",
      "C. デッドロック",
      "D. スレッドの終了"
    ],
    "correct": 1,
    "explanation": "レースコンディションは複数スレッドの実行順序が非決定的で、共有データの読み書きタイミングにより結果が変わるバグです。"
  },
  {
    "id": 885,
    "question": "ミューテックス（Mutex）の役割は？",
    "options": [
      "A. 非同期処理",
      "B. 共有リソースへのアクセスを1スレッドに制限する排他制御",
      "C. メモリ管理",
      "D. ネットワーク制御"
    ],
    "correct": 1,
    "explanation": "Mutexは一度に1つのスレッドだけがロックを取得してクリティカルセクションにアクセスできるようにし、レースコンディションを防ぎます。"
  },
  {
    "id": 886,
    "question": "アクターモデルとは？",
    "options": [
      "A. デザインパターン",
      "B. 各アクターが独立した状態を持ちメッセージパッシングで通信する並行計算モデル",
      "C. OOPの一種",
      "D. 関数型プログラミング"
    ],
    "correct": 1,
    "explanation": "アクターモデルは共有メモリではなくメッセージパッシングで並行処理を行うモデルで、Erlang/Elixir、Akka(Scala)で採用されています。"
  },
  {
    "id": 887,
    "question": "OOP（オブジェクト指向プログラミング）の4つの原則は？",
    "options": [
      "A. 変数、関数、クラス、モジュール",
      "B. カプセル化、継承、ポリモーフィズム、抽象化",
      "C. SOLID原則",
      "D. DRY、KISS、YAGNI、SOLID"
    ],
    "correct": 1,
    "explanation": "OOPの4原則は①カプセル化（データ隠蔽）②継承（コード再利用）③ポリモーフィズム（多態性）④抽象化（本質のみ公開）です。"
  },
  {
    "id": 888,
    "question": "カプセル化（Encapsulation）の目的は？",
    "options": [
      "A. コードの再利用",
      "B. データと操作をまとめ、外部から直接アクセスを制限して内部実装を隠蔽",
      "C. 多態性の実現",
      "D. 抽象クラスの作成"
    ],
    "correct": 1,
    "explanation": "カプセル化はprivateフィールドとpublicメソッド（getter/setter）でデータを保護し、不正な状態変更を防ぎます。"
  },
  {
    "id": 889,
    "question": "ポリモーフィズム（多態性）とは？",
    "options": [
      "A. 単一の実装",
      "B. 同じインターフェースで異なる型のオブジェクトが異なる振る舞いをする性質",
      "C. 継承と同じ",
      "D. 型変換"
    ],
    "correct": 1,
    "explanation": "ポリモーフィズムはAnimal.speak()を犬は「ワン」、猫は「ニャー」と各クラスで異なる実装にでき、統一的に扱えます。"
  },
  {
    "id": 890,
    "question": "SOLID原則の「S」Single Responsibility Principleとは？",
    "options": [
      "A. 単一継承",
      "B. クラスは変更理由が1つだけ（1つの責務のみ持つべき）",
      "C. 単一メソッド",
      "D. 単一パラメータ"
    ],
    "correct": 1,
    "explanation": "SRPはクラスが変更される理由を1つに限定し、複数の責務を持たないようにする原則です。各クラスは1つのことだけに責任を持つ。"
  },
  {
    "id": 891,
    "question": "SOLID原則の「O」Open/Closed Principleとは？",
    "options": [
      "A. 常に開いている",
      "B. 拡張に対して開き、修正に対して閉じている（既存コードを変更せず拡張）",
      "C. 常に閉じている",
      "D. ファイルのオープン/クローズ"
    ],
    "correct": 1,
    "explanation": "OCPは既存コードを変更せずに新機能を追加（拡張）できるよう、抽象やインターフェースを使って設計する原則です。"
  },
  {
    "id": 892,
    "question": "SOLID原則の「D」Dependency Inversion Principleとは？",
    "options": [
      "A. 依存関係の削除",
      "B. 上位モジュールは下位モジュールに依存せず、両方とも抽象に依存すべき",
      "C. 依存関係の増加",
      "D. 循環依存"
    ],
    "correct": 1,
    "explanation": "DIPは具体的な実装ではなくインターフェース（抽象）に依存することで、モジュール間の結合度を下げて柔軟性を高めます。"
  },
  {
    "id": 893,
    "question": "デザインパターン「Singleton」の目的は？",
    "options": [
      "A. 複数インスタンスの作成",
      "B. クラスのインスタンスが1つだけであることを保証しグローバルアクセス点を提供",
      "C. オブジェクトのコピー",
      "D. 継承の制限"
    ],
    "correct": 1,
    "explanation": "Singletonはprivateコンストラクタとstaticメソッドで唯一のインスタンスを保証します。DB接続、設定管理等に使用。"
  },
  {
    "id": 894,
    "question": "デザインパターン「Factory Method」の目的は？",
    "options": [
      "A. シングルトン",
      "B. オブジェクトの生成をサブクラスに委ね、生成する具体的な型を動的に決定",
      "C. オブジェクトのコピー",
      "D. アルゴリズムの切替え"
    ],
    "correct": 1,
    "explanation": "Factory Methodは生成するオブジェクトの型を実行時に決定し、newの直接呼び出しを避けて柔軟なオブジェクト生成を実現します。"
  },
  {
    "id": 895,
    "question": "デザインパターン「Observer」の目的は？",
    "options": [
      "A. オブジェクト生成",
      "B. あるオブジェクトの状態変化を複数のオブジェクトに自動通知する仕組み",
      "C. 構造の変換",
      "D. アルゴリズムの選択"
    ],
    "correct": 1,
    "explanation": "Observerは1対多の依存関係で、Subjectの状態変化をObserverに通知します。イベントシステム、MVC等で広く使われます。"
  },
  {
    "id": 896,
    "question": "デザインパターン「Strategy」の目的は？",
    "options": [
      "A. オブジェクト生成",
      "B. アルゴリズムをカプセル化して実行時に切り替え可能にする",
      "C. 状態の通知",
      "D. 構造の変換"
    ],
    "correct": 1,
    "explanation": "Strategyは交換可能なアルゴリズムを定義し、if-elseの代わりにインターフェースで実行時に振る舞いを動的に切り替えます。"
  },
  {
    "id": 897,
    "question": "デザインパターン「Decorator」の目的は？",
    "options": [
      "A. オブジェクトの削除",
      "B. 既存オブジェクトに動的に機能を追加する（継承の代替）",
      "C. オブジェクト生成",
      "D. 状態管理"
    ],
    "correct": 1,
    "explanation": "Decoratorはオブジェクトをラップして新しい振る舞いを追加します。継承よりも柔軟で、複数のデコレータを組み合わせ可能です。"
  },
  {
    "id": 898,
    "question": "デザインパターン「Adapter」の目的は？",
    "options": [
      "A. オブジェクトの生成",
      "B. 互換性のないインターフェースを変換して既存クラスを新しいインターフェースで使えるようにする",
      "C. アルゴリズムの切替え",
      "D. 状態通知"
    ],
    "correct": 1,
    "explanation": "Adapterは既存クラスのインターフェースをクライアントが期待するインターフェースに変換する「翻訳者」の役割を果たします。"
  },
  {
    "id": 899,
    "question": "デザインパターン「Builder」の目的は？",
    "options": [
      "A. オブジェクトの破棄",
      "B. 複雑なオブジェクトの構築過程を分離し、段階的に構築する",
      "C. 既存オブジェクトのコピー",
      "D. 状態の通知"
    ],
    "correct": 1,
    "explanation": "Builderは多数のパラメータを持つ複雑なオブジェクトを段階的に構築し、生成過程と表現を分離するパターンです。"
  },
  {
    "id": 900,
    "question": "デザインパターン「MVC」の構成要素は？",
    "options": [
      "A. Module, View, Container",
      "B. Model（データ）, View（表示）, Controller（制御）",
      "C. Main, Variable, Class",
      "D. Memory, Value, Cache"
    ],
    "correct": 1,
    "explanation": "MVCはModel（データとビジネスロジック）、View（UIの表示）、Controller（入力処理と仲介）の3つに責務を分離するアーキテクチャパターンです。"
  },
  {
    "id": 901,
    "question": "DRY原則（Don't Repeat Yourself）とは？",
    "options": [
      "A. 繰り返しを推奨",
      "B. 同じコードやロジックを繰り返さず1箇所にまとめるべきという原則",
      "C. 乾燥環境での開発",
      "D. テストの削減"
    ],
    "correct": 1,
    "explanation": "DRYは知識の重複を排除し、変更箇所を1つにすることで保守性とバグ防止を高める原則です。関数化や共通化が手段。"
  },
  {
    "id": 902,
    "question": "KISS原則（Keep It Simple, Stupid）とは？",
    "options": [
      "A. 複雑さの追求",
      "B. 設計やコードをできるだけシンプルに保つべきという原則",
      "C. 速度の最適化",
      "D. セキュリティの強化"
    ],
    "correct": 1,
    "explanation": "KISS原則は不必要な複雑さを避け、シンプルで理解しやすい設計・実装を推奨します。複雑なコードはバグの温床です。"
  },
  {
    "id": 903,
    "question": "YAGNI原則（You Aren't Gonna Need It）とは？",
    "options": [
      "A. 将来の機能を先に実装",
      "B. 現時点で必要のない機能は実装しないという原則",
      "C. 全機能を網羅",
      "D. テストの省略"
    ],
    "correct": 1,
    "explanation": "YAGNIは「今必要ないものは作るな」という原則で、将来使うかもしれない機能の過剰設計（オーバーエンジニアリング）を戒めます。"
  },
  {
    "id": 904,
    "question": "関数型プログラミングの「純粋関数」の特徴は？",
    "options": [
      "A. グローバル変数を使う",
      "B. 同じ入力に対して常に同じ出力を返し、副作用がない",
      "C. 状態を変更する",
      "D. 例外をスローする"
    ],
    "correct": 1,
    "explanation": "純粋関数は外部状態に依存せず入力のみから出力を決定し、副作用（外部変数変更、I/O等）がないため、テストや推論が容易です。"
  },
  {
    "id": 905,
    "question": "イミュータブル（不変）なデータの利点は？",
    "options": [
      "A. 常に変更可能",
      "B. 作成後に変更不可のため並行処理で安全、バグが減少、推論が容易",
      "C. メモリ消費が少ない",
      "D. パフォーマンスが高い"
    ],
    "correct": 1,
    "explanation": "イミュータブルデータは変更不可のため共有しても安全で、並行処理でのデータ競合を回避し、コードの予測可能性が向上します。"
  },
  {
    "id": 906,
    "question": "高階関数（Higher-Order Function）とは？",
    "options": [
      "A. 複雑な関数",
      "B. 関数を引数に取るか、関数を戻り値として返す関数",
      "C. 再帰関数",
      "D. コンストラクタ"
    ],
    "correct": 1,
    "explanation": "高階関数はmap、filter、reduce等のように関数を引数として受け取ったり、関数を返したりする関数です。"
  },
  {
    "id": 907,
    "question": "JavaScriptのアロー関数の特徴は？",
    "options": [
      "A. function宣言と完全に同じ",
      "B. 短い構文で、thisを外側のスコープから継承する（自身のthisを持たない）",
      "C. constructorとして使用可能",
      "D. hoistingされる"
    ],
    "correct": 1,
    "explanation": "アロー関数(=>)は簡潔な構文で、thisが定義時のスコープに束縛されます。従来のfunctionはthisが呼び出し方で変わります。"
  },
  {
    "id": 908,
    "question": "JavaScriptの「プロトタイプチェーン」とは？",
    "options": [
      "A. クラスの継承と同じ",
      "B. オブジェクトがプロパティを自身→プロトタイプ→親プロトタイプと順に検索する仕組み",
      "C. 配列のチェーン",
      "D. Promiseのチェーン"
    ],
    "correct": 1,
    "explanation": "JSのオブジェクトは__proto__でプロトタイプを参照し、プロパティが見つかるまで親を辿ります。これがJSの継承の基盤です。"
  },
  {
    "id": 909,
    "question": "TypeScriptの「Enum」の用途は？",
    "options": [
      "A. 配列の代替",
      "B. 関連する定数値の集合に名前を付けて型安全に管理",
      "C. ループ制御",
      "D. 例外処理"
    ],
    "correct": 1,
    "explanation": "Enumは関連する定数群（Direction.Up, Direction.Down等）を列挙型として定義し、マジックナンバーを排除します。"
  },
  {
    "id": 910,
    "question": "TypeScriptのユーティリティ型「Partial<T>」の動作は？",
    "options": [
      "A. 全プロパティ必須化",
      "B. 型Tの全プロパティをオプショナル（?）にした新しい型を生成",
      "C. 型の削除",
      "D. 読取り専用化"
    ],
    "correct": 1,
    "explanation": "Partial<T>はTの全プロパティにundefinedを許可するオプショナルにします。更新時に一部のフィールドだけ渡す場合等に便利です。"
  },
  {
    "id": 911,
    "question": "TypeScriptのユニオン型（Union Type）とは？",
    "options": [
      "A. 交差型",
      "B. 複数の型のいずれかを取りうる型（string | number等）",
      "C. タプル型",
      "D. ジェネリクス"
    ],
    "correct": 1,
    "explanation": "ユニオン型はlet x: string | number のように複数の型のいずれかであることを示し、型ガードでnarrowingして安全に使います。"
  },
  {
    "id": 912,
    "question": "Goの「defer」文の動作は？",
    "options": [
      "A. 即座に実行",
      "B. 関数の終了時（return後）にLIFO順で遅延実行される",
      "C. 別スレッドで実行",
      "D. エラー時のみ実行"
    ],
    "correct": 1,
    "explanation": "deferは関数のreturn後にLIFO（後入れ先出し）順で実行されます。ファイルクローズやロック解放の確実な実行に使います。"
  },
  {
    "id": 913,
    "question": "Goのスライスと配列の違いは？",
    "options": [
      "A. 同じもの",
      "B. 配列は固定長、スライスは可変長で内部的に配列への参照を持つ",
      "C. スライスは固定長",
      "D. 配列は可変長"
    ],
    "correct": 1,
    "explanation": "Goの配列は[5]intのように固定長。スライスは[]intのように可変長で、内部では配列へのポインタ、長さ、容量を持ちます。"
  },
  {
    "id": 914,
    "question": "Rustのトレイト（trait）とは？",
    "options": [
      "A. クラスの継承",
      "B. 型が実装すべきメソッドの集合を定義する（インターフェースに相当）",
      "C. 構造体の別名",
      "D. マクロ"
    ],
    "correct": 1,
    "explanation": "traitはJavaのinterfaceに似た概念で、型に共通の振る舞いを定義します。ジェネリクスの制約（トレイト境界）にも使われます。"
  },
  {
    "id": 915,
    "question": "Rustのライフタイム注釈（'a）の目的は？",
    "options": [
      "A. 変数の値を設定",
      "B. 参照の有効期間をコンパイラに伝え、ダングリング参照を防止",
      "C. 実行速度の指定",
      "D. メモリ量の指定"
    ],
    "correct": 1,
    "explanation": "ライフタイム注釈は参照がどのくらい有効かをコンパイラに伝え、参照先が先に解放される（ダングリング参照）をコンパイル時に防止します。"
  },
  {
    "id": 916,
    "question": "ジェネリックプログラミングとは？",
    "options": [
      "A. 特定の型専用",
      "B. 型をパラメータ化して複数の型で動作する汎用的なコードを書く手法",
      "C. 動的型付け",
      "D. リフレクション"
    ],
    "correct": 1,
    "explanation": "ジェネリクスは型パラメータ（<T>）でアルゴリズムやデータ構造を抽象化し、型安全性を保ちながらコードの再利用性を高めます。"
  },
  {
    "id": 917,
    "question": "Pythonのジェネレータ（Generator）とは？",
    "options": [
      "A. クラスの一種",
      "B. yieldキーワードで値を1つずつ遅延生成するイテレータ",
      "C. リストの別名",
      "D. デコレータ"
    ],
    "correct": 1,
    "explanation": "ジェネレータはyieldで値を返し、次のnext()呼び出しまで状態を保持する遅延評価イテレータです。メモリ効率に優れます。"
  },
  {
    "id": 918,
    "question": "Pythonの「with」文（コンテキストマネージャ）の目的は？",
    "options": [
      "A. ループ制御",
      "B. リソースの確実な取得と解放を保証（ファイルクローズ等）",
      "C. 条件分岐",
      "D. 例外の無視"
    ],
    "correct": 1,
    "explanation": "with文は__enter__と__exit__メソッドでリソースの取得・解放を自動管理し、例外発生時もリソースが確実に解放されます。"
  },
  {
    "id": 919,
    "question": "JavaScriptの「スプレッド構文（...）」の用途は？",
    "options": [
      "A. 変数宣言",
      "B. 配列/オブジェクトを展開、またはrest引数として可変長引数を受取る",
      "C. 型チェック",
      "D. ループ制御"
    ],
    "correct": 1,
    "explanation": "...はスプレッド（展開：[...arr, 4]）とrest（収集：function(...args){}）の2つの用途があり、配列/オブジェクト操作を簡潔にします。"
  },
  {
    "id": 920,
    "question": "JavaScriptの「分割代入（Destructuring）」とは？",
    "options": [
      "A. 変数の削除",
      "B. 配列やオブジェクトの値を個別の変数に展開して代入する構文",
      "C. 型の分割",
      "D. 関数の分割"
    ],
    "correct": 1,
    "explanation": "const {name, age} = user; やconst [a, b] = [1, 2]; のように、オブジェクト/配列から値を簡潔に取り出します。"
  },
  {
    "id": 921,
    "question": "JavaScriptのWeakMapの特徴は？",
    "options": [
      "A. Mapと同じ",
      "B. キーがオブジェクトのみで、GCによるキーの回収を妨げない弱い参照",
      "C. 値が弱い参照",
      "D. 列挙可能"
    ],
    "correct": 1,
    "explanation": "WeakMapはキーにオブジェクトのみ使用でき、他に参照がなくなるとGCに回収されます。メモリリーク防止に有用。"
  },
  {
    "id": 922,
    "question": "リフレクション（Reflection）とは？",
    "options": [
      "A. コードの最適化",
      "B. プログラムが実行時に自身の構造（クラス、メソッド等）を調査・操作する能力",
      "C. コンパイル時の最適化",
      "D. エラー処理"
    ],
    "correct": 1,
    "explanation": "リフレクションはJavaのClass.forName()、PythonのgetAttr()等で実行時にクラスの情報取得やメソッド呼び出しを動的に行います。"
  },
  {
    "id": 923,
    "question": "シリアライズ（Serialization）とは？",
    "options": [
      "A. 並列処理",
      "B. オブジェクトをバイト列やJSONに変換して保存・転送可能にすること",
      "C. 暗号化",
      "D. 圧縮"
    ],
    "correct": 1,
    "explanation": "シリアライズはメモリ上のオブジェクトをJSONやバイナリ等の形式に変換し、ファイル保存やネットワーク送信を可能にする処理です。"
  },
  {
    "id": 924,
    "question": "デザインパターン「Proxy」の目的は？",
    "options": [
      "A. オブジェクトの生成",
      "B. オブジェクトへのアクセスを代理オブジェクトが制御する（遅延読込み、アクセス制御等）",
      "C. アルゴリズムの選択",
      "D. 状態の通知"
    ],
    "correct": 1,
    "explanation": "Proxyは実オブジェクトへのアクセスを代理し、遅延初期化（Virtual Proxy）、アクセス制御、ログ記録等の機能を追加します。"
  },
  {
    "id": 925,
    "question": "デザインパターン「Iterator」の目的は？",
    "options": [
      "A. オブジェクト生成",
      "B. コレクションの内部構造を露出せずに要素を順次アクセスする方法を提供",
      "C. 状態の通知",
      "D. 構造の変換"
    ],
    "correct": 1,
    "explanation": "Iteratorはコレクション（リスト、ツリー等）の走査方法を統一インターフェースで提供し、データ構造の詳細を隠蔽します。"
  },
  {
    "id": 926,
    "question": "C言語のプリプロセッサ「#include」の役割は？",
    "options": [
      "A. ライブラリのリンク",
      "B. 指定したヘッダファイルの内容をソースコードに展開する",
      "C. 変数の定義",
      "D. 関数の呼び出し"
    ],
    "correct": 1,
    "explanation": "#includeはコンパイル前にヘッダファイル（.h）の内容をソースに文字通り挿入するプリプロセッサディレクティブです。"
  },
  {
    "id": 927,
    "question": "C++のテンプレート（template）とは？",
    "options": [
      "A. マクロ",
      "B. 型パラメータで汎用的なクラスや関数を定義するコンパイル時ジェネリクス",
      "C. 仮想関数",
      "D. 例外処理"
    ],
    "correct": 1,
    "explanation": "template<typename T>で型をパラメータ化し、コンパイル時に具体的な型で実体化されるC++のジェネリクス機構です。"
  },
  {
    "id": 928,
    "question": "Goのmap型の特徴は？",
    "options": [
      "A. 順序が保証される",
      "B. キーバリュー形式のハッシュマップで、反復順序は保証されない",
      "C. 固定サイズ",
      "D. 型安全ではない"
    ],
    "correct": 1,
    "explanation": "Goのmapはmap[string]int等のハッシュテーブルで、高速なキーアクセスが可能ですが、反復時の順序は非決定的です。"
  },
  {
    "id": 929,
    "question": "Rustのenumの特徴は？",
    "options": [
      "A. 数値定数のみ",
      "B. 各バリアントがデータを持てる代数的データ型（ADT）",
      "C. C言語のenumと同じ",
      "D. クラスと同じ"
    ],
    "correct": 1,
    "explanation": "Rustのenumは各バリアントに異なる型のデータを持てます。enum Message { Quit, Text(String), Move{x:i32, y:i32} } のように定義できます。"
  },
  {
    "id": 930,
    "question": "依存性注入（Dependency Injection）の目的は？",
    "options": [
      "A. 依存関係の増加",
      "B. オブジェクトが必要とする依存を外部から注入し、結合度を下げてテスト容易性を向上",
      "C. セキュリティ向上",
      "D. パフォーマンス向上"
    ],
    "correct": 1,
    "explanation": "DIはクラスが自身で依存オブジェクトを生成する代わりに外部から受け取ることで、モック差替えやモジュール交換を容易にします。"
  }
]
