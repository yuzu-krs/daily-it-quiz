[
  {
    "id": 865,
    "question": "「SQLインジェクション」で攻撃者が' OR '1'='1を入力する目的はどれか？",
    "options": [
      "A. データベースのテーブル構造を暗号化してランサムウェアのように身代金を要求する",
      "B. WHERE句の条件を常に真にして認証を迂回したり全データを取得したりする攻撃手法",
      "C. SQL文の構文エラーを意図的に発生させてサーバーをクラッシュさせる手法のこと",
      "D. データベースの接続プールを枯渇させてサービス拒否状態を引き起こす攻撃のこと"
    ],
    "correct": 1,
    "explanation": "' OR '1'='1はWHERE句の条件を常に真にし、認証バイパスや全レコード取得を可能にする典型的なSQLインジェクションのペイロードです。"
  },
  {
    "id": 866,
    "question": "「Reflected XSS」と「Stored XSS」の違いとして正しいものはどれか？",
    "options": [
      "A. Reflectedはサーバー側で実行されるがStoredはクライアント側で実行される攻撃",
      "B. Reflectedはリクエスト内のスクリプトが即座に反射されるがStoredはDBに永続保存される",
      "C. ReflectedはCookieを窃取できるがStoredはDOM操作のみが可能な攻撃のこと指す",
      "D. ReflectedはHTTPSでのみ有効だがStoredはHTTPでのみ有効な攻撃手法のことを指す"
    ],
    "correct": 1,
    "explanation": "Reflected XSSはURLパラメータ等に含まれたスクリプトがレスポンスに反射されて実行されます。Stored XSSはスクリプトがDB等に保存され、閲覧者全員に影響します。"
  },
  {
    "id": 867,
    "question": "「DOM Based XSS」が他のXSSと異なる特徴として正しいものはどれか？",
    "options": [
      "A. サーバーサイドのレスポンスにスクリプトが含まれてクライアントに送信される特徴",
      "B. サーバーを経由せずクライアント側のJavaScriptでDOMが動的に書き換えられて発生する",
      "C. データベースにスクリプトが永続的に保存されて全ユーザーに影響を与える特徴指す",
      "D. HTTPレスポンスヘッダーにスクリプトが挿入されてブラウザで実行される特徴のこと"
    ],
    "correct": 1,
    "explanation": "DOM Based XSSはサーバー側を経由せず、クライアント側のJavaScriptがlocation.hash等のユーザー入力をinnerHTML等で安全にDOMに挿入しないことで発生します。"
  },
  {
    "id": 868,
    "question": "「CSRF（Cross-Site Request Forgery）」の攻撃手法として正しいものはどれか？",
    "options": [
      "A. 被害者のブラウザに保存されたCookieを窃取してセッションを乗っ取る攻撃手法",
      "B. 被害者が認証済みの状態で罠サイトから意図しないリクエストを送信させる攻撃手法",
      "C. サーバーのCSRFトークンをブルートフォースで推測して不正リクエストを送信する攻撃",
      "D. 被害者のブラウザにXSSを仕掛けてCSRFトークンを無効化するための二段階攻撃手法"
    ],
    "correct": 1,
    "explanation": "CSRFは被害者が認証済み（Cookie保持）状態で罠サイトを訪問した際、被害者のブラウザが自動的にCookieを付与して意図しないリクエストを正規サイトに送信させます。"
  },
  {
    "id": 869,
    "question": "「SSRF（Server-Side Request Forgery）」の危険性として正しいものはどれか？",
    "options": [
      "A. クライアントのブラウザから内部ネットワークへの直接アクセスを可能にする攻撃手法",
      "B. サーバーを踏み台にして内部ネットワークやクラウドメタデータへアクセスできる手法",
      "C. サーバーのSSL証明書を偽造して通信を傍受できるようにするための攻撃手法のこと",
      "D. サーバーのファイアウォールルールを書き換えて外部からの接続を許可する攻撃手法"
    ],
    "correct": 1,
    "explanation": "SSRFはサーバーに内部URL（http://169.254.169.254等）をリクエストさせ、外部からアクセスできない内部サービスやクラウドメタデータを取得させる攻撃です。"
  },
  {
    "id": 870,
    "question": "「コマンドインジェクション」と「OSコマンドインジェクション」の関係はどれか？",
    "options": [
      "A. コマンドインジェクションはSQL限定で、OSコマンドインジェクションはシェル限定の攻撃",
      "B. OSコマンドインジェクションはコマンドインジェクションの一種でシェルコマンドを実行する",
      "C. コマンドインジェクションはクライアント側、OSコマンドインジェクションはサーバー側攻撃",
      "D. 両者は完全に同義であり技術文書では区別なく同じ意味で使用されている用語のこと"
    ],
    "correct": 1,
    "explanation": "コマンドインジェクションは外部コマンドを不正に実行させる攻撃の総称で、OSコマンドインジェクションはその中でもシェル（bash等）のコマンドを実行させる手法です。"
  },
  {
    "id": 871,
    "question": "「パストラバーサル」で../../etc/passwdが使われる理由として正しいものはどれか？",
    "options": [
      "A. etc/passwdファイルにはデータベースの接続パスワードが平文保存されているため",
      "B. ディレクトリを遡って公開ディレクトリ外のOS設定ファイルを読み取るための手法",
      "C. passwdファイルはWebサーバーの設定ファイルでバーチャルホスト情報が含まれるため",
      "D. Linuxでは/etc/passwdに書き込むことでroot権限のアカウントを作成できるため利用"
    ],
    "correct": 1,
    "explanation": "パストラバーサルは../でディレクトリを遡り、Webルート外のファイルにアクセスします。/etc/passwdはLinuxのユーザー情報ファイルで読み取り可能かの検証に使われます。"
  },
  {
    "id": 872,
    "question": "「ファイルアップロード攻撃」で.phpファイルをアップロードする目的はどれか？",
    "options": [
      "A. サーバーのディスク容量を圧迫してサービスを停止させるDoS攻撃が主な目的のこと",
      "B. Webシェルとして機能するPHPスクリプトをサーバー上で実行しリモート制御するため",
      "C. PHPの脆弱性を利用してサーバーのSSL証明書を自動更新させるための攻撃手法のこと",
      "D. アップロードされたPHPファイルを経由して他のユーザーにXSS攻撃を仕掛けるため"
    ],
    "correct": 1,
    "explanation": "PHPファイルのアップロードが許可されると、攻撃者はWebシェル（system($_GET['cmd'])等）をサーバーに配置し、任意のOSコマンドをリモート実行できます。"
  },
  {
    "id": 873,
    "question": "「LFI（Local File Inclusion）」と「RFI（Remote File Inclusion）」の違いはどれか？",
    "options": [
      "A. LFIはサーバー上のローカルファイルを読み込むがRFIは外部URLのファイルを読み込む",
      "B. LFIは読み取り専用だがRFIはファイルの書き込みも可能な攻撃のことを指す手法",
      "C. LFIはPHP限定の脆弱性だがRFIはすべてのプログラミング言語で発生する脆弱性のこと",
      "D. LFIはHTTPのみで動作するがRFIはFTPやSSH経由でもファイルを取得する攻撃の手法"
    ],
    "correct": 0,
    "explanation": "LFI（Local File Inclusion）はサーバーのローカルファイルをインクルードし、RFI（Remote File Inclusion）は外部URLのファイルをインクルードして実行します。"
  },
  {
    "id": 874,
    "question": "「オープンリダイレクト」の脆弱性が悪用される主なシナリオはどれか？",
    "options": [
      "A. リダイレクト先のサーバーに対してDDoS攻撃を仕掛けるためのリフレクター利用手法",
      "B. 正規ドメインのURLを経由してフィッシングサイトへ誘導しユーザーの信頼を悪用する",
      "C. リダイレクトのレスポンスヘッダーにXSSペイロードを注入して実行する攻撃の手法",
      "D. 連続リダイレクトでブラウザのスタックをオーバーフローさせてクラッシュさせる手法"
    ],
    "correct": 1,
    "explanation": "オープンリダイレクトは正規サイトのURLパラメータで任意のURLへ転送できるため、https://正規サイト.com/redirect?url=https://偽サイト.comでフィッシングに悪用されます。"
  },
  {
    "id": 875,
    "question": "「Clickjacking」の攻撃手法として正しいものはどれか？",
    "options": [
      "A. ユーザーのマウスクリック位置を記録してパスワード入力パターンを推測する攻撃",
      "B. 透明なiframeを重ねて正規サイトのボタンをユーザーに気付かせず押させる攻撃手法",
      "C. JavaScriptでクリックイベントを偽装してサーバーに不正リクエストを送信する手法",
      "D. CSSアニメーションでボタンの表示位置をずらしてユーザーの誤クリックを誘発する手法"
    ],
    "correct": 1,
    "explanation": "Clickjackingは攻撃者のページに透明なiframe（opacity:0）で正規サイトを重ね、ユーザーが見えないiframe上のボタン（削除・送金等）を押すよう誘導します。"
  },
  {
    "id": 876,
    "question": "「Host Header Injection」の攻撃で悪用されるシナリオはどれか？",
    "options": [
      "A. DNSサーバーのキャッシュを汚染して不正なIPアドレスに誘導するための攻撃手法",
      "B. パスワードリセットメールのリンクURLを攻撃者のドメインに差し替えて窃取する手法",
      "C. HTTPSの証明書検証をバイパスして中間者攻撃を可能にするための攻撃手法のこと指す",
      "D. サーバーのバーチャルホスト設定を書き換えて別のWebサイトを表示させる攻撃手法"
    ],
    "correct": 1,
    "explanation": "Host Header Injectionはパスワードリセット時にHostヘッダーを偽装し、リセットリンクのURLを攻撃者のドメインに差し替えてトークンを窃取する攻撃です。"
  },
  {
    "id": 877,
    "question": "「HTTP Request Smuggling」が発生する根本原因として正しいものはどれか？",
    "options": [
      "A. HTTPプロトコル自体にバッファオーバーフローの脆弱性が存在するためと仕様上の問題",
      "B. フロントエンドとバックエンドでContent-LengthとTransfer-Encodingの解釈が異なるため",
      "C. HTTPSの暗号化処理でリクエストの境界が曖昧になるプロトコル上の設計上の欠陥",
      "D. HTTP/2とHTTP/1.1の互換性の問題でリクエストが正しくパースされないため発生する"
    ],
    "correct": 1,
    "explanation": "HTTP Request SmugglingはProxyとバックエンドでContent-LengthとTransfer-Encoding: chunkedの優先度解釈が異なることを悪用し、リクエスト境界をずらす攻撃です。"
  },
  {
    "id": 878,
    "question": "「Prototype Pollution」の攻撃対象として正しいものはどれか？",
    "options": [
      "A. PythonのクラスのMRO（メソッド解決順序）を書き換えてコード実行する攻撃手法",
      "B. JavaScriptのObject.prototypeを汚染して全オブジェクトの挙動を変更する攻撃手法",
      "C. JavaのClassLoaderを改ざんしてマルウェアクラスをロードさせる攻撃手法のことを指す",
      "D. C++の仮想関数テーブルを上書きして任意のコードを実行させる攻撃手法のことを指す"
    ],
    "correct": 1,
    "explanation": "Prototype PollutionはJavaScriptの__proto__やconstructor.prototypeを汚染し、Object.prototypeに不正なプロパティを追加して全オブジェクトに影響を与える攻撃です。"
  },
  {
    "id": 879,
    "question": "「CORSミス設定」が悪用される条件として正しいものはどれか？",
    "options": [
      "A. Access-Control-Allow-Originがnullのみ許可されている場合に悪用される脆弱性",
      "B. Access-Control-Allow-Originがワイルドカード(*)かつCredentials許可で悪用される",
      "C. Content-Typeがapplication/jsonのみ許可されている場合に攻撃が成立する脆弱性設定",
      "D. Access-Control-Max-Ageが長時間に設定されている場合に悪用可能となる設定の問題"
    ],
    "correct": 1,
    "explanation": "CORSでAccess-Control-Allow-Origin: *とAccess-Control-Allow-Credentials: trueが同時設定されると、任意のオリジンからCookie付きリクエストが送信可能になります。"
  },
  {
    "id": 880,
    "question": "「ブルートフォース攻撃」に対する最も効果的な対策はどれか？",
    "options": [
      "A. パスワードをMD5でハッシュ化して保存することで解読を困難にする対策手法のこと",
      "B. アカウントロックアウトとレート制限を組み合わせて試行回数を制限する対策が有効",
      "C. パスワードの最大文字数を8文字に制限して計算量を減らすことで対策になる手法指す",
      "D. ログインページをHTTPSではなくHTTPで運用して通信速度を上げる対策のことを指す"
    ],
    "correct": 1,
    "explanation": "ブルートフォース対策ではアカウントロックアウト（N回失敗で一時ロック）、レート制限、CAPTCHA、多要素認証の組み合わせが有効です。MD5は安全ではありません。"
  },
  {
    "id": 881,
    "question": "「クレデンシャルスタッフィング」と「パスワードリスト攻撃」の関係はどれか？",
    "options": [
      "A. 両者は完全に別の攻撃でクレデンシャルスタッフィングはソーシャルエンジニアリング",
      "B. 流出したID/パスワードの組を別サービスに試行する攻撃で両者はほぼ同義の手法を指す",
      "C. パスワードリスト攻撃は辞書攻撃の別名でクレデンシャルスタッフィングとは異なる手法",
      "D. クレデンシャルスタッフィングはAPI経由限定でパスワードリスト攻撃はWeb限定の攻撃"
    ],
    "correct": 1,
    "explanation": "クレデンシャルスタッフィング（パスワードリスト攻撃）は他サービスから流出したID/パスワードのペアを別サービスのログインに試行するパスワード再利用を突く攻撃です。"
  },
  {
    "id": 882,
    "question": "「セッションハイジャック」の手法として正しいものはどれか？",
    "options": [
      "A. サーバーのセッション管理プログラムのソースコードを改ざんする攻撃手法のこと指す",
      "B. XSSやネットワーク盗聴でセッションIDを窃取し正規ユーザーになりすます攻撃手法",
      "C. セッションIDをブルートフォースで総当たり生成して有効なIDを発見する攻撃の手法",
      "D. サーバーのセッションストレージを直接削除して全ユーザーをログアウトさせる攻撃"
    ],
    "correct": 1,
    "explanation": "セッションハイジャックはXSS（document.cookie窃取）、ネットワーク盗聴、HTTPリファラー漏洩等でセッションIDを入手し、正規ユーザーのセッションを乗っ取ります。"
  },
  {
    "id": 883,
    "question": "「セッション固定攻撃」の手口として正しいものはどれか？",
    "options": [
      "A. 被害者のセッションIDを事後的に推測してセッションを乗っ取る攻撃手法のことを指す",
      "B. 攻撃者が事前に用意したセッションIDを被害者に使わせて認証後に乗っ取る攻撃手法",
      "C. セッションの有効期限を無期限に変更してサーバーリソースを枯渇させる攻撃のこと",
      "D. 複数のセッションIDを同時に使用して負荷分散機能を混乱させる攻撃手法のことを指す"
    ],
    "correct": 1,
    "explanation": "セッション固定攻撃は攻撃者が事前にセッションIDを設定したURLを被害者に踏ませ、被害者がログインした後にそのセッションIDで認証済みセッションを乗っ取ります。"
  },
  {
    "id": 884,
    "question": "「JWT改ざん」攻撃で「alg: none」が悪用される理由はどれか？",
    "options": [
      "A. alg: noneを指定するとJWTのペイロードが自動的に暗号化されるため安全に見える",
      "B. 署名アルゴリズムをnoneにすると署名検証がスキップされ任意のペイロードが通用する",
      "C. alg: noneはデバッグモードを表しサーバーが詳細なエラーメッセージを返すようになる",
      "D. noneアルゴリズムはJWTの有効期限チェックを無効化してトークンが永続化されるため"
    ],
    "correct": 1,
    "explanation": "JWTヘッダーのalgをnoneに変更すると署名なし（Unsecured JWT）扱いとなり、サーバーが署名検証を省略するため、攻撃者が任意のペイロードを偽造できます。"
  },
  {
    "id": 885,
    "question": "「OAuth悪用」のリダイレクトURI改ざんで起きる問題はどれか？",
    "options": [
      "A. OAuthプロバイダーのデータベースが直接書き換えられユーザーデータが漏洩する問題",
      "B. 認可コードやアクセストークンが攻撃者のサーバーに送信されセッション窃取される問題",
      "C. OAuthの認可画面がフィッシングページに書き換えられてパスワードが窃取される問題",
      "D. リフレッシュトークンの有効期限が無期限に変更されて永続的にアクセスされる問題"
    ],
    "correct": 1,
    "explanation": "redirect_uriパラメータを攻撃者の管理するURLに改ざんすると、OAuth認可コードやアクセストークンが攻撃者のサーバーに送信され、アカウントが乗っ取られます。"
  },
  {
    "id": 886,
    "question": "「多要素認証（MFA）バイパス」の手法として実在するものはどれか？",
    "options": [
      "A. MFAのQRコードをブルートフォースで総当たり生成して有効なコードを発見する手法",
      "B. リアルタイムフィッシングで被害者にMFAコードを入力させ即座に中継して認証する手法",
      "C. MFAのSMSメッセージを電波妨害して受信させないことでMFA自体を無効化する手法",
      "D. 生体認証のセンサーを磁気パルスで無効化して常に認証成功させるハードウェア攻撃"
    ],
    "correct": 1,
    "explanation": "リアルタイムフィッシング（Adversary-in-the-Middle）はフィッシングサイトで被害者のMFAコードを入力させ、リアルタイムで正規サイトに中継する高度なMFAバイパス手法です。"
  },
  {
    "id": 887,
    "question": "「アカウント列挙（Account Enumeration）」の検出方法として正しいものはどれか？",
    "options": [
      "A. サーバーのCPU使用率の変動パターンからアカウント存在の有無を推測する手法指す",
      "B. ログインやパスワードリセット時のエラーメッセージやレスポンス時間の差異を分析する",
      "C. サーバーのアクセスログに記録されたIPアドレスの国別分布を分析して検出する手法",
      "D. DNSの逆引き結果からサーバーに登録されたアカウントのドメインを推測する攻撃手法"
    ],
    "correct": 1,
    "explanation": "アカウント列挙は「メールアドレスが見つかりません」等のエラーメッセージの違いや、存在/非存在アカウントのレスポンス時間差からアカウントの存在を特定します。"
  },
  {
    "id": 888,
    "question": "「セッションハイジャック」を防ぐCookieの属性として最も重要なものはどれか？",
    "options": [
      "A. SameSite=None属性を設定してクロスサイトからのCookie送信を許可する設定のこと",
      "B. HttpOnly属性を設定してJavaScriptからのCookieアクセスを禁止する設定が最も重要",
      "C. Max-Age=0を設定してCookieの有効期限を即座に切れるように制限する設定の属性",
      "D. Domain属性をワイルドカード(*)に設定してサブドメイン全体で共有する設定のこと"
    ],
    "correct": 1,
    "explanation": "HttpOnly属性はJavaScriptのdocument.cookieからのアクセスを禁止し、XSSによるセッションID窃取を防ぎます。Secure属性やSameSiteと併用が推奨されます。"
  },
  {
    "id": 889,
    "question": "「JWT」の「RS256」と「HS256」を混同させる攻撃手法の説明はどれか？",
    "options": [
      "A. RS256のトークンをHS256に変更して公開鍵で署名検証させる誤動作を悪用する手法",
      "B. HS256の秘密鍵をブルートフォースで推測してトークンを偽造するための攻撃の手法",
      "C. RS256の秘密鍵をサーバーのメモリダンプから抽出してトークン偽造する攻撃のこと",
      "D. 両アルゴリズムを交互に指定してサーバーのキャッシュを混乱させるDoS攻撃の手法"
    ],
    "correct": 0,
    "explanation": "アルゴリズム混同攻撃はalgをRS256からHS256に書き換え、サーバーがRSA公開鍵（公開情報）をHMAC秘密鍵として使って検証するよう誘導し、偽造トークンを通します。"
  }
]
