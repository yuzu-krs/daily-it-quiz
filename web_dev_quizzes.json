[
  {
    "id": 671,
    "question": "HTMLの「セマンティックタグ」の目的として正しいものはどれか？",
    "options": [
      "A. ページの見た目を装飾するためのスタイル指定用の要素",
      "B. コンテンツの意味や構造を明示しアクセシビリティを向上",
      "C. JavaScriptの実行を制御するために使用される特殊なタグ",
      "D. フォームのバリデーションを自動的に行うための要素のこと"
    ],
    "correct": 1,
    "explanation": "セマンティックタグ（header, nav, article, section等）はコンテンツの意味を明示し、検索エンジンやスクリーンリーダーの理解を助けます。"
  },
  {
    "id": 672,
    "question": "CSSの「Flexbox」と「Grid」の使い分けとして適切なものはどれか？",
    "options": [
      "A. Flexboxは2次元レイアウト、Gridは1次元レイアウト向き",
      "B. Flexboxは1次元レイアウト、Gridは2次元レイアウト向き",
      "C. FlexboxはIE専用でGridはモダンブラウザ専用のレイアウト",
      "D. FlexboxとGridは完全に同じ機能で互換性がある仕組み活用"
    ],
    "correct": 1,
    "explanation": "Flexboxは行または列の1次元レイアウト、Gridは行と列の2次元レイアウトに適しています。目的に応じて使い分けます。"
  },
  {
    "id": 673,
    "question": "「REST API」の設計原則として正しいものはどれか？",
    "options": [
      "A. サーバーがクライアントの状態を常にセッションで保持する",
      "B. ステートレスで各リクエストが完結した情報を含む設計原則",
      "C. すべての操作をPOSTメソッドのみで実行する設計のルール",
      "D. レスポンスは必ずXML形式で返すことが仕様で定められている"
    ],
    "correct": 1,
    "explanation": "RESTはステートレスが原則で、各リクエストに必要な情報がすべて含まれます。HTTPメソッド（GET/POST/PUT/DELETE）で操作を表現します。"
  },
  {
    "id": 674,
    "question": "「GraphQL」のRESTと比較した利点として正しいものはどれか？",
    "options": [
      "A. サーバー側の実装が常にRESTより簡単になることが利点",
      "B. クライアントが必要なデータだけを指定して取得できる利点",
      "C. キャッシュ機構がRESTより優れていることが最大の利点",
      "D. すべてのブラウザでネイティブサポートされている点が利点"
    ],
    "correct": 1,
    "explanation": "GraphQLはクライアントがクエリでフィールドを指定し、必要なデータだけを取得できます。オーバーフェッチ・アンダーフェッチを防げます。"
  },
  {
    "id": 675,
    "question": "「JWT（JSON Web Token）」の構造として正しいものはどれか？",
    "options": [
      "A. ヘッダー、ボディ、フッターの3パートで構成されるトークン",
      "B. ヘッダー、ペイロード、署名の3パートで構成されるトークン",
      "C. 認証情報、認可情報、暗号鍵の3パートで構成されるトークン",
      "D. セッションID、タイムスタンプ、ハッシュで構成されるトークン"
    ],
    "correct": 1,
    "explanation": "JWTはHeader（アルゴリズム等）、Payload（クレーム）、Signature（署名）の3パートをドットで結合したトークンです。"
  },
  {
    "id": 676,
    "question": "「Cookie」と「localStorage」の違いとして正しいものはどれか？",
    "options": [
      "A. Cookieはサーバーに自動送信されるがlocalStorageは不可",
      "B. localStorageはHTTPリクエストに自動的に付与される仕組み",
      "C. Cookieは容量無制限だがlocalStorageは4KB制限がある形式",
      "D. localStorageは有効期限を設定でき自動削除される仕組み形式"
    ],
    "correct": 0,
    "explanation": "CookieはHTTPリクエストに自動付与されサーバーに送信されます。localStorageはクライアント側のみで使用され、約5MBの容量があります。"
  },
  {
    "id": 677,
    "question": "Webセッション管理で「セッションハイジャック」を防ぐ方法はどれか？",
    "options": [
      "A. セッションIDをURLパラメータに含めて管理する方法が有効",
      "B. HTTPSの使用とセッションIDの定期的な再生成が有効な対策",
      "C. セッションの有効期限を無期限に設定することが有効な対策",
      "D. セッションIDを固定値にしてキャッシュ効率を高める対策方法"
    ],
    "correct": 1,
    "explanation": "セッションハイジャック対策にはHTTPS、セッションID再生成、HttpOnly/Secure属性の設定、IP制限等が有効です。"
  },
  {
    "id": 678,
    "question": "「CORS（Cross-Origin Resource Sharing）」の目的はどれか？",
    "options": [
      "A. 同一オリジン間の通信速度を最適化するための仕組みのこと",
      "B. 異なるオリジン間でリソース共有を安全に許可する仕組み",
      "C. サーバー間のデータ同期を自動化するためのプロトコル仕組",
      "D. クライアントのキャッシュを制御するHTTPヘッダーの仕組み"
    ],
    "correct": 1,
    "explanation": "CORSはブラウザの同一オリジンポリシーを緩和し、異なるオリジンからのリソースアクセスを安全に許可する仕組みです。"
  },
  {
    "id": 679,
    "question": "「SPA（Single Page Application）」の特徴として正しいものはどれか？",
    "options": [
      "A. ページ遷移のたびにサーバーからHTML全体を再取得する方式",
      "B. 初回ロード後はJSで動的にページを更新しページ遷移しない",
      "C. サーバーサイドで全てのレンダリングを行う方式のことを指す",
      "D. 複数のHTMLページを事前に生成してキャッシュする方式のこと"
    ],
    "correct": 1,
    "explanation": "SPAは初回に必要なリソースを読み込み、以降はJavaScriptで動的にDOMを更新します。ページ全体の再読み込みが不要です。"
  },
  {
    "id": 680,
    "question": "「SSR（Server Side Rendering）」のメリットとして正しいものはどれか？",
    "options": [
      "A. クライアント側のJavaScript実行量が増加する点がメリット",
      "B. 初期表示速度の向上とSEO対策に有効である点がメリット",
      "C. サーバーの負荷が大幅に軽減される点が最大のメリットに",
      "D. ブラウザのキャッシュが不要になる点が最大のメリットになる"
    ],
    "correct": 1,
    "explanation": "SSRはサーバーでHTMLを生成して配信するため、初期表示が速く検索エンジンのクローラーがコンテンツを読み取りやすくなります。"
  },
  {
    "id": 681,
    "question": "Next.jsの「ISR（Incremental Static Regeneration）」の説明はどれか？",
    "options": [
      "A. ビルド時にすべてのページを静的生成し更新不可にする方式",
      "B. 静的生成されたページをリクエスト時に段階的に再生成する",
      "C. クライアント側で全てのレンダリングを動的に行う方式手法",
      "D. サーバーサイドで毎回HTMLを生成してキャッシュしない方式"
    ],
    "correct": 1,
    "explanation": "ISRは静的生成の利点を活かしつつ、revalidate設定により指定時間経過後にバックグラウンドでページを再生成します。"
  },
  {
    "id": 682,
    "question": "Reactの「仮想DOM」の目的として正しいものはどれか？",
    "options": [
      "A. サーバーサイドでDOMをレンダリングするための仮想環境",
      "B. 実DOMとの差分を計算し最小限の更新で効率化する仕組み",
      "C. ブラウザのDOMを完全にバイパスしCanvasで描画する方式",
      "D. DOMの構造をデータベースに永続化する仕組みのことを指す"
    ],
    "correct": 1,
    "explanation": "仮想DOMはメモリ上にDOMのコピーを保持し、変更時に差分（diff）を計算して実DOMへの更新を最小限にすることでパフォーマンスを向上させます。"
  },
  {
    "id": 683,
    "question": "HTTPステータスコード「304 Not Modified」の意味はどれか？",
    "options": [
      "A. リクエストが正常に処理されリソースが新規作成されたこと",
      "B. リソースが変更されておらずキャッシュを使用可能な状態",
      "C. リクエスト先のリソースが恒久的に移動されたことを示す",
      "D. サーバーがリクエストを処理中で完了を待つ必要がある状態"
    ],
    "correct": 1,
    "explanation": "304はリソースが前回取得時から変更されていないことを示し、クライアントはキャッシュされた内容を使用できます。"
  },
  {
    "id": 684,
    "question": "「XSS（クロスサイトスクリプティング）」の対策として正しいものはどれか？",
    "options": [
      "A. SQLクエリをパラメータ化するプリペアドステートメントの使用",
      "B. ユーザー入力のHTMLエスケープとCSPの設定が有効な対策",
      "C. パスワードをハッシュ化してデータベースに保存する対策方法",
      "D. HTTPS通信を強制してデータの暗号化を行うことが有効対策"
    ],
    "correct": 1,
    "explanation": "XSS対策にはユーザー入力のHTMLエスケープ、Content Security Policy（CSP）の設定、サニタイズ処理が有効です。"
  },
  {
    "id": 685,
    "question": "「WebSocket」の特徴として正しいものはどれか？",
    "options": [
      "A. リクエスト・レスポンス型の半二重通信プロトコルである特徴",
      "B. クライアントとサーバー間で全二重の双方向通信が可能な特徴",
      "C. HTTPと異なりTLS暗号化に対応していないプロトコルである",
      "D. RESTの代替としてCRUD操作に特化したプロトコルのこと特徴"
    ],
    "correct": 1,
    "explanation": "WebSocketはHTTPハンドシェイク後に確立される全二重通信プロトコルで、サーバーからクライアントへのプッシュ通知などに使われます。"
  },
  {
    "id": 686,
    "question": "CSSの「z-index」の動作として正しいものはどれか？",
    "options": [
      "A. すべての要素に対して絶対的な重なり順を決定する属性のこと",
      "B. positionが指定された要素のスタッキングコンテキスト内で有効",
      "C. z-indexの値が小さいほど前面に表示される仕組みの属性のこと",
      "D. インライン要素にのみ適用可能な重なり制御属性のことを指す"
    ],
    "correct": 1,
    "explanation": "z-indexはposition（static以外）が設定された要素に有効で、同一スタッキングコンテキスト内での重なり順を制御します。"
  },
  {
    "id": 687,
    "question": "「Service Worker」の機能として正しいものはどれか？",
    "options": [
      "A. DOMの操作とユーザーイベントの直接ハンドリングが機能",
      "B. オフラインキャッシュやプッシュ通知を実現するバックグラウンド処理",
      "C. サーバーサイドでNode.jsのワーカースレッドを管理する機能",
      "D. WebSocketの接続をプロキシする中間層としての機能のこと"
    ],
    "correct": 1,
    "explanation": "Service Workerはブラウザのバックグラウンドで動作し、オフラインキャッシュ、プッシュ通知、バックグラウンド同期を実現します。"
  },
  {
    "id": 688,
    "question": "Reactの「useEffect」フックの用途として正しいものはどれか？",
    "options": [
      "A. コンポーネントの状態（state）を定義・更新するためのフック",
      "B. 副作用（データ取得やDOM操作等）を処理するためのフック",
      "C. コンポーネント間のプロパティを共有するためのフックのこと",
      "D. コンポーネントのレンダリングを強制的にスキップするフック"
    ],
    "correct": 1,
    "explanation": "useEffectはコンポーネントのレンダリング後に副作用（API呼び出し、イベントリスナー設定、DOM操作等）を実行するフックです。"
  },
  {
    "id": 689,
    "question": "「CSP（Content Security Policy）」の役割として正しいものはどれか？",
    "options": [
      "A. サーバーのファイアウォール設定を制御するセキュリティ機構",
      "B. ブラウザが読み込めるリソースの出所を制限するセキュリティ",
      "C. データベースへのアクセス権限を管理するセキュリティ機構",
      "D. ネットワーク通信の暗号化方式を指定するセキュリティ機構"
    ],
    "correct": 1,
    "explanation": "CSPはHTTPヘッダーでスクリプト、スタイル、画像等の読み込み元を制限し、XSS等のクライアント攻撃を緩和するセキュリティ機構です。"
  },
  {
    "id": 690,
    "question": "「HTTP/2」の特徴として正しいものはどれか？",
    "options": [
      "A. テキストベースのプロトコルでHTTP/1.1と同じ形式を使用",
      "B. バイナリフレーム化と多重化により効率的な通信を実現する",
      "C. WebSocketを完全に置き換えるリアルタイム通信プロトコル",
      "D. 暗号化通信（TLS）を使用せずに高速通信を実現するもの"
    ],
    "correct": 1,
    "explanation": "HTTP/2はバイナリフレーム化、多重化（1接続で複数リクエスト並行処理）、ヘッダー圧縮、サーバープッシュ等で通信効率を向上させます。"
  },
  {
    "id": 691,
    "question": "「OAuth 2.0」における「アクセストークン」の役割はどれか？",
    "options": [
      "A. ユーザーのパスワードを暗号化して保存するための仕組み",
      "B. 認可されたリソースへのアクセス権を表す短命なトークン",
      "C. ユーザーの認証情報を恒久的に保存するためのトークン認証",
      "D. サーバー間の通信を暗号化するための証明書のことを指す"
    ],
    "correct": 1,
    "explanation": "アクセストークンは認可サーバーが発行し、クライアントがリソースサーバーのAPIにアクセスする際の認可証明として使用されます。"
  },
  {
    "id": 692,
    "question": "「Web Vitals」の「LCP」が計測する指標として正しいものはどれか？",
    "options": [
      "A. ページの最初のバイトがサーバーから返されるまでの時間",
      "B. ビューポート内で最も大きなコンテンツ要素の表示完了時間",
      "C. ユーザーの最初のクリックに対する応答時間のことを指す指標",
      "D. ページ内の全リソースのダウンロード完了までの時間の計測"
    ],
    "correct": 1,
    "explanation": "LCP（Largest Contentful Paint）はビューポート内で最も大きなコンテンツ（画像、テキストブロック等）の描画完了までの時間を計測します。"
  },
  {
    "id": 693,
    "question": "HTMLの「defer」属性付きscriptタグの動作として正しいものはどれか？",
    "options": [
      "A. スクリプトの読み込みと実行がHTMLパースを完全にブロック",
      "B. 非同期で読み込みHTMLパース完了後に実行順序を保証する形",
      "C. スクリプトの実行をユーザーのクリック時まで遅延させる動作",
      "D. スクリプトの読み込みを中止しエラーハンドラを呼び出す動作"
    ],
    "correct": 1,
    "explanation": "defer属性はスクリプトを非同期で読み込みつつ、HTMLパース完了後に記述順序通り実行します。asyncは読み込み完了次第実行します。"
  },
  {
    "id": 694,
    "question": "「PWA（Progressive Web App）」の必須要件として正しいものはどれか？",
    "options": [
      "A. ネイティブアプリストアでの配布が必須要件として定義される",
      "B. manifest.jsonとService Workerの実装が必須要件として定義",
      "C. WebGLを使った3Dレンダリング対応が必須要件として定義",
      "D. WebRTCを使ったビデオ通話機能の実装が必須要件として定義"
    ],
    "correct": 1,
    "explanation": "PWAにはmanifest.json（アプリ情報定義）とService Worker（オフライン対応等）の実装が必須です。HTTPS配信も要件です。"
  },
  {
    "id": 695,
    "question": "「CSRF（クロスサイトリクエストフォージェリ）」の対策はどれか？",
    "options": [
      "A. ユーザー入力をHTMLエスケープすることが有効な対策手法",
      "B. CSRFトークンをフォームに埋め込みサーバーで検証する対策",
      "C. パスワードの文字数制限を強化することが有効な対策の手法",
      "D. データベースクエリをパラメータ化することが有効な対策手法"
    ],
    "correct": 1,
    "explanation": "CSRF対策にはランダムなCSRFトークンをフォームに埋め込み、サーバー側で検証する方法が有効です。SameSite Cookie属性も有効です。"
  },
  {
    "id": 696,
    "question": "Reactの「Context API」の目的として正しいものはどれか？",
    "options": [
      "A. コンポーネントのレンダリングパフォーマンスを最適化する目的",
      "B. prop drillingを避けてコンポーネントツリー全体でデータ共有",
      "C. HTTPリクエストのコンテキスト情報を管理するAPIのことを指す",
      "D. サーバーサイドレンダリングの設定を管理するAPIのことを指す"
    ],
    "correct": 1,
    "explanation": "Context APIは中間コンポーネントを経由せず（prop drilling回避）、ツリー全体でデータを共有する仕組みです。テーマや認証情報の共有に使われます。"
  },
  {
    "id": 697,
    "question": "「npm」と「yarn」の共通点として正しいものはどれか？",
    "options": [
      "A. どちらもPythonのパッケージ管理ツールとして使われるもの",
      "B. どちらもNode.jsのパッケージ管理とバージョン管理を行う",
      "C. どちらもRubyGemsを内部的に利用しているパッケージ管理",
      "D. どちらもOSのシステムパッケージ管理を行うツールのこと指す"
    ],
    "correct": 1,
    "explanation": "npmとyarnはどちらもNode.jsのパッケージマネージャで、package.jsonからの依存関係解決とインストールを行います。"
  },
  {
    "id": 698,
    "question": "「Webpack」の主要な機能として正しいものはどれか？",
    "options": [
      "A. JavaScriptのテストフレームワークとしてテスト実行を管理",
      "B. モジュールバンドラとしてJSやアセットを1つに統合する機能",
      "C. CSSフレームワークとしてレスポンシブデザインを提供する",
      "D. データベースのマイグレーションを管理するツールのこと指す"
    ],
    "correct": 1,
    "explanation": "WebpackはJavaScriptモジュールバンドラで、JS/CSS/画像等のアセットを依存関係に基づいて1つまたは複数のバンドルに統合します。"
  },
  {
    "id": 699,
    "question": "HTMLの「<picture>」要素の目的として正しいものはどれか？",
    "options": [
      "A. 画像にフィルターやエフェクトを適用するための要素のこと",
      "B. 画面サイズや解像度に応じた最適な画像を出し分ける要素",
      "C. 画像のアニメーションを制御するための要素のことを指す要素",
      "D. 画像の著作権情報をメタデータとして埋め込む要素のこと指す"
    ],
    "correct": 1,
    "explanation": "picture要素はsource要素と組み合わせて、メディアクエリや画像フォーマットに応じたレスポンシブ画像の出し分けを実現します。"
  },
  {
    "id": 700,
    "question": "「SSG（Static Site Generation）」の特徴として正しいものはどれか？",
    "options": [
      "A. リクエストのたびにサーバーでHTMLを動的に生成する方式",
      "B. ビルド時にすべてのページをHTMLとして事前生成する方式",
      "C. クライアント側のJavaScriptで全ページを動的描画する方式",
      "D. データベースからリアルタイムにコンテンツを取得する方式流れ"
    ],
    "correct": 1,
    "explanation": "SSGはビルド時にすべてのページを静的HTMLとして生成します。CDN配信が可能で高速ですが、動的コンテンツには不向きです。"
  }
]
